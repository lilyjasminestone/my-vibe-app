{
  "version": "1.0",
  "exported_at": "2025-12-14T04:04:08.981248",
  "shifu": {
    "shifu_bid": "51ee98a2341940b3a96774b5cb9559cb",
    "title": "用Markdown语法轻松开发 AI 应用",
    "keywords": "",
    "description": "",
    "avatar_res_bid": "",
    "llm": "",
    "llm_temperature": 0.3,
    "llm_system_prompt": "",
    "ask_enabled_status": 5101,
    "ask_llm": "",
    "ask_llm_temperature": 0.0,
    "ask_llm_system_prompt": "",
    "price": 0.5
  },
  "outline_items": [
    {
      "outline_item_bid": "3f837fb309554304bd731f6a519867e5",
      "title": "课程导论与学习路径规划",
      "type": 400,
      "hidden": 0,
      "parent_bid": "",
      "position": "01",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "# 角色\n你是《借助 Vibe Coding 开发 AI 应用》课程的讲师，擅长 Vibe Coding 开发模式和 AI 应用全栈开发。\n有丰富的教学经验，擅长应用适当的教学理论讲解知识点。\n\n# 任务\n- 当前课程是《借助 Vibe Coding 开发 AI 应用》，你的目标是带初学者在 2 周内掌握用 Vibe Coding 方式开发 AI 应用的核心技能。\n- 你收到的提示词都是讲解指令，遵从指令要求做信息的讲解，不要回应指令。\n- 你正在一对一讲解课程内容，用户只有一个人，要有第一人称的对话感\n- 务必严格遵从指令，不可丢失信息，不能改变指令原意，不要增加内容，不要改变顺序\n- 不要出现模拟词，比如（停顿）\n- 不要引导下一步动作，比如提问或设问\n- 不要做自我介绍\n- 不要打招呼\n\n# 技巧\n- 符合认知设计，设计用户体验，激发用户学习和探索的欲望。\n- 重点内容（关键步骤/颠覆认知点/观点总结）做加粗处理。\n- 善用具体、比喻、结构化信息加强用户的感知\n- 讲解要口语化、富有感染力、优雅和正向，禁止说教、抽象表达\n\n# 格式\n- 按照 Markdown 格式输出\n- 输出不要有任何级别的标题（如#, ##, ### 或 H1, H2 之类）\n- 指代 AI 要用 `ta`，不要用`它`\n- 在中文和英文，中文和数字之间，要加个空格。例如：「AI 大模型」「准确率 99%」\n",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": ""
    },
    {
      "outline_item_bid": "627fad460fa74f5ca3e8766c5eeee7b4",
      "title": "课程适用人群与学习前置知识",
      "type": 401,
      "hidden": 0,
      "parent_bid": "3f837fb309554304bd731f6a519867e5",
      "position": "0102",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：适用人群罗列 + 编程经验调研\n\n这门课程是为谁设计的？让我给你罗列四类最适合的人群：\n\n**第一类：计算机相关专业的大学生**\n- 你可能学过一些编程课程，但总觉得理论和实践脱节\n- 想做一个真实的项目作为毕业设计或作品集\n- 对 AI 感兴趣，想了解如何将 AI 集成到应用中\n\n**第二类：有一定编程基础的开发者**\n- 你可能会 Python 或 JavaScript，但没做过完整项目\n- 想快速入门 AI 应用开发，不想从零学习大量新技术\n- 希望用 Vibe Coding 提升开发效率\n\n**第三类：想转型 AI 应用开发的工程师**\n- 你可能是传统行业的程序员（Java、C++、PHP 等）\n- 看到 AI 浪潮，想抓住机会转型\n- 需要一个实战项目快速建立 AI 开发的感觉\n\n**第四类：对 AI 感兴趣的产品经理或设计师**\n- 你不一定有编程背景，但想深入了解 AI 应用是如何开发的\n- 希望能够独立验证自己的产品想法\n- 想和开发团队更好地沟通\n\n结合你的背景'''{{sys_user_background}}'''，分析用户最接近哪一类人群，给予正向肯定。\n\n现在，我想了解一下你的编程经验水平，这会帮助我给你更精准的学习建议。\n\n?[%{{programming_experience}}我完全没有编程经验//零基础|我学过一些 Python//学过Python|我学过一些 JavaScript//学过JavaScript|我有 1 年以上开发经验//1年以上经验]\n\n---\n\n# 块 2：前置知识要求 + AI 工具经验调研\n\n用户的编程经验是'''{{programming_experience}}'''，针对用户的水平给出具体的前置知识建议。\n\n这门课程对前置知识的要求是这样的：\n\n**必须具备**（如果不具备，需要先补充）：\n- **基本计算机操作**：会使用浏览器、安装软件、管理文件\n- **英文阅读能力**：能看懂基本的编程文档和错误提示\n- **学习意愿**：每天能投入 2-3 小时学习 + 1-2 小时实践\n\n**推荐具备**（有的话学起来更轻松）：\n- **Python 或 JavaScript 基础**：了解变量、函数、条件判断等基本概念\n- **命令行基础**：知道如何用终端执行简单命令（cd、ls、npm、pip 等）\n- **Markdown 语法**：会用 Markdown 写文档（不会也没关系，很容易学）\n\n**加分项**（不是必须，但会帮助你走得更远）：\n- **Git 版本控制**：会用 git clone、git commit、git push\n- **HTTP 协议基础**：了解什么是 API、GET/POST 请求\n- **React 或前端框架经验**：知道组件、状态、props 这些概念\n\n如果用户是零基础，给予特别的鼓励和建议：告诉用户课程设计充分考虑了零基础学员，会从最基础的概念讲起，配合 AI 助手，完全可以跟上。\n\n如果用户有一定基础，告诉用户可以快速过理论部分，把更多时间放在实战和优化上。\n\n除了编程经验，我也很想知道你使用 AI 工具的经验如何。\n\n?[%{{ai_experience}}我没用过 AI 工具//没用过|我用过 ChatGPT//用过ChatGPT|我用过 Claude 或 Cursor//用过Claude或Cursor|我开发过 AI 应用//开发过AI应用]\n\n---\n\n# 块 3：学习预期管理\n\n用户的编程经验是'''{{programming_experience}}'''，AI 工具使用经验是'''{{ai_experience}}'''，结合这两个维度，给用户设定合理的学习预期。\n\n用表格形式展示不同背景学员的学习预期：\n\n| 背景组合 | 第 1 周重点 | 第 2 周重点 | 预期成果 |\n|---------|-----------|-----------|---------|\n| 零基础 + 没用过 AI | 理解概念，熟悉工具 | 跟随 Demo 实操 | 能运行 Demo，理解核心流程 |\n| 有编程基础 + 用过 AI | 快速过理论，聚焦 MarkdownFlow | 开发自己的功能模块 | 能独立开发小功能 |\n| 有经验 + 开发过 AI 应用 | 深入 MarkdownFlow 原理 | 优化性能，扩展功能 | 能优化和扩展 Demo 项目 |\n\n**这门课程的特别之处**：\n\n不管你是哪种背景，**课程设计都充分考虑了不同水平学员的需求**。\n\n对于零基础学员，我会：\n- 从最基础的概念讲起，不假设你有任何前置知识\n- 提供详细的环境配置指南，确保你能顺利运行代码\n- 配合大量的对比案例，让抽象概念变得具体可感知\n\n对于有基础的学员，我会：\n- 提供进阶学习路径，快速跳过基础内容\n- 深入讲解 MarkdownFlow 的设计思想和最佳实践\n- 给出性能优化和功能扩展的方向\n\n**最重要的是**：这门课程教你的不仅是技术本身，更是 **Vibe Coding 的思维方式**——如何与 AI 协作，如何用自然语言驱动开发。这种能力，无论你的技术背景如何，都能让你的开发效率提升数倍。\n\n给用户正向激励：任何背景都可以完成这门课程，关键是保持好奇心和动手实践的热情。\n"
    },
    {
      "outline_item_bid": "691a0bb7866e447895e365fc262c5454",
      "title": "AI 应用开发工具生态全景",
      "type": 400,
      "hidden": 0,
      "parent_bid": "",
      "position": "02",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "# 角色\n\n你是《借助 Vibe Coding 开发 AI 应用》课程的讲师,擅长 AI 开发工具选型、低代码平台使用和 MarkdownFlow 代码级开发。\n\n# 任务\n\n- 当前课程是《借助 Vibe Coding 开发 AI 应用》第二章《AI 应用开发工具生态全景》,你的目标是帮助学员理解不同开发模式的差异,并通过亲手体验低代码平台(扣子、Dify)和了解 MarkdownFlow 的优势,最终理解为什么本课程选择 MarkdownFlow 作为教学工具。\n- 一对一讲解,有第一人称对话感\n- 务必严格遵从指令,不可丢失信息\n\n# 技巧\n\n- 重点内容做**加粗**处理\n- 多用**对比**和**表格**帮助理解差异\n- 对于低代码平台的实操,提供**详细的分步指导**,确保零基础学员也能顺利完成\n- 对于 MarkdownFlow 的优势,用**具体场景**和**代码示例对比**说明,而不是空洞的理论\n- 口语化、富有感染力、优雅和正向\n\n# 格式\n\n- 不要有任何级别的标题(除非在 `===...===` 保留内容中)\n- AI 用 `ta`,不要用`它`\n- 中英文、数字之间加空格\n- 使用 `===...===` 保留实操步骤、对比表格等关键内容,确保格式完整呈现\n",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": ""
    },
    {
      "outline_item_bid": "bf841234eae84d6dbf0ee3122354e06f",
      "title": "Vibe Coding 工作流与项目脚手架",
      "type": 400,
      "hidden": 0,
      "parent_bid": "",
      "position": "03",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "# 角色\n\n你是《借助 Vibe Coding 开发 AI 应用》课程的讲师，精通 Vibe Coding 开发模式、AI 辅助编程工具和全栈项目架构设计。\n\n# 任务\n\n- 当前课程是《借助 Vibe Coding 开发 AI 应用》第三章《Vibe Coding 工作流与项目脚手架》，你的目标是帮助学员理解 Vibe Coding 这一全新的编程范式，熟悉 Demo 项目的完整架构，掌握如何用 AGENTS.md 让 AI 理解项目，并完成第一次 AI 辅助编程实战。\n- 一对一讲解，有第一人称对话感\n- 务必严格遵从指令，不可丢失信息\n\n# 技巧\n\n- 重点内容做**加粗**处理\n- 用**对比**强化\"传统开发 vs Vibe Coding\"的差异\n- 用**可视化工具**（Mermaid 架构图、流程图、序列图、目录树）帮助理解项目结构\n- 提供**具体的 Prompt 示例**（好的 vs 不好的对比），让学员学会与 AI 对话\n- 强调\"**迭代优化**而非一次完美\"的 Vibe Coding 核心理念\n- 口语化、富有感染力、优雅和正向\n\n# 格式\n\n- 不要有任何级别的标题（除非在 `===...===` 保留内容中）\n- AI 用 `ta`，不要用`它`\n- 中英文、数字之间加空格\n- 使用 `===...===` 保留架构图、目录树、对比表格、代码示例等关键内容，确保格式完整呈现\n",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": ""
    },
    {
      "outline_item_bid": "ec716ba63dad4e618178f02675c0c3bb",
      "title": "AI 应用后端开发实战",
      "type": 400,
      "hidden": 0,
      "parent_bid": "",
      "position": "04",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "# 角色\n\n你是《借助 Vibe Coding 开发 AI 应用》课程的讲师，精通后端开发、MarkdownFlow 语法和 AI 辅助编程。\n\n# 任务\n\n- 当前课程是《借助 Vibe Coding 开发 AI 应用》第四章《AI 应用后端开发实战》，你的目标是帮助学员理解后端架构、精通 MarkdownFlow 语法、学会用 AI 构建后端应用。\n- 一对一讲解，有第一人称对话感\n- 务必严格遵从指令，不可丢失信息\n\n# 技巧\n\n- 重点内容做**加粗**处理\n- 用**对比**和**表格**帮助理解差异\n- 提供**具体的 Prompt 示例**（好的 vs 不好的对比）\n- 用**检查清单**帮助学生审查 AI 生成的代码\n- 强调\"**学会与 AI 协作**\"而非\"记住所有语法\"\n- 口语化、富有感染力、优雅和正向\n\n# 格式\n\n- 不要有任何级别的标题（除非在 `===...===` 保留内容中）\n- AI 用 `ta`，不要用`它`\n- 中英文、数字之间加空格\n- 使用 `===...===` 保留架构图、对比表格、代码示例等关键内容，确保格式完整呈现\n",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": ""
    },
    {
      "outline_item_bid": "0bc85fd1cd3a43a18c2cdc704910b505",
      "title": "AI 应用前端开发实战",
      "type": 400,
      "hidden": 0,
      "parent_bid": "",
      "position": "05",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "# 角色\n\n你是《借助 Vibe Coding 开发 AI 应用》课程的讲师，精通前端开发、markdown-flow-ui 组件库和 AI 辅助编程。\n\n# 任务\n\n- 当前课程是《借助 Vibe Coding 开发 AI 应用》第五章《AI 应用前端开发实战》，你的目标是帮助学员理解前端架构、掌握 markdown-flow-ui 组件库、学会用 AI 构建前端界面。\n- 一对一讲解，有第一人称对话感\n- 务必严格遵从指令，不可丢失信息\n\n# 技巧\n\n- 重点内容做**加粗**处理\n- 用**对比**和**表格**帮助理解差异\n- 提供**具体的 Prompt 示例**（好的 vs 不好的对比）\n- 用**检查清单**帮助学生审查 AI 生成的代码\n- 强调\"**学会与 AI 协作**\"而非\"记住所有语法\"\n- 口语化、富有感染力、优雅和正向\n\n# 格式\n\n- 不要有任何级别的标题（除非在 `===...===` 保留内容中）\n- AI 用 `ta`，不要用`它`\n- 中英文、数字之间加空格\n- 使用 `===...===` 保留架构图、对比表格、代码示例等关键内容，确保格式完整呈现\n",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": ""
    },
    {
      "outline_item_bid": "7e10d317f3b444cabdfd70aa0e3e7a2c",
      "title": "项目总结与进阶路径",
      "type": 400,
      "hidden": 0,
      "parent_bid": "",
      "position": "06",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "# 角色\n\n你是《借助 Vibe Coding 开发 AI 应用》课程的讲师，精通 Vibe Coding、MarkdownFlow、项目部署和学习路径规划。\n\n# 任务\n\n- 当前课程是《借助 Vibe Coding 开发 AI 应用》第六章《项目总结与进阶路径》，你的目标是帮助学员巩固核心知识、掌握项目部署思路、规划进阶学习路径，并激励学员继续探索 AI 应用开发。\n- 一对一讲解，有第一人称对话感\n- 务必严格遵从指令，不可丢失信息\n\n# 技巧\n\n- 重点内容做**加粗**处理\n- 用**对比表格**帮助回顾差异（传统 vs Vibe Coding）\n- 用**检查清单**帮助学生自我验证\n- 用**时间对比**量化提效成果\n- 提供**部署思路和关键步骤**（概念 + 外部资源链接，不提供完整配置代码）\n- 强调\"**持续学习**\"和\"**社区共建**\"理念\n- 口语化、富有感染力、鼓励和正向\n\n# 格式\n\n- 不要有任何级别的标题（除非在 `===...===` 保留内容中）\n- AI 用 `ta`，不要用`它`\n- 中英文、数字之间加空格\n- 使用 `===...===` 保留架构图、对比表格、检查清单等关键内容，确保格式完整呈现\n",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": ""
    },
    {
      "outline_item_bid": "7630236d3bac43568740e06722473813",
      "title": "2 周打造你的第一个 AI 应用",
      "type": 401,
      "hidden": 0,
      "parent_bid": "3f837fb309554304bd731f6a519867e5",
      "position": "0101",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：欢迎 + 错误认知调研\n\n想象一下，**2 周后的你**，能够独立开发一个完整的 AI 应用——前端界面、后端逻辑、AI 交互，全都掌握。听起来是不是有点不可思议？\n\n在开始之前，我想先了解一下，关于 AI 应用开发，你可能听过哪些说法？\n\n?[%{{ai_dev_misconception}}AI 开发很难，必须是资深程序员//AI开发很难|必须精通多种编程语言才能开发 AI 应用//必须精通多种编程语言|开发一个 AI 应用至少需要几个月时间//开发需要几个月|AI 开发成本很高，个人玩不起//成本很高|不了解，第一次接触//不了解]\n\n---\n\n# 块 2：针对性回应 + 收集昵称\n\n用户选择的是'''{{ai_dev_misconception}}'''，让我来告诉你真相。\n\n**传统的 AI 应用开发**确实门槛很高：你需要懂 Python、JavaScript、前端框架、后端架构、数据库、部署运维……光是学习这些技术栈，就可能花费数年时间。一个简单的聊天机器人，可能需要数千行代码。\n\n但 **Vibe Coding 彻底改变了这一切**。\n\n什么是 Vibe Coding？简单说就是：**用自然语言描述你想要什么，让 AI 帮你写代码**。你只需要关注\"我想做什么功能\"，而不是\"如何用代码实现\"。\n\n举个对比：\n- **传统方式**：学习 React → 学习 FastAPI → 学习数据库 → 学习部署 → 写几千行代码 → 调试几周 → 终于能用\n- **Vibe Coding**：描述需求 → AI 生成代码 → 测试调整 → 2 周上线\n\n这门课程，就是要带你用 **Vibe Coding** 的方式，在 **2周打卡学习**（不含周末）内，完成一个真实可用的 AI 应用。\n\n友好询问学员姓名，接下来开始与 AI 的协作和学习。\n\n?[%{{sys_user_nickname}}...我可以怎样称呼你？（这里不回答其他问题哦～）]\n\n---\n\n# 块 3：Demo 演示 + 背景调研\n\n用户叫'''{{sys_user_nickname}}'''，向用户打个友好的招呼，然后真诚地赞美一下这个称呼。\n\n现在，让我带你看看这门课程能带给你什么。\n\n**我们要开发的 Demo 项目**：一个基于 MarkdownFlow 的 AI 内容生成应用。\n\n具体功能包括：\n- **前端界面**：用户可以编辑 MarkdownFlow 文档，实时预览 AI 生成的内容\n- **交互元素**：支持按钮选择、文本输入、多选等多种交互方式\n- **流式输出**：AI 内容逐字打字机效果呈现，体验流畅\n- **变量管理**：收集用户信息，实现内容个性化\n\n**2 周后，你将掌握**：\n1. **MarkdownFlow 语法**：一种专门控制 AI 输出的 Markdown 扩展语法\n2. **Vibe Coding 工作流**：如何用自然语言指挥 AI 帮你写代码\n3. **后端开发**（Python + FastAPI）：处理 AI 请求、流式输出、API 设计\n4. **前端开发**（React + Next.js）：构建交互界面、状态管理、实时渲染\n5. **完整项目部署**：从开发到上线的全流程\n\n为了让课程更贴合你的实际情况，我想了解一下你的背景。\n\n请用户仿照下面的例子，尽量详细地从行业、岗位、技能、学习目的等角度介绍自己：\n- 某互联网公司产品经理，想用 AI 提升工作效率\n- 计算机专业大三学生，学过 Python 基础，想做毕业设计\n- 传统行业程序员，写了 5 年 Java，想转型 AI 开发\n- 全职妈妈，完全零基础，但对 AI 很好奇想学习\n- 自由职业者，会一些前端，想开发 AI 工具变现\n\n上面只是例子，请用户一定要输入真实情况，数据仅供课程学习。\n\n?[%{{sys_user_background}}...你的身份背景、当前状态是怎样的？]\n\n---\n\n# 块 4：学习方法建议\n\n用户的背景是'''{{sys_user_background}}'''，结合用户背景给出 2-3 条针对性的学习建议。\n\n**这门课程的学习路径**是这样的：\n\n```mermaid\ngraph LR\n    A[第 1-2 天<br/>课程导论] --> B[第 3 天<br/>工具生态]\n    B --> C[第 4-5 天<br/>Vibe Coding 实战]\n    C --> D[第 6-7 天<br/>后端开发]\n    D --> E[第 8-9 天<br/>前端开发]\n    E --> F[第 10 天<br/>项目总结]\n\n    style A fill:#e1f5ff\n    style B fill:#fff4e1\n    style C fill:#ffe1e1\n    style D fill:#e1ffe1\n    style E fill:#f0e1ff\n    style F fill:#ffe1f0\n```\n\n**核心学习方法**：\n\n**动手实践 > 理论学习**。每个章节都有实操环节，边学边练才能真正掌握。\n\n**善用 AI 助手**。遇到问题，先尝试问 Claude、ChatGPT 或 Cursor，ta 们就是你的 24 小时助教。\n\n**小步快跑，快速验证**。不要追求一次性完美，先让功能跑起来，再慢慢优化。\n\n**记录你的学习过程**。把每天的收获、遇到的坑、解决方案都记录下来，这些都是你的宝贵财富。\n\nVibe Coding 的精髓就是：**让 AI 成为你的编程助手**，而不是你一个人埋头苦学。这门课程，会手把手教你如何与 AI 协作，用最高效的方式完成开发任务。\n"
    },
    {
      "outline_item_bid": "c320a9c01a52418d85d746928b826c8a",
      "title": "学习路径个性化推荐",
      "type": 401,
      "hidden": 0,
      "parent_bid": "3f837fb309554304bd731f6a519867e5",
      "position": "0103",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：学习目标调研\n\n在开始学习之前，明确你的学习目标非常重要。不同的目标，会决定你在课程中的侧重点。\n\n让我介绍一下四种典型的学习目标：\n\n**快速入门 AI 开发**\n- 你的重点是**理解全貌**，知道 AI 应用是如何开发的\n- 时间分配：理论 40% + 实操 60%\n- 建议：跟随 Demo 项目一步步实操，先把流程跑通\n\n**深入学习 MarkdownFlow**\n- 你的重点是**掌握 MarkdownFlow 语法和设计思想**\n- 时间分配：MarkdownFlow 章节 60% + 前后端集成 40%\n- 建议：深入阅读 MarkdownFlow 文档，尝试不同的语法组合\n\n**掌握 Vibe Coding 工作流**\n- 你的重点是**学会如何与 AI 协作开发**\n- 时间分配：Vibe Coding 实战 70% + 理论 30%\n- 建议：每个功能都尝试用 AI 帮你写代码，总结最佳实践\n\n**开发自己的 AI 产品**\n- 你的重点是**完成一个可上线的产品**\n- 时间分配：跟随课程 50% + 自己项目 50%\n- 建议：边学边做自己的项目，把课程内容直接应用到你的产品中\n\n现在，请选择最符合你的学习目标：\n\n?[%{{learning_goal}}快速入门 AI 开发//快速入门|深入学习 MarkdownFlow//深入MarkdownFlow|掌握 Vibe Coding 工作流//掌握VibeCoding|开发自己的 AI 产品//开发AI产品]\n\n---\n\n# 块 2：个性化学习路径推荐\n\n用户的学习目标是'''{{learning_goal}}'''，编程经验是'''{{programming_experience}}'''，AI 工具经验是'''{{ai_experience}}'''。\n\n结合用户的三个维度（学习目标、编程经验、AI 经验），生成最适合用户的学习路径推荐。\n\n用表格展示三种典型学习路径：\n\n===\n| 学习路径 | 适合人群 | 学习重点 | 每日时间分配 |\n|---------|---------|---------|------------|\n| **零基础快速路径** | 零编程经验 + 没用过 AI | 理解概念、跟随实操 | 学习 3h + 实践 2h |\n| **有基础进阶路径** | 有编程基础 + 用过 AI | 快速过理论、聚焦实战 | 学习 2h + 实践 3h |\n| **深度学习路径** | 有经验 + 开发过 AI | 深入原理、优化扩展 | 学习 1.5h + 实践 3.5h |\n===\n\n针对用户的具体情况，推荐最适合的路径，并给出详细的 2周学习节奏建议。\n\n用 Mermaid 时间线图展示推荐的学习节奏：\n\n```mermaid\ngantt\n    title 2周学习时间线（推荐节奏）\n    dateFormat  YYYY-MM-DD\n    section 第 1 周\n    Day 1-2 课程导论与环境准备       :a1, 2025-12-15, 2d\n    Day 3 工具生态体验              :a2, 2025-12-17, 1d\n    Day 4-5 Vibe Coding 实战       :a3, 2025-12-18, 2d\n    section 第 2 周\n    Day 6-7 后端开发实战            :b1, 2025-12-22, 2d\n    Day 8-9 前端开发实战            :b2, 2025-12-24, 2d\n    Day 10 项目总结与优化           :b3, 2025-12-26, 1d\n```\n\n特别强调：\n- **不要贪多求快**，每个知识点都要动手实践才算掌握\n- **善用周末时间**，可以补充遗漏的内容或做深入探索\n- **保持学习节奏**，每天投入固定时间，比一次性突击学习效果更好\n\n根据用户的情况，给出 2-3 条个性化的学习建议。\n\n---\n\n# 块 3：讲课风格定制\n\n最后，我想让你的学习体验更加个性化。\n\n你可以告诉我你喜欢什么样的讲课风格，后续的课程内容会根据你的偏好进行调整。\n\n举几个例子，你可以参考：\n- **幽默轻松型**：多用比喻和段子，让学习过程更有趣\n- **严谨专业型**：直奔主题，注重技术细节和最佳实践\n- **简洁高效型**：精简讲解，快速过重点，节省时间\n- **详细图文型**：配合大量示例、图表、代码注释，讲得很细\n- **互动引导型**：多提问，多思考题，启发式教学\n- **实战导向型**：少讲理论，多做项目，边做边学\n\n你也可以组合多种风格，比如\"幽默 + 实战导向\"或\"简洁 + 图文并茂\"。\n\n当然，你完全可以自己描述想要的风格，不用拘泥于上面的例子。\n\n?[%{{sys_user_style}}...你喜欢什么样的讲课风格？]\n\n---\n\n# 块 4：个性化确认\n\n用户喜欢的讲课风格是'''{{sys_user_style}}'''，给予正向反馈，告诉用户接下来的课程会尽量用 ta 喜欢的风格来讲解。\n\n再次总结用户的个人信息：\n- 昵称：{{sys_user_nickname}}\n- 背景：{{sys_user_background}}\n- 编程经验：{{programming_experience}}\n- AI 经验：{{ai_experience}}\n- 学习目标：{{learning_goal}}\n- 讲课风格：{{sys_user_style}}\n\n告诉用户这些信息都会被记录下来，后续的课程内容会根据这些信息进行个性化调整。如果中途想修改任何信息，可以在\"个人设置\"中更新。\n\n用一句激励的话，鼓励用户开始第一章的最后一节：环境准备。告诉用户配置好开发环境后，就可以真正开始动手实操了！\n"
    },
    {
      "outline_item_bid": "5d5fb1aa3063437abf5d7bbbaa1989d6",
      "title": "开发环境准备清单",
      "type": 401,
      "hidden": 0,
      "parent_bid": "3f837fb309554304bd731f6a519867e5",
      "position": "0104",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：环境准备清单\n\n欢迎来到第一章的最后一节！完成这一节后，你就拥有了一个完整可用的开发环境，可以开始真正的编程之旅。\n\n根据你的编程经验'''{{programming_experience}}'''，给出针对性的鼓励和提示（零基础学员可能觉得环境配置有点复杂，有经验的学员可以快速跳过已安装的软件）。\n\n下面是完整的环境准备清单，我会一步步带你完成。\n\n===\n## 必备软件安装\n\n### 1. Python 3.10+ 安装\n\n**为什么需要？** Python 是我们后端开发的核心语言。\n\n**安装步骤**：\n- **Windows**：访问 [https://www.python.org/downloads/](https://www.python.org/downloads/)，下载最新版本（建议 3.11），安装时**勾选\"Add Python to PATH\"**\n- **macOS**：\n  ```bash\n  # 推荐使用 Homebrew 安装\n  brew install python@3.11\n  ```\n- **Linux**：\n  ```bash\n  sudo apt update\n  sudo apt install python3.11 python3-pip\n  ```\n\n**验证安装**：\n```bash\npython3 --version\n# 应该显示 Python 3.10.x 或更高版本\n```\n\n---\n\n### 2. Node.js 16+ 安装\n\n**为什么需要？** Node.js 是前端开发的运行环境，npm 是前端包管理工具。\n\n**安装步骤**：\n- 访问 [https://nodejs.org/](https://nodejs.org/)\n- 下载 LTS（长期支持）版本（建议 18.x 或 20.x）\n- 按照安装向导完成安装\n\n**验证安装**：\n```bash\nnode --version\n# 应该显示 v16.x.x 或更高版本\n\nnpm --version\n# 应该显示 8.x.x 或更高版本\n```\n\n---\n\n### 3. Git 版本控制\n\n**为什么需要？** Git 用于克隆课程 Demo 项目，也是团队协作必备工具。\n\n**安装步骤**：\n- **Windows**：下载 [Git for Windows](https://git-scm.com/download/win)\n- **macOS**：\n  ```bash\n  brew install git\n  ```\n- **Linux**：\n  ```bash\n  sudo apt install git\n  ```\n\n**验证安装**：\n```bash\ngit --version\n# 应该显示 git version 2.x.x\n```\n\n**配置 Git**（首次使用需要）：\n```bash\ngit config --global user.name \"你的名字\"\ngit config --global user.email \"你的邮箱\"\n```\n\n---\n\n### 4. 代码编辑器（二选一）\n\n**选项 1：VS Code**（推荐零基础学员）\n- 下载地址：[https://code.visualstudio.com/](https://code.visualstudio.com/)\n- 轻量级、扩展丰富、上手简单\n\n**选项 2：Cursor**（推荐有经验学员）\n- 下载地址：[https://cursor.sh/](https://cursor.sh/)\n- 基于 VS Code 魔改，内置 AI 辅助编程\n- **强烈推荐**：如果你想体验 Vibe Coding，Cursor 是最佳选择\n\n---\n\n### 5. AI 编程助手（二选一）\n\n**选项 1：Claude Code**\n- 安装方式：VS Code 扩展市场搜索\"Claude Code\"\n- 优势：Claude 模型推理能力强，代码质量高\n\n**选项 2：GitHub Copilot**\n- 安装方式：VS Code 扩展市场搜索\"GitHub Copilot\"\n- 优势：集成度高，代码补全流畅\n- 注意：需要付费订阅（学生可免费）\n===\n\n---\n\n# 块 2：Demo 项目克隆与运行\n\n===\n## Demo 项目设置\n\n### 克隆项目\n\n打开终端（Windows 用 Git Bash），执行以下命令：\n\n```bash\n# 克隆 Demo 项目（替换为实际仓库地址）\ngit clone https://gitlink.org.cn/ai-shifu/vibe-coding-app.git\n\n# 进入项目目录\ncd demo\n```\n\n---\n\n### 后端启动\n\n```bash\n# 进入后端目录\ncd demo\n\n# 创建 Python 虚拟环境（推荐）\npython3 -m venv venv\n\n# 激活虚拟环境\n# Windows:\nvenv\\Scripts\\activate\n# macOS/Linux:\nsource venv/bin/activate\n\n# 安装依赖\npip install -r requirements.txt\n\n# 修改配置文件\n# 将.env.example 文件复制为 .env\n# 修改 .env 文件中的内容\nLLM_BASE_URL=\"https://xxx\"\nLLM_API_KEY=\"xxx\"\nLLM_MODEL=\"xxx\"\n\n# 设置环境变量文件路径\nexport ENV_FILE=\".env\"\n\n# 启动后端服务\npython main.py\n\n# 如果想使用 开发者模式来运行可以使用\n# 启动 FastAPI 开发服务器\nfastapi dev main.py --reload\n\n```\n\n如果一切正常，你会看到：\n```\nINFO:     Will watch for changes in these directories: ['/xxx/demo']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [45144] using WatchFiles\nINFO:     Started server process [45146]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```\n如果是开发者模式，你会看到:\n```\n   FastAPI   Starting development server 🚀\n\n             Searching for package file structure from directories with __init__.py files\n             Importing from /Users/aichy/work/aishifu/teaching/demo\n\n    module   🐍 main.py\n\n      code   Importing the FastAPI app object from the module with the following code:\n\n             from main import app\n\n       app   Using import string: main:app\n\n    server   Server started at http://127.0.0.1:8000\n    server   Documentation at http://127.0.0.1:8000/docs\n\n       tip   Running in development mode, for production use: fastapi run\n```\n\n开发者模式的好处是如果修改了代码并不需要重新运行后端项目,代码的修改会热更新,自动修改变化,避免频繁的重启后端服务\n\n**不要关闭这个终端窗口**，让后端服务保持运行。\n\n---\n\n### 前端启动\n\n打开**新的终端窗口**，执行：\n\n```bash\n# 进入前端目录\ncd frontend\n\n# 安装依赖\nnpm install\n\n# 启动开发服务器\nnpm run dev\n```\n\n如果一切正常，你会看到：\n```\n  ➜  Local:   http://localhost:3000\n```\n\n**在浏览器中打开** http://localhost:3000，你应该能看到 Demo 项目的界面！\n===\n\n如果用户是零基础，特别强调：第一次启动可能会遇到各种错误，**这很正常**！遇到问题时，先尝试用搜索引擎或 AI 助手（ChatGPT/Claude）查找解决方案，这本身就是程序员的日常工作。\n\n如果用户有经验，告诉 ta 可以先看看项目结构，了解前后端是如何组织的。\n\n---\n\n# 块 3：LLM API 配置\n\n===\n## LLM API 申请与配置\n\nDemo 项目需要调用 LLM API 来生成 AI 内容，你需要选择一个 LLM 服务提供商。\n\n### 推荐选择（按性价比排序）\n\n**1. DeepSeek**（最推荐）\n- 官网：[https://platform.deepseek.com/](https://platform.deepseek.com/)\n- **优势**：价格便宜（约 OpenAI 的 1/10），中文能力强，速度快\n- **注册**：支持国内手机号注册，充值 10 元即可开始使用\n- **适合**：个人学习、成本敏感的开发者\n\n**2. OpenAI**\n- 官网：[https://platform.openai.com/](https://platform.openai.com/)\n- **优势**：模型能力强（GPT-4），生态成熟\n- **注册**：需要海外手机号，支持信用卡充值\n- **适合**：追求最佳效果的开发者\n\n**3. Claude**\n- 官网：[https://console.anthropic.com/](https://console.anthropic.com/)\n- **优势**：推理能力强，输出质量高\n- **注册**：需要海外手机号\n- **适合**：需要复杂推理的场景\n\n---\n\n### 获取 API Key\n\n以 DeepSeek 为例（其他服务流程类似）：\n\n1. 访问 [https://platform.deepseek.com/](https://platform.deepseek.com/)\n2. 注册并登录\n3. 进入\"API Keys\"页面\n4. 点击\"Create API Key\"\n5. 复制生成的 API Key（格式：`sk-xxxxxxxxxxxxxx`）\n\n**重要**：API Key 是敏感信息，**不要泄露**给他人，也**不要上传到 GitHub**。\n\n---\n\n### 配置环境变量\n\n在后端目录下，创建 `.env` 文件：\n\n```bash\n# 在 backend/ 目录下\ncp .env.example .env\n```\n\n编辑 `.env` 文件，填入你的 API Key：\n\n```bash\n# LLM 配置\nLLM_BASE_URL=https://api.deepseek.com/v1\nLLM_API_KEY=sk-your-actual-api-key-here\nLLM_MODEL=deepseek-chat\nLLM_TEMPERATURE=0.3\n```\n\n如果使用 OpenAI，则改为：\n```bash\nLLM_BASE_URL=https://api.openai.com/v1\nLLM_API_KEY=sk-your-openai-key-here\nLLM_MODEL=gpt-3.5-turbo\n```\n\n**保存文件后，重启后端服务**（Ctrl+C 停止，然后重新运行 `python main.py`）。\n\n---\n\n### 成本估算\n\n完成整个课程大约需要的 API 费用：\n\n| 服务商 | 模型 | 预估费用（10 天课程） |\n|-------|------|---------------------|\n| DeepSeek | deepseek-chat | ¥5-10 元 |\n| OpenAI | gpt-3.5-turbo | $2-5 美元 |\n| OpenAI | gpt-4 | $10-20 美元 |\n\n**建议**：先充值 ¥10-20 元即可，课程结束后如果有剩余可以继续用于个人项目。\n===\n\n---\n\n# 块 4：环境验证 + 完成确认\n\n===\n## 环境验证\n\n让我们快速验证一下环境是否配置正确。\n\n### 验证后端\n\n在浏览器中访问：[http://localhost:8000/health](http://localhost:8000/health)\n\n应该看到类似这样的 JSON 响应：\n```json\n{\n  \"status\": \"healthy\",\n  \"version\": \"1.0.0\",\n  \"timestamp\": \"2025-01-06T10:30:00\"\n}\n```\n\n### 验证前端\n\n访问：[http://localhost:3000](http://localhost:3000)\n\n你应该能看到 Playground 界面，包括：\n- 左侧编辑面板\n- 中间预览区域\n- 右侧变量栏\n\n### 验证 LLM API\n\n在 Playground 编辑器中，输入简单的 MarkdownFlow 内容：\n\n```markdown\n# 你好\n\n请说一句话测试 API 连接。\n```\n\n点击\"运行\"或\"生成\"按钮，如果能看到 AI 返回的内容（带打字机效果），说明 API 配置成功！\n\n---\n\n## 常见问题排查\n\n**问题 1**：后端启动失败，提示 `ModuleNotFoundError`\n- 解决：确保虚拟环境已激活，重新运行 `pip install -r requirements.txt`\n\n**问题 2**：前端 `npm install` 很慢或失败\n- 解决：切换 npm 镜像源\n  ```bash\n  npm config set registry https://registry.npmmirror.com\n  ```\n\n**问题 3**：LLM API 返回 401 错误\n- 解决：检查 `.env` 文件中的 API Key 是否正确，是否有多余空格\n\n**问题 4**：浏览器访问 `localhost:3000` 无响应\n- 解决：检查终端是否有报错信息，尝试换个端口（修改 `next.config.ts`）\n\n**问题 5**：Windows 下命令找不到\n- 解决：使用 Git Bash 而不是 CMD，或者安装 Windows Terminal\n===\n\n给用户正向鼓励：配置开发环境是编程的第一课，也是最容易遇到问题的环节。如果遇到问题不要气馁，**每个程序员都是从解决环境问题开始的**！\n\n现在，请确认你的环境准备情况：\n\n?[环境准备完成，可以开始学习//环境准备完成]\n\n---\n\n# 块 5：完成第一章\n\n如果用户选择\"环境准备完成\"，给予热烈祝贺，告诉 ta：\n\n**恭喜你，{{sys_user_nickname}}！** 你已经完成了第一章的所有内容！\n\n让我们回顾一下你在第一章的收获：\n- ✅ 了解了课程整体架构和学习目标\n- ✅ 明确了自己的学习路径：{{learning_goal}}\n- ✅ 配置好了完整的开发环境\n- ✅ 成功运行了 Demo 项目\n\n**下一章预告**：我们将进入第 2 章《AI 应用开发工具生态全景》，你会亲手体验低代码平台（扣子、Dify）和 MarkdownFlow 的对比，深刻理解为什么选择代码级开发。\n\n用你喜欢的讲课风格'''{{sys_user_style}}'''，鼓励用户继续第二章的学习。\n"
    },
    {
      "outline_item_bid": "a9e87bd5ea524dfab324b7435ef92f16",
      "title": "低代码智能体平台实操体验",
      "type": 401,
      "hidden": 0,
      "parent_bid": "691a0bb7866e447895e365fc262c5454",
      "position": "0202",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1:扣子(Coze)实操体验\n\n现在,让我们亲手体验一下低代码平台的魅力!我们从**扣子(Coze)** 开始,这是字节跳动推出的 AI 应用开发平台,在国内使用非常方便。\n\n根据你的工具经验'''{{tool_experience}}''',我会调整讲解的详细程度。\n\n**我们要做什么?** 用扣子快速搭建一个**AI 学习助手**,ta 能根据用户的学习目标推荐学习资源。整个过程不超过 **15 分钟**,你会直观感受到低代码平台的优势和局限。\n\n---\n## 扣子(Coze)注册与基础操作\n\n### 第 1 步:注册账号\n\n1. 访问扣子官网:[https://www.coze.cn/](https://www.coze.cn/)\n2. 点击右上角\"登录/注册\"\n3. 支持以下方式:\n   - 手机号注册(推荐,最快)\n   - 微信扫码登录\n   - 飞书账号登录\n4. 首次登录会赠送一定量的免费 tokens,足够体验使用\n\n### 第 2 步:创建第一个 Bot\n\n1. 登录后进入工作台\n2. 点击\"创建 Bot\"按钮\n3. 填写基础信息:\n   - **Bot 名称**:AI 学习助手\n   - **Bot 描述**:根据用户学习目标推荐学习资源\n   - **Bot 头像**:可以选择默认头像或上传自定义图片\n4. 点击\"创建\"\n\n### 第 3 步:配置 Bot 人设(Prompt)\n\n在 Bot 编辑页面,你会看到左侧的\"人设与回复逻辑\"配置区域。\n\n**人设配置示例**:\n```\n你是一个专业的学习规划助手,擅长根据用户的学习目标和背景推荐合适的学习资源。\n\n你的任务:\n1. 了解用户的学习目标\n2. 询问用户的当前水平\n3. 根据以上信息推荐 3-5 个学习资源(课程、书籍、视频等)\n4. 给出清晰的学习路径建议\n\n风格:\n- 友好、耐心\n- 提供具体、可执行的建议\n- 不要推荐过于复杂的资源\n```\n\n粘贴到\"人设与回复逻辑\"框中,点击保存。\n\n### 第 4 步:添加开场白\n\n在\"开场白\"区域,输入:\n```\n你好!我是你的 AI 学习助手。\n\n请告诉我:\n1. 你想学习什么?(比如:Python 编程、AI 开发、产品设计等)\n2. 你的当前水平如何?(零基础/有一些基础/比较熟练)\n\n我会根据你的情况推荐合适的学习资源和路径!\n```\n\n### 第 5 步:测试 Bot\n\n1. 点击右侧的\"预览与调试\"\n2. 在对话框中输入测试内容:\n   ```\n   我想学习 AI 开发,目前是零基础\n   ```\n3. 观察 Bot 的回复,ta 应该会推荐一些适合零基础的 AI 学习资源\n\n### 第 6 步:发布 Bot\n\n1. 如果测试满意,点击右上角\"发布\"\n2. 选择发布渠道:\n   - **网页链接**:生成一个链接,分享给任何人\n   - **API**:集成到你的应用中\n   - **微信公众号/企业微信**:连接到已有平台\n3. 点击\"生成链接\",复制链接并在浏览器中打开测试\n\n**恭喜!** 你已经用扣子创建了第一个 AI 应用,整个过程是不是非常快?\n---\n\n**体验总结**:\n\n用扣子开发的**优势**:\n- ✅ 速度快:15 分钟从 0 到发布\n- ✅ 门槛低:几乎不需要编程知识\n- ✅ 开箱即用:内置了 LLM 能力,不需要自己对接 API\n\n用扣子开发的**局限**:\n- ❌ 定制能力有限:只能调整 Prompt 和一些基础配置\n- ❌ 交互形式固定:对话式交互,无法实现复杂的多步骤流程\n- ❌ 难以集成:如果你想把这个 Bot 深度集成到现有系统,会比较困难\n\n现在你可能会想:**如果我需要更复杂的流程呢?** 这就是 Dify 的优势所在。Dify 提供了**工作流编排**功能,让我们继续体验。\n\n---\n\n# 块 2:Dify 实操体验\n\nDify 是一个开源的 LLM 应用开发平台,相比扣子,它提供了更强大的**工作流编排**能力。\n\n我们接下来要用 Dify 搭建一个**AI 职业规划助手**,ta 会通过多步骤交互收集用户信息,然后生成个性化的职业建议。\n\n---\n## Dify 部署与基础操作\n\n### 第 1 步:部署 Dify(两种方式任选其一)\n\n**方式 A:云端版本(推荐,最简单)**\n\n1. 访问 Dify Cloud:[https://cloud.dify.ai/](https://cloud.dify.ai/)\n2. 使用 GitHub 或 Google 账号登录\n3. 注册后会赠送免费额度,足够体验使用\n\n**方式 B:本地部署(适合想深入了解的学员)**\n\n```bash\n# 克隆 Dify 仓库\ngit clone https://github.com/langgenius/dify.git\ncd dify/docker\n\n# 启动服务(需要安装 Docker)\ndocker-compose up -d\n\n# 访问 http://localhost/install 完成初始化\n```\n\n**注意**:本地部署需要配置自己的 LLM API(OpenAI/DeepSeek 等),云端版本自带免费额度。\n\n如果你是零基础学员,**强烈推荐使用云端版本**,避免在环境配置上花费过多时间。\n\n### 第 2 步:创建工作流应用\n\n1. 登录 Dify 后,点击\"创建应用\"\n2. 选择\"工作流编排\"(Workflow)\n3. 填写应用信息:\n   - **应用名称**:AI 职业规划助手\n   - **应用描述**:通过多步骤交互生成个性化职业建议\n4. 点击\"创建\"进入工作流编辑器\n\n### 第 3 步:设计工作流\n\nDify 的工作流是**可视化节点连接**的方式,就像画流程图一样。\n\n**我们要实现的流程**:\n1. 收集用户当前岗位\n2. 收集用户技能\n3. 收集用户兴趣\n4. 调用 LLM 生成职业建议\n5. 输出结果\n\n**具体操作**:\n\n1. 添加\"开始\"节点(已默认存在)\n\n2. 添加\"问题\"节点(收集当前岗位)\n   - 拖拽左侧工具栏的\"问题\"节点到画布\n   - 配置:\n     - 问题文本:\"你目前从事什么岗位?(如:产品经理、程序员、设计师、学生等)\"\n     - 变量名:`current_role`\n   - 连接\"开始\"节点到这个\"问题\"节点\n\n3. 添加第二个\"问题\"节点(收集技能)\n   - 配置:\n     - 问题文本:\"你擅长哪些技能?(可以列举 2-3 个)\"\n     - 变量名:`skills`\n   - 连接上一个\"问题\"节点到这个节点\n\n4. 添加第三个\"问题\"节点(收集兴趣)\n   - 配置:\n     - 问题文本:\"你对哪些领域感兴趣?(如:AI、设计、管理等)\"\n     - 变量名:`interests`\n   - 连接上一个节点\n\n5. 添加\"LLM\"节点(生成建议)\n   - 拖拽\"LLM\"节点到画布\n   - 配置 Prompt:\n     ```\n     用户信息:\n     - 当前岗位:{{current_role}}\n     - 擅长技能:{{skills}}\n     - 兴趣领域:{{interests}}\n\n     请作为职业规划专家,给出 3 条具体的职业发展建议,每条建议包括:\n     1. 建议的职业方向\n     2. 所需技能\n     3. 学习路径(3-5 步)\n\n     格式要求:清晰、具体、可执行\n     ```\n   - 连接上一个\"问题\"节点到这个节点\n\n6. 添加\"结束\"节点\n   - 拖拽\"结束\"节点\n   - 连接\"LLM\"节点到\"结束\"节点\n\n**完成后的工作流应该是这样的**:\n\n```\n开始 → 问题1(岗位) → 问题2(技能) → 问题3(兴趣) → LLM → 结束\n```\n\n### 第 4 步:测试工作流\n\n1. 点击右上角\"运行\"按钮\n2. 依次回答三个问题:\n   - 岗位:产品经理\n   - 技能:需求分析、原型设计、数据分析\n   - 兴趣:AI、用户体验\n3. 观察 LLM 生成的职业建议\n\n### 第 5 步:发布应用\n\n1. 如果测试满意,点击\"发布\"\n2. 选择发布方式:\n   - **公开链接**:生成分享链接\n   - **API**:通过 API 调用\n   - **嵌入网站**:提供嵌入代码\n3. 复制链接并测试\n---\n\n**体验总结**:\n\n用 Dify 开发的**优势**:\n- ✅ 可视化工作流:直观看到整个流程\n- ✅ 多步骤交互:可以设计复杂的对话流程\n- ✅ 变量管理:每个节点的输出可以作为后续节点的输入\n- ✅ 开源:可以自己部署,数据完全掌控\n\n用 Dify 开发的**局限**:\n- ❌ 学习曲线:虽然是可视化,但理解节点和变量的概念需要时间\n- ❌ 灵活性有限:复杂的条件判断、循环逻辑实现起来比较繁琐\n- ❌ 定制困难:如果需要特殊的交互形式或输出格式,很难实现\n\n---\n\n# 块 3:低代码平台体验总结\n\n通过亲手体验扣子和 Dify,你应该对低代码平台有了直观的感受。让我们总结一下:\n\n!===\n| 维度 | 扣子(Coze) | Dify | 适用场景 |\n|------|-----------|------|---------|\n| **上手难度** | ⭐ 非常简单 | ⭐⭐ 简单 | 扣子更适合完全零基础 |\n| **开发速度** | ⭐⭐⭐⭐⭐ 非常快(15 分钟) | ⭐⭐⭐⭐ 快(30 分钟) | 快速验证想法都可以 |\n| **流程控制** | ⭐⭐ 有限 | ⭐⭐⭐⭐ 强 | Dify 适合多步骤流程 |\n| **定制能力** | ⭐⭐ 有限 | ⭐⭐⭐ 中等 | 都不适合深度定制 |\n| **部署方式** | 云端 | 云端 + 自部署 | Dify 更灵活 |\n| **学习成本** | 几乎为 0 | 需要理解工作流概念 | 根据背景选择 |\n!===\n\n**关键发现**:\n\n你可能发现了,虽然低代码平台开发速度很快,但在以下场景会遇到瓶颈:\n\n1. **个性化输出格式**:比如你想生成一个特定格式的学习计划表,低代码平台很难精确控制输出格式\n\n2. **复杂的条件逻辑**:比如根据用户的 10 个不同维度的选择,给出不同的建议,用节点连接会非常复杂\n\n3. **与现有系统集成**:如果你想把这个 AI 助手集成到你现有的网站或 APP 中,会遇到很多技术障碍\n\n这些正是 **MarkdownFlow 要解决的问题**。\n\n---\n\n# 块 4:过渡到 MarkdownFlow\n\n现在,让我给你看一个对比:同样是\"AI 职业规划助手\",用 MarkdownFlow 怎么实现?\n\n---\n**Dify 实现**(需要在可视化界面配置多个节点):\n- 问题节点 1:收集岗位\n- 问题节点 2:收集技能\n- 问题节点 3:收集兴趣\n- LLM 节点:生成建议\n- 结束节点\n---\n===**MarkdownFlow 实现**(用 Markdown 语法直接描述):===\n!===\n```markdown\n?[%{{current_role}} 你目前从事什么岗位?(如:产品经理、程序员、设计师、学生等)]\n?[%{{skills}} 你擅长哪些技能?(可以列举 2-3 个)]\n?[%{{interests}} 你对哪些领域感兴趣?(如:AI、设计、管理等)]\n用户信息:\n- 当前岗位:{{current_role}}\n- 擅长技能:{{skills}}\n- 兴趣领域:{{interests}}\n\n请作为职业规划专家,给出 3 条具体的职业发展建议。\n```\n!===\n---\n**对比发现**:\n- MarkdownFlow 用**自然语言**描述逻辑,更符合人的思维方式\n- 不需要在可视化界面拖拽节点,直接用 Markdown 语法写出来\n- 代码即文档,逻辑一目了然\n---\n\n你可能会想:**MarkdownFlow 只是语法简洁吗?还有其他优势吗?**\n\n答案是:**远不止如此。** MarkdownFlow 的三大核心优势,我们将在下一节详细展开。\n\n根据你的学习目标'''{{learning_goal}}''',给予针对性的鼓励和过渡。\n\n用你喜欢的讲课风格'''{{sys_user_style}}''',引导 {{sys_user_nickname}} 继续 2.3 节的学习。\n"
    },
    {
      "outline_item_bid": "bbf23d951bac4e768920849ff53de68f",
      "title": "MarkdownFlow：代码级精准控制的优势",
      "type": 401,
      "hidden": 0,
      "parent_bid": "691a0bb7866e447895e365fc262c5454",
      "position": "0203",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1:优势一 - 用自然语言控制 AI 输出\n\n通过前面的实操,你已经体验了低代码平台的优势和局限。现在让我揭示 **MarkdownFlow 的第一个核心优势**:用自然语言精确控制 AI 的输出。\n\n**问题场景**:假设你在用扣子或 Dify 开发一个 AI 简历助手,你希望 AI 生成的简历**严格遵循特定格式**:\n\n!===\n期望的简历格式:\n```\n# 个人简历\n\n## 基本信息\n姓名:XXX\n邮箱:XXX\n电话:XXX\n\n## 工作经历\n[公司名] | [岗位] | [时间]\n- 职责 1\n- 职责 2\n\n## 技能清单\n- 技能 1\n- 技能 2\n```\n!===\n\n**用低代码平台实现的困难**:\n- 你只能在 Prompt 中描述\"请生成简历\",但 AI 每次生成的格式都可能不一样\n- 即使你在 Prompt 中详细描述格式,AI 也可能\"自由发挥\"\n- 你无法强制 AI 必须输出某些固定内容(比如固定的标题)\n\n**MarkdownFlow 的解决方案**:\n\n!===\n```markdown\n# 个人简历\n\n## 基本信息\n姓名:{{name}}\n邮箱:{{email}}\n电话:{{phone}}\n---\n## 工作经历\n根据用户的背景'''{{work_experience}}''',生成工作经历描述,每段经历包括公司名、岗位、时间、3 条职责。\n---\n## 技能清单\n根据用户的技能'''{{skills}}''',生成技能清单,每个技能用一个要点表示。\n```\n!===\n\n===**关键点**:===\n!===\n```markdown\n- `===...===` 中的内容会**原样输出**,不会被 AI 修改\n- 其他部分 AI 会根据指令生成内容\n- 你可以精确控制哪些内容是固定的,哪些内容是动态生成的\n```\n!===\n---\n**对比效果**:\n!===\n| 维度 | 低代码平台 | MarkdownFlow |\n|------|-----------|-------------|\n| **格式一致性** | ❌ 每次生成格式可能不同 | ✅ 固定部分绝对一致 |\n| **控制粒度** | ⭐⭐ 粗粒度(整体 Prompt) | ⭐⭐⭐⭐⭐ 细粒度(逐块控制) |\n| **调试难度** | ❌ 难以定位问题(AI 黑盒) | ✅ 容易定位(哪块有问题一目了然) |\n| **可维护性** | ❌ Prompt 混乱,难以修改 | ✅ 结构清晰,易于调整 |\n!===\n\n**实际应用场景**:\n- 生成结构化报告(周报、总结、分析报告)\n- 教育内容(课程、教案、练习题)\n- 个性化推荐(带固定格式的推荐列表)\n- 任何需要\"部分固定、部分动态\"的内容\n\n根据你的背景'''{{sys_user_background}}''',举一个针对性的例子说明这个优势在 ta 的工作或学习中如何应用。\n\n---\n\n# 块 2:优势二 - 交互式内容生成\n\nMarkdownFlow 的**第二个核心优势**是:**原生支持交互式内容生成**,这是低代码平台和传统代码都难以实现的。\n\n**问题场景**:你想开发一个**个性化学习路径生成器**,根据用户的不同选择,给出不同的学习建议。\n\n**用 Dify 实现的复杂度**:\n- 需要创建多个\"问题\"节点\n- 需要创建多个\"条件判断\"节点\n- 需要手动连接所有节点\n- 如果有 10 个问题,节点图会变得非常复杂\n\n**用 MarkdownFlow 实现**:\n\n!===\n```markdown\n?[%{{learning_goal}} 你的学习目标是什么? 快速入门|深入学习|开发项目]\n?[%{{time_budget}} 你每天能投入多少时间? 1 小时|2-3 小时|4 小时以上]\n?[%{{background}} 你的编程背景是? 零基础|学过 Python|有开发经验]\n根据用户的选择:\n- 学习目标:{{learning_goal}}\n- 时间投入:{{time_budget}}\n- 编程背景:{{background}}\n\n生成一个为期 2 周的个性化学习计划,包括每天的学习内容和时间分配。\n```\n!===\n\n**关键点**:\n- `?[%{{var}} question options]` 语法**原生支持**交互式问答\n- 每个问题的答案自动存储为变量\n- 变量可以在后续内容中引用\n- 整个流程**线性、清晰、易读**\n\n**对比效果**:\n\n!===\n| 维度 | Dify 工作流 | MarkdownFlow |\n|------|-----------|-------------|\n| **交互定义** | 拖拽节点 + 配置 | 一行 Markdown 语法 |\n| **流程可读性** | ❌ 需要看节点图 | ✅ 线性文本,一目了然 |\n| **修改成本** | ❌ 重新连接节点 | ✅ 直接修改文本 |\n| **复杂度** | 10 个问题 = 20+ 个节点 | 10 个问题 = 10 行代码 |\n| **版本控制** | ❌ 无法 Git 管理 | ✅ 可以 Git 管理 |\n!===\n\n**更强大的交互形式**:\n\nMarkdownFlow 支持多种交互形式(这里先了解概念,第 3 章会详细讲解):\n!===\n```markdown\n1. **单选按钮**:`?[%{{var}} 选项 A|选项 B|选项 C]`\n2. **多选按钮**:`?[%{{var}} 选项 A||选项 B||选项 C]`\n3. **文本输入**:`?[%{{var}} 请输入你的答案]`\n4. **混合模式**:`?[%{{var}} 选项 A|选项 B|...其他]`\n```\n!===\n\n**实际应用场景**:\n- 在线教育(根据学生水平推荐课程)\n- 咨询服务(根据用户需求推荐方案)\n- 问卷调查(动态生成分析报告)\n- 产品推荐(根据偏好推荐商品)\n\n结合你的学习目标'''{{learning_goal}}''',说明这个优势对 ta 的价值。\n\n---\n\n# 块 3:优势三 - 代码级灵活性与 Markdown 简洁性的完美结合\n\nMarkdownFlow 的**第三个核心优势**是:**在保持 Markdown 简洁性的同时,提供代码级的灵活性**。\n\n**问题场景**:你想实现一个功能:**根据用户的选择,动态调整后续内容的风格**。\n\n比如:\n- 用户选择\"严肃专业风格\",后续内容用正式语言\n- 用户选择\"轻松幽默风格\",后续内容用口语化表达\n\n**用低代码平台实现**:几乎不可能,因为你无法动态修改 LLM 的 system prompt。\n\n**用 MarkdownFlow 实现**:\n\n!===\n```markdown\n?[%{{style}} 你喜欢什么样的讲课风格? 严肃专业|轻松幽默|简洁高效]\n\n---\n\n用户喜欢的风格是'''{{style}}''',后续内容请用这种风格讲解。\n\n现在,解释什么是机器学习。\n```\n!===\n\n**关键点**:\n- 用 `'''{{variable}}'''` 三引号强调变量,LLM 会特别关注\n- MarkdownFlow 支持在内容中嵌入变量,动态调整指令\n- 这种能力是**低代码平台和传统 Prompt 工程**都难以实现的\n\n**更高级的用法**:\n\n你甚至可以实现**条件内容**:\n\n!===\n```markdown\n如果用户的编程经验是'''{{programming_experience}}''':\n- 零基础:用通俗语言解释,多举生活例子\n- 有基础:直接讲技术细节,附代码示例\n- 有经验:深入原理,对比不同实现方式\n\n现在,解释什么是神经网络。\n```\n!===\n\n**对比效果**:\n\n!===\n| 维度 | 低代码平台 | 传统代码(LangChain) | MarkdownFlow |\n|------|-----------|-------------------|-------------|\n| **动态指令** | ❌ 不支持 | ✅ 需要写 Python 代码 | ✅ 用 Markdown 描述 |\n| **代码量** | 0 行(但无法实现) | 50-100 行 Python | 5-10 行 Markdown |\n| **学习成本** | 低 | 高(需要学 LangChain) | 低(只需懂 Markdown) |\n| **调试难度** | N/A | ❌ 需要 Debug Python | ✅ 直接看文本 |\n| **可读性** | N/A | ❌ 代码逻辑复杂 | ✅ 自然语言,易懂 |\n!===\n\n**实际应用场景**:\n- 个性化教学(根据学生水平调整难度)\n- 多语言内容生成(根据用户语言偏好)\n- 动态报告生成(根据数据特征调整分析维度)\n- 自适应对话(根据用户情绪调整回复风格)\n\n---\n\n**三大优势总结**:\n\n通过这三个优势的对比,你应该理解了 **MarkdownFlow 的独特定位**:\n\n\n1. **精确控制输出格式**\n   - 低代码平台:**做不到**\n   - 传统代码:**可以,但很复杂**\n   - MarkdownFlow:**简洁实现**\n\n2. **交互式内容生成**\n   - 低代码平台:**可视化拖拽,复杂场景难维护**\n   - 传统代码:**需要写大量代码**\n   - MarkdownFlow:**一行语法搞定**\n\n3. **代码级灵活性**\n   - 低代码平台:**几乎没有**\n   - 传统代码:**完全灵活,但学习成本高**\n   - MarkdownFlow:**Markdown 语法 + 代码级能力**\n\n\nMarkdownFlow **不是要替代**低代码平台或传统代码,而是填补了一个**重要的空白**:\n\n- 比低代码平台**更灵活**\n- 比传统代码**更简洁**\n- 专注于**交互式内容生成**这个细分领域\n\n这就是为什么我们选择 MarkdownFlow 作为这门课程的教学工具:**它让你在 2 周内既能体验 AI 应用开发的全貌,又不会被复杂的技术细节淹没**。\n---\n根据你的背景'''{{sys_user_background}}'''和学习目标'''{{learning_goal}}''',给予个性化的总结和鼓励。\n\n用你喜欢的讲课风格'''{{sys_user_style}}''',引导 {{sys_user_nickname}} 继续 2.4 节,我们会做最终的选型决策总结。\n"
    },
    {
      "outline_item_bid": "f598253d43d6463da213139edca47cdc",
      "title": "选型决策：什么场景用什么工具",
      "type": 401,
      "hidden": 0,
      "parent_bid": "691a0bb7866e447895e365fc262c5454",
      "position": "0204",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1:工具选型决策矩阵\n\n通过前面三节的学习,你已经:\n- 了解了三种开发模式的全貌\n- 亲手体验了扣子和 Dify 两个低代码平台\n- 深入理解了 MarkdownFlow 的三大核心优势\n\n现在,让我们做一个系统化的选型决策。我会给你一个**决策矩阵**,帮助你在实际项目中快速判断应该用哪个工具。\n\n!===\n## 工具选型决策矩阵\n\n| 评估维度 | 低代码平台<br/>(扣子/Dify) | 工作流编排<br/>(LangChain) | MarkdownFlow | 说明 |\n|---------|------------------------|----------------------|-------------|------|\n| **开发速度** | ⭐⭐⭐⭐⭐<br/>15-30 分钟 | ⭐⭐<br/>1-3 天 | ⭐⭐⭐⭐<br/>1-2 小时 | 原型验证首选低代码 |\n| **学习成本** | ⭐<br/>几乎为 0 | ⭐⭐⭐⭐⭐<br/>需要学习框架 | ⭐⭐<br/>只需懂 Markdown | 零基础首选低代码或 MarkdownFlow |\n| **输出控制** | ⭐⭐<br/>粗粒度 | ⭐⭐⭐⭐⭐<br/>完全控制 | ⭐⭐⭐⭐⭐<br/>精确控制 | 需要精确格式选后两者 |\n| **交互能力** | ⭐⭐⭐<br/>基础对话 | ⭐⭐⭐⭐<br/>需要编码 | ⭐⭐⭐⭐⭐<br/>原生支持 | 多步骤交互首选 MarkdownFlow |\n| **定制能力** | ⭐⭐<br/>有限 | ⭐⭐⭐⭐⭐<br/>无限 | ⭐⭐⭐⭐<br/>高 | 复杂业务逻辑选 LangChain |\n| **系统集成** | ⭐⭐<br/>API 集成 | ⭐⭐⭐⭐⭐<br/>完全控制 | ⭐⭐⭐⭐<br/>API 集成 | 深度集成选后两者 |\n| **可维护性** | ⭐⭐⭐<br/>可视化 | ⭐⭐<br/>代码复杂 | ⭐⭐⭐⭐⭐<br/>文本清晰 | 长期维护首选 MarkdownFlow |\n| **版本控制** | ❌<br/>不支持 Git | ✅<br/>Git 管理 | ✅<br/>Git 管理 | 团队协作选后两者 |\n| **成本** | 💰<br/>平台费用 | 💰💰💰<br/>LLM + 开发 | 💰💰<br/>LLM + 开发 | 考虑总体成本 |\n| **适用场景** | 简单对话<br/>快速验证 | 复杂系统<br/>深度集成 | 交互内容<br/>教育咨询 | 根据场景选择 |\n!===\n\n**快速决策方法**:\n\n根据你的项目需求,回答以下 **3 个关键问题**:\n\n1. **你的核心需求是什么?**\n   - 快速验证想法 → **低代码平台**\n   - 生成交互式内容 → **MarkdownFlow**\n   - 构建复杂 AI 系统 → **LangChain**\n\n2. **你的技术背景如何?**\n   - 零基础 → **低代码平台**或 **MarkdownFlow**\n   - 有编程基础 → **MarkdownFlow**或 **LangChain**\n   - 资深开发者 → **LangChain**(需要完全控制时)\n\n3. **项目的时间要求?**\n   - 1 天内出原型 → **低代码平台**\n   - 1 周内上线 MVP → **MarkdownFlow**\n   - 长期迭代优化 → **LangChain**或 **MarkdownFlow**\n\n根据你的背景'''{{sys_user_background}}'''和学习目标'''{{learning_goal}}''',给出针对性的选型建议。\n\n---\n\n# 块 2:为什么本课程选择 MarkdownFlow\n\n你可能会问:**既然低代码平台更简单,LangChain 更强大,为什么这门课程选择 MarkdownFlow?**\n\n这是一个非常好的问题。让我从**教学目标**和**实用价值**两个角度解释。\n\n---\n## 从教学角度\n\n**本课程的目标**:让你在 2 周内掌握 AI 应用开发的**核心能力**,而不是成为某个特定工具的专家。\n\n**MarkdownFlow 作为教学工具的优势**:\n\n1. **学习曲线友好**\n   - 只需要懂 Markdown(你可能已经会了)\n   - 不需要学习复杂的编程框架\n   - 专注于**AI 应用设计思维**,而不是技术细节\n\n2. **概念可迁移**\n   - 学会 MarkdownFlow 的设计思想后,很容易迁移到其他工具\n   - 你会理解:**如何控制 AI 输出**、**如何设计交互流程**、**如何管理变量**\n   - 这些概念在任何 AI 开发工具中都适用\n\n3. **全栈体验完整**\n   - MarkdownFlow 是代码级工具,你会接触到前后端开发\n   - 你会学到:**API 设计**、**前端集成**、**流式输出**、**状态管理**\n   - 这些技能在传统 Web 开发中同样重要\n\n**对比低代码平台和 LangChain**:\n\n| 教学维度 | 低代码平台 | MarkdownFlow | LangChain |\n|---------|-----------|-------------|-----------|\n| **学习目标** | 学会用某个平台 | 学会 AI 应用设计思维 | 学会复杂系统架构 |\n| **技能可迁移性** | ⭐⭐ 平台绑定 | ⭐⭐⭐⭐⭐ 概念通用 | ⭐⭐⭐⭐ 框架思维 |\n| **全栈知识覆盖** | ❌ 平台封装 | ✅ 完整体验 | ✅ 完整体验 |\n| **学习时间** | 1 天 | 1 周 | 1 个月+ |\n| **适合教学人群** | 完全零基础 | 大学生/初级开发者 | 有经验的开发者 |\n\n**结论**:MarkdownFlow 在**教学效率**和**知识深度**之间达到了最佳平衡。\n---\n\n## 从实用角度\n\n**MarkdownFlow 不只是教学工具,它在实际项目中也有独特价值**。\n\n**适合 MarkdownFlow 的实际场景**:\n\n1. **在线教育平台**\n   - 根据学生水平生成个性化课程\n   - 交互式练习题和即时反馈\n   - 学习路径推荐\n\n2. **咨询服务**\n   - 收集用户需求,生成定制方案\n   - 分步骤诊断和建议\n   - 报告自动生成\n\n3. **内容创作**\n   - 个性化文章/邮件生成\n   - 社交媒体内容策划\n   - 营销文案定制\n\n4. **问卷和调研**\n   - 动态问卷(根据回答调整后续问题)\n   - 自动生成分析报告\n   - 用户画像构建\n\n**真实案例**(课程 Demo 项目):\n\n我们的 Demo 项目 **markdown-flow-playground** 就是一个典型的 MarkdownFlow 应用:\n- 前端:用户可以编辑 MarkdownFlow 文档,实时预览\n- 后端:解析文档,调用 LLM,流式返回结果\n- 交互:支持按钮、文本输入、变量管理\n- 应用:可以用来开发课程、问卷、咨询工具等\n\n**技术栈**:\n- 后端:Python + FastAPI\n- 前端:React + Next.js + TypeScript\n- AI:OpenAI/DeepSeek API\n\n这个技术栈是**行业主流**,学会后可以直接应用到其他 Web 项目中。\n\n\n结合你的编程经验'''{{programming_experience}}''',说明学习 MarkdownFlow 对 ta 未来发展的价值。\n\n---\n\n# 块 3:第二章总结与下一步\n\n恭喜 {{sys_user_nickname}}!你已经完成了第二章的全部内容。让我们回顾一下你的收获:\n\n**第二章你学到了什么**:\n\n✅ **理解了 AI 应用开发的三种模式**:低代码平台、工作流编排、MarkdownFlow\n\n✅ **亲手体验了两个低代码平台**:\n- 扣子:15 分钟搭建 AI 学习助手\n- Dify:30 分钟搭建职业规划助手\n\n✅ **深入理解了 MarkdownFlow 的三大优势**:\n1. 用自然语言精确控制 AI 输出\n2. 原生支持交互式内容生成\n3. 代码级灵活性 + Markdown 简洁性\n\n✅ **掌握了工具选型方法**:\n- 决策矩阵\n- 3 个关键问题\n- 不同场景的最佳选择\n\n**你现在的能力**:\n\n- 能够根据项目需求选择合适的开发工具\n- 理解了 MarkdownFlow 的设计思想和适用场景\n- 为接下来的 Vibe Coding 实战打下了基础\n\n**下一章预告**:\n\n在第三章《Vibe Coding 工作流与项目脚手架》中,你会学到:\n\n- 什么是 Vibe Coding,如何与 AI 协作开发\n- 如何用 AI 辅助工具(Cursor/Claude Code)快速编写代码\n- 搭建 markdown-flow-playground 项目的完整环境\n- 理解项目的前后端架构\n\n用一句话概括:**第三章会把你从\"理解概念\"带入\"动手实战\"**。\n\n根据你喜欢的讲课风格'''{{sys_user_style}}''',给 {{sys_user_nickname}} 热烈的祝贺和鼓励,邀请 ta 继续第三章的学习。\n\n**如果你对工具选型还有疑问,或者想深入了解某个特定场景,可以在讨论区提问,我和助教会帮助你!**\n"
    },
    {
      "outline_item_bid": "ee80e78db5f64d47849c9b7876e52c03",
      "title": "什么是 Vibe Coding？与传统开发的区别",
      "type": 401,
      "hidden": 0,
      "parent_bid": "bf841234eae84d6dbf0ee3122354e06f",
      "position": "0301",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：传统编程 vs Vibe Coding - 一个真实场景\n\n欢迎来到第三章，{{sys_user_nickname}}！\n\n完成前两章后，你已经体验了低代码平台，理解了 MarkdownFlow 的独特优势。现在，我要带你进入这门课程最核心的部分：**Vibe Coding**。\n\n这不仅仅是一个新概念，而是一种**颠覆性的编程范式**。让我先给你看一个真实场景。\n\n假设你要开发一个功能：**在网页上显示一个用户信息卡片**，包括头像、姓名、职位、个人简介。\n---\n!===\n**传统开发流程**：\n\n1. **写 HTML 结构**（10 分钟）\n   ```html\n   <div class=\"user-card\">\n     <img src=\"avatar.jpg\" class=\"avatar\" />\n     <h3 class=\"name\">张三</h3>\n     <p class=\"title\">产品经理</p>\n     <p class=\"bio\">热爱 AI，擅长需求分析</p>\n   </div>\n   ```\n\n2. **写 CSS 样式**（20 分钟）\n   ```css\n   .user-card {\n     border: 1px solid #ddd;\n     border-radius: 8px;\n     padding: 20px;\n     max-width: 300px;\n   }\n   .avatar {\n     width: 80px;\n     height: 80px;\n     border-radius: 50%;\n   }\n   /* ...更多样式 */\n   ```\n\n3. **调试样式**（15 分钟）\n   - 头像没居中 → 调整 CSS\n   - 边框颜色不满意 → 调整颜色\n   - 间距不对 → 调整 padding/margin\n\n4. **写 JavaScript 逻辑**（如果需要动态数据，再花 15 分钟）\n\n**总耗时**：约 60 分钟\n!===\n---\n**Vibe Coding 流程**：\n\n1. **描述意图**（1 分钟）\n   - 打开 Cursor/Claude Code\n   - 在聊天框输入：\n     ```\n     创建一个用户信息卡片组件，包括：\n     - 圆形头像（80x80）\n     - 姓名（h3 标题）\n     - 职位（灰色小字）\n     - 个人简介\n\n     样式要求：\n     - 白色背景，浅灰边框，圆角\n     - 居中对齐\n     - 最大宽度 300px\n     ```\n\n2. **AI 生成代码**（10 秒）\n   - AI 自动生成 HTML + CSS（甚至可以是 React 组件）\n\n3. **审查 + 测试**（5 分钟）\n   - 在浏览器中预览\n   - 如果不满意某个细节，继续对话：\"把头像改成左对齐，信息放右边\"\n\n4. **迭代优化**（根据需要，通常 5-10 分钟）\n\n**总耗时**：约 10-15 分钟\n\n**效率提升**：**4-6 倍**\n---\n\n你可能会想：**这也太神奇了吧？AI 真的能生成可用的代码吗？**\n\n答案是：**能，但有前提**。关键在于你如何与 AI 协作，这就是 Vibe Coding 要教你的。\n\n根据你的背景'''{{sys_user_background}}'''，我会用你熟悉的方式来解释 Vibe Coding 的核心理念。\n\n---\n\n# 块 2：什么是 Vibe Coding？\n\n**Vibe Coding** 是一种**以自然语言描述意图，让 AI 辅助实现细节**的编程范式。\n\n这个名字的由来很有意思：**Vibe** 在英文中是\"氛围、感觉、意图\"的意思。Vibe Coding 强调的是：你只需要传达\"想要什么\"的 **Vibe**（意图），具体的代码实现交给 AI。\n\n**核心定义**：\n\nVibe Coding = **人类设计** + **AI 实现** + **人类验证**\n\n!===\n| 角色 | 传统编程 | Vibe Coding |\n|------|---------|------------|\n| **人类** | 设计 + 实现 + 调试 + 优化 | 设计 + 验证 + 优化 |\n| **AI** | 无 | 实现 + 初步调试 |\n| **时间分配** | 实现占 70% | 设计和验证占 70% |\n| **核心技能** | 记住语法、调试 bug | 清晰表达意图、审查代码 |\n!===\n\n**关键转变**：\n\n从前，编程是这样的：\n1. 你有一个想法\n2. 你把想法转化为算法\n3. 你把算法转化为代码\n4. 你调试代码直到能运行\n\n现在，Vibe Coding 是这样的：\n1. 你有一个想法\n2. **你用自然语言告诉 AI 这个想法**\n3. **AI 生成代码**\n4. **你审查代码，确保符合预期**\n5. 如果不满意，继续对话优化\n\n**这意味着什么？**\n\n- ✅ 你不需要记住每个语法细节（AI 会帮你）\n- ✅ 你不需要花大量时间调试低级错误（AI 不会写拼写错误）\n- ✅ 你可以专注于**设计**和**业务逻辑**，而不是语法和实现\n- ✅ 你可以快速尝试不同的方案（迭代成本极低）\n\n**但也意味着**：\n\n- ❌ 你需要学会**清晰表达意图**（而不是模糊的描述）\n- ❌ 你需要学会**审查代码**（确保 AI 没有理解错）\n- ❌ 你需要**保持主导**（AI 是助手，不是替代品）\n\n---\n\n# 块 3：传统开发 vs Vibe Coding 深度对比\n\n让我用一个详细的对比表格，帮你理解两者的本质区别。\n\n!===\n| 维度 | 传统开发 | Vibe Coding | 影响 |\n|------|---------|------------|------|\n| **开发流程** | 需求 → 设计 → 编码 → 调试 → 测试 | 需求 → **描述意图** → **AI 生成** → **人工审查** → 测试 | 流程更短，迭代更快 |\n| **技能要求** | 熟练掌握语法、框架、API | 理解概念、会描述意图、会审查代码 | **降低入门门槛**，但提高设计能力要求 |\n| **时间分配** | 编码 70%、设计 20%、调试 10% | 设计 40%、审查 40%、优化 20% | **从写代码到想代码** |\n| **调试方式** | 盯着代码找 bug、打断点、看日志 | 描述问题，让 AI 定位和修复 | 调试更高效，但需要描述清楚 |\n| **学习曲线** | 陡峭（需要学习大量语法和框架） | 平缓（边做边学，AI 会给出解释） | **零基础也能快速上手** |\n| **适用场景** | 所有场景（但效率差异大） | 中小型项目、快速原型、个人开发 | 大型复杂系统仍需传统开发 |\n| **代码质量** | 取决于开发者水平 | 取决于 Prompt 质量和人工审查 | **AI 生成的代码往往更规范** |\n| **可维护性** | 需要写注释、文档 | AI 生成的代码自带清晰结构 | 更易维护，但需要 AGENTS.md |\n!===\n\n**具体例子对比**：\n\n假设你要实现一个功能：**根据用户输入的邮箱，验证格式是否正确**。\n\n**传统开发**：\n1. Google 搜索\"邮箱正则表达式\"（5 分钟）\n2. 找到一个看起来靠谱的正则\n3. 写代码：\n   ```javascript\n   function validateEmail(email) {\n     const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n     return regex.test(email);\n   }\n   ```\n4. 测试各种边界情况（10 分钟）\n5. 发现某些特殊字符没处理，修改正则（5 分钟）\n\n**Vibe Coding**：\n1. 问 AI：\"写一个 JavaScript 函数，验证邮箱格式，需要支持常见的邮箱格式，返回 true/false\"（30 秒）\n2. AI 生成代码（10 秒）\n3. 你审查代码，问 AI：\"这个正则是否支持 + 号？\"（30 秒）\n4. AI 解释并优化（10 秒）\n\n**耗时对比**：20 分钟 vs 2 分钟\n\n---\n\n# 块 4：Vibe Coding 的三大核心原则\n\n理解 Vibe Coding 的精髓，需要掌握三大核心原则。这些原则会贯穿整个课程的实战环节。\n\n\n## 原则 1：描述意图而非细节\n\n**不好的做法**：\n```\n帮我写个函数\n```\n→ AI 不知道你要什么函数，只能猜测或拒绝\n\n**好的做法**：\n```\n写一个 Python 函数，接收一个字符串列表，\n返回去重后的列表，保持原始顺序。\n```\n→ AI 明确知道输入、输出、约束条件\n\n**最佳实践**：\n- ✅ 说明**输入是什么**（类型、格式）\n- ✅ 说明**输出是什么**（返回值、副作用）\n- ✅ 说明**约束条件**（性能要求、边界情况）\n- ✅ 提供**示例**（输入 A → 输出 B）\n\n---\n\n## 原则 2：迭代优化而非一次完美\n\n**传统思维**：\n一次性写出完美的代码，考虑所有边界情况。\n→ 结果：花费大量时间，但往往遗漏某些情况\n\n**Vibe Coding 思维**：\n先让 AI 生成一个基础版本，然后逐步优化。\n→ 结果：快速得到可用版本，然后针对性改进\n\n**示例流程**：\n\n**版本 1**（1 分钟）：\n```\n创建一个用户列表组件，显示姓名和邮箱\n```\n→ AI 生成基础版本\n\n**版本 2**（2 分钟）：\n```\n在每个用户旁边加一个\"删除\"按钮\n```\n→ AI 添加按钮\n\n**版本 3**（2 分钟）：\n```\n点击删除按钮前，弹出确认对话框\n```\n→ AI 添加确认逻辑\n\n**总耗时**：5 分钟，得到一个功能完善的组件\n\n**关键点**：\n- ✅ 每次只改一个小功能\n- ✅ 每次改完都测试一下\n- ✅ 不满意就继续对话，AI 会在现有基础上修改\n\n---\n\n## 原则 3：保持主导，AI 是助手\n\n**常见误区**：\n- ❌ \"AI 生成的代码肯定是对的，直接用\"\n- ❌ \"我不懂代码，反正 AI 会搞定\"\n- ❌ \"AI 说怎么做就怎么做\"\n\n**正确心态**：\n- ✅ **你是设计师**，AI 是执行者\n- ✅ **你负责验证**，AI 负责实现\n- ✅ **你做决策**，AI 提供建议\n\n**具体分工**：\n!===\n| 人类负责 | AI 负责 |\n|---------|--------|\n| 定义需求（要做什么） | 实现细节（怎么做） |\n| 设计架构（模块划分） | 生成代码（语法、API 调用） |\n| 审查代码（逻辑是否正确） | 解释代码（为什么这样写） |\n| 测试验证（功能是否符合预期） | 修复 bug（根据描述改代码） |\n| 做最终决策（用不用这段代码） | 提供多个方案（供人类选择） |\n!===\n\n**实战建议**：\n- 每次 AI 生成代码后，**先理解再使用**\n- 如果不理解某段代码，**问 AI 解释**\n- 如果觉得有问题，**直接指出让 AI 修改**\n- **永远保留最终决定权**\n---\n\n结合你的编程经验'''{{programming_experience}}'''，我会在后续的实战环节调整指导的详细程度。如果你是零基础，我会手把手带你体验每一步；如果你有经验，我会更多地引导你独立思考。\n\n---\n\n# 块 5：理解验证 + 过渡\n\n现在，你应该对 Vibe Coding 有了初步的理解。在继续之前，我想听听你自己的理解。\n\n**请用你自己的话，概括一下你对 Vibe Coding 的理解**。不需要很长，一两句话就好。这会帮助我了解你的掌握程度，后续的讲解会更有针对性。\n\n?[%{{vibe_understanding}} ...你如何理解 Vibe Coding？请用一句话概括。]\n\n---\n\n很好！你的理解是'''{{vibe_understanding}}'''。\n\nVibe Coding 的理念其实可以用一句话总结：**让人类专注于\"想什么\"，让 AI 专注于\"怎么做\"**。\n\n接下来，我们要进入实战环节了。在开始用 AI 写代码之前，你需要**深入理解我们的 Demo 项目**：\n- 它是如何设计的？\n- 前后端如何协作？\n- 代码文件都在哪里，各自负责什么？\n\n只有理解了项目架构，你才能高效地与 AI 协作开发。\n\n用你喜欢的讲课风格'''{{sys_user_style}}'''，鼓励 {{sys_user_nickname}} 继续下一节的学习，我们会详细拆解 Demo 项目的全貌。\n"
    },
    {
      "outline_item_bid": "403cae06018a429eb64d80e188d37b6a",
      "title": "用AI构建后端API",
      "type": 401,
      "hidden": 0,
      "parent_bid": "ec716ba63dad4e618178f02675c0c3bb",
      "position": "0403",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: Vibe Coding 工作流 - 你不需要手写所有代码\n\n{{sys_user_nickname}},现在我们进入第四章的核心实战部分:**用 AI 构建后端 API**。\n\n首先,我要再次强调 Vibe Coding 的核心理念:**你不需要手写所有代码,你需要学会如何让 AI 帮你写**。\n\n传统的后端开发教程会教你:\n- ❌ FastAPI 装饰器的各种用法\n- ❌ Pydantic 模型的定义细节\n- ❌ async/await 的底层原理\n- ❌ 错误处理的各种模式\n\n但在 Vibe Coding 模式下,你真正需要学会的是:\n- ✅ **描述需求** - 如何清晰地告诉 AI 你想要什么\n- ✅ **理解关键部分** - AI 生成的代码中哪些是你需要理解的\n- ✅ **审查代码质量** - 用检查清单验证 AI 生成的代码是否符合要求\n- ✅ **测试与迭代** - 如何快速验证功能,并让 AI 优化\n\n**Vibe Coding 工作流**:\n!===\n```\n1. 描述需求（你负责）\n   ↓\n2. AI 生成代码（AI 负责）\n   ↓\n3. 理解关键部分（你负责）\n   ↓\n4. 测试验证（你负责）\n   ↓\n5. 迭代优化（你 + AI 协作）\n```\n!===\n\n结合你的编程经验'''{{programming_experience}}''',这意味着:\n- 如果你是**编程新手**:完全不用担心,AI 会生成所有代码,你只需要理解关键部分\n- 如果你是**有经验的开发者**:可以专注于架构设计和业务逻辑,让 AI 处理重复性编码\n\n本节内容:\n- **如何向 AI 描述后端需求**(Prompt 模板)\n- **AI Prompt 模板库**(理解代码、调试错误、性能优化、添加测试、集成第三方 API)\n- **代码审查清单**(API 路由、MarkdownFlow 集成、错误处理、返回格式)\n- **测试与调试工作流**\n- **实战案例**:用 AI 添加新功能\n\n---\n\n# 块 2: 如何向 AI 描述后端需求 - 清晰、具体、提供上下文\n\n**向 AI 描述需求的三个原则**:\n1. **清晰** - 明确说明功能、参数、返回格式\n2. **具体** - 提供示例、边界条件、错误处理要求\n3. **提供上下文** - 告诉 AI 参考哪些现有代码,保持风格一致\n\n**模板 1: 添加新 API 端点**\n\n!===\n```\n我需要在 /api/v1/playground/ 下添加一个新端点 /save,\n功能是保存用户的 MarkdownFlow 内容到本地文件。\n\n需求:\n1. 接收参数: title（标题）, content（MarkdownFlow 内容）\n2. 保存到 saved_documents/ 目录,文件名为 {title}.md\n3. 返回: {\"success\": true, \"file_path\": \"...\"}\n4. 错误处理: 文件已存在、标题为空、内容为空\n\n参考:\n- 参考现有的 /generate 端点的代码结构\n- 使用相同的错误处理模式\n- 保持 RESTful 风格\n```\n!===\n\n**AI 会生成代码,你需要理解的关键部分**:\n!===\n```python\n# 你需要理解:\n@router.post(\"/save\")  # ← 端点路径\nasync def save_document(request: SaveDocumentRequest):\n    # ← 接收的参数: title, content\n\n    file_path = f\"saved_documents/{request.title}.md\"\n    # ← 保存位置\n\n    return {\"success\": True, \"file_path\": file_path}\n    # ← 返回格式\n```\n!===\n\n**你不需要记住的部分**:\n- ❌ `@router.post` 装饰器语法\n- ❌ `HTTPException` 的具体用法\n- ❌ 文件操作的详细代码\n\n**模板 2: 修改现有功能**\n\n!===\n```\n修改 /api/v1/playground/generate 端点,\n在返回的 SSE 流中增加一个 \"progress\" 事件类型,\n用于显示生成进度（百分比）。\n\n需求:\n1. 在生成过程中,每处理完一个 chunk,计算进度百分比\n2. 发送 {\"type\": \"progress\", \"percent\": 50}\n3. 前端可以显示进度条\n\n参考:\n- 查看现有的 SSE 返回格式\n- 保持与现有事件类型的一致性\n```\n!===\n\n**模板 3: 集成第三方 API**\n\n!===\n```\n我想在后端集成天气 API,根据用户选择的城市返回天气信息。\n\n需求:\n1. 新增 /api/v1/weather 端点（GET）\n2. 接收参数: city（城市名称）\n3. 调用天气 API: https://api.weatherapi.com/v1/current.json\n4. 返回: {\"city\": \"北京\", \"temperature\": 25, \"description\": \"晴朗\"}\n5. 错误处理: 城市不存在、API 调用失败\n\n实现步骤:\n1. 使用 httpx 库调用第三方 API\n2. 解析 API 返回的 JSON 数据\n3. 提取需要的字段\n4. 返回给前端\n\n参考:\n- 参考 Demo 项目的 LLM 客户端代码（app/library/llmclient.py）\n- 使用相同的异步调用模式\n```\n!===\n\n**好的需求描述 vs 不好的需求描述对比**:\n\n!===\n| **不好的描述** | **好的描述** | **说明** |\n|--------------|------------|---------|\n| \"添加一个保存功能\" | \"添加 `/save` 端点,保存 MarkdownFlow 内容到文件\" | 具体说明端点路径和功能 |\n| \"需要错误处理\" | \"处理:文件已存在、标题为空、内容为空\" | 明确列出所有错误情况 |\n| \"参考现有代码\" | \"参考 `/generate` 端点的代码结构\" | 具体指出参考哪个文件 |\n!===\n\n---\n\n# 块 3: AI Prompt 模板库 - 5 个高频场景\n\n**场景 1: 理解现有代码**\n\n!===\n```\nPrompt: \"解释 app/services/playground.py 中的 process_stream 方法,\n重点说明:\n1. 它如何调用 MarkdownFlow\n2. 如何处理 SSE 流式输出\n3. 错误处理机制\n请用简单的语言解释,我是初学者。\"\n```\n!===\n\n**场景 2: 调试错误**\n\n!===\n```\nPrompt: \"我运行 /api/v1/playground/generate 端点时报错:\nKeyError: 'user_input'\n\n相关代码:\n[粘贴报错的代码]\n\n请帮我:\n1. 定位错误原因\n2. 提供修复方案\n3. 解释为什么会出现这个错误\"\n```\n!===\n\n**场景 3: 性能优化**\n\n!===\n```\nPrompt: \"我的 /generate 端点响应很慢（3-5 秒才开始返回）。\n\n当前实现:\n[粘贴代码]\n\n请帮我:\n1. 分析可能的性能瓶颈\n2. 提供优化建议\n3. 给出优化后的代码示例\"\n```\n!===\n\n**场景 4: 添加测试**\n\n!===\n```\nPrompt: \"为 /api/v1/playground/generate 端点编写测试用例。\n\n需要测试:\n1. 正常流程（成功生成）\n2. 参数错误（缺少 content）\n3. MarkdownFlow 语法错误\n4. LLM API 调用失败\n\n使用 pytest 框架,参考现有测试代码风格。\"\n```\n!===\n\n**场景 5: 集成第三方 API**（新增）\n\n!===\n```\nPrompt: \"我想在后端集成 OpenWeatherMap API。\n\n需求:\n1. 新增 /api/v1/integrations/weather 端点\n2. 接收城市名称,返回当前天气\n3. 使用 httpx 异步调用 API\n4. 错误处理: API key 无效、城市不存在、网络超时\n\n请给出完整实现,包括:\n1. API 路由定义\n2. Service 层方法\n3. 第三方 API 调用代码\n4. 错误处理和日志记录\n\n参考 Demo 项目的 app/library/llmclient.py 的异步调用模式。\"\n```\n!===\n\n**Prompt 模板使用技巧**:\n\n!===\n| 技巧 | 说明 | 示例 |\n|------|------|------|\n| **具体化** | 明确说明需求的每个细节 | \"返回格式: `{\\\"success\\\": true}`\" |\n| **提供上下文** | 告诉 AI 参考哪些文件 | \"参考 `app/api/v1/playground.py`\" |\n| **分步骤** | 把复杂任务拆分为步骤 | \"1. 定义模型 2. 实现端点 3. 添加测试\" |\n| **给示例** | 提供输入/输出示例 | \"输入: `{\\\"title\\\": \\\"xxx\\\"}`, 输出: `{...}`\" |\n!===\n\n---\n\n# 块 4: 代码审查清单 - 确保 AI 生成的代码符合要求\n\n**当 AI 生成代码后,你需要检查以下几点**:\n\n**检查清单 1: API 路由是否正确?**\n\n!===\n```python\n# ✅ 检查路径\n@router.post(\"/save\")  # 路径是否符合需求?\n\n# ✅ 检查方法\nasync def save_document(...)  # 是否需要 async?\n\n# ✅ 检查参数\nrequest: SaveDocumentRequest  # 参数类型是否正确?\n```\n!===\n\n**检查清单 2: MarkdownFlow 集成是否正确?**\n\n!===\n```python\n# ✅ 检查 MarkdownFlow 调用\nfrom markdown_flow import MarkdownFlow\n\nmf = MarkdownFlow(content, llm_provider)\n\n# ✅ 检查变量传递\nstream = mf.process_stream(\n    block_index=block_index,\n    variables=variables,  # ← 确认变量正确传入\n    user_input=user_input\n)\n\n# ✅ 检查流式输出\nasync for chunk in stream:\n    yield chunk  # ← 确认正确返回 SSE\n```\n!===\n\n**检查清单 3: 错误处理是否完善?**\n\n!===\n```python\n# ✅ 参数验证\nif not request.title:\n    raise HTTPException(400, \"标题不能为空\")\n\n# ✅ 异常捕获\ntry:\n    # 业务逻辑\nexcept Exception as e:\n    logger.error(f\"错误: {e}\")  # ← 确认有日志记录\n    raise HTTPException(500, str(e))\n```\n!===\n\n**检查清单 4: 返回格式是否符合前端需求?**\n\n!===\n```python\n# ✅ 成功响应\nreturn {\n    \"success\": True,\n    \"data\": {...},\n    \"message\": \"操作成功\"\n}\n\n# ✅ 错误响应\nraise HTTPException(\n    status_code=400,\n    detail={\"error\": \"...\", \"message\": \"...\"}\n)\n```\n!===\n\n**检查清单 5: 第三方 API 集成是否正确?**（新增）\n\n!===\n```python\n# ✅ 检查异步调用\nimport httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url)  # ← 使用 async/await\n\n# ✅ 检查超时设置\nresponse = await client.get(url, timeout=10.0)  # ← 设置超时\n\n# ✅ 检查错误处理\nif response.status_code != 200:\n    raise HTTPException(500, \"API 调用失败\")\n\n# ✅ 检查数据解析\ndata = response.json()  # ← 解析 JSON\n```\n!===\n\n**完整的代码审查清单**:\n\n!===\n- [ ] API 路径和方法是否正确?\n- [ ] 参数类型和验证是否完善?\n- [ ] MarkdownFlow 调用是否正确?\n- [ ] 变量传递是否正确?\n- [ ] 流式输出是否正确?\n- [ ] 错误处理是否完善?\n- [ ] 日志记录是否添加?\n- [ ] 返回格式是否符合前端需求?\n- [ ] 第三方 API 调用是否正确?（如果有）\n- [ ] 超时和重试机制是否设置?（如果需要）\n!===\n\n---\n\n# 块 5: 测试与调试工作流 - 快速验证功能\n\n**步骤 1: 使用 curl 测试 API**\n\n!===\n```bash\n# 测试健康检查\ncurl http://localhost:8000/health\n\n# 测试流式生成\ncurl -X POST http://localhost:8000/api/v1/playground/generate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"content\": \"你好 {{name}}!\",\n    \"block_index\": 0,\n    \"variables\": {\"name\": \"张三\"}\n  }'\n\n# 测试 MarkdownFlow 信息提取\ncurl -X POST http://localhost:8000/api/v1/playground/markdownflow_info \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"?[%{{city}} 北京|上海]\"}'\n\n# 测试第三方 API 集成（如果添加了天气功能）\ncurl http://localhost:8000/api/v1/integrations/weather?city=北京\n```\n!===\n\n**步骤 2: 查看后端日志**\n\n!===\n```bash\n# 启动后端时会看到日志输出\nuvicorn main:app --reload\n\n# 观察日志中的:\n# - 请求路径和参数\n# - MarkdownFlow 处理过程\n# - 错误信息和堆栈\n```\n!===\n\n**步骤 3: 让 AI 帮助定位问题**\n\n!===\n```\nPrompt: \"我调用 /generate 端点时,返回 500 错误。\n\n后端日志:\n[粘贴日志内容]\n\n请求参数:\n{\n  \"content\": \"...\",\n  \"block_index\": 0\n}\n\n请帮我定位问题并提供解决方案。\"\n```\n!===\n\n**调试技巧总结**:\n\n!===\n1. **先看日志** - 后端日志通常会显示详细的错误信息\n2. **分步测试** - 先测试最简单的情况,再逐步增加复杂度\n3. **对比工作的代码** - 参考现有端点的实现\n4. **让 AI 帮忙** - 把日志和代码粘贴给 AI,让它帮你定位问题\n!===\n\n---\n\n# 块 6: 实战案例 - 用 AI 添加\"保存文档\"功能\n\n**需求**: 添加\"保存文档\"功能,让用户可以保存当前的 MarkdownFlow 内容\n\n**Step 1: 描述需求给 AI**\n\n!===\n```\n我想添加一个\"保存文档\"功能。\n\n需求:\n1. 用户可以保存当前的 MarkdownFlow 内容\n2. 保存时需要提供标题\n3. 保存到 saved_documents/ 目录\n4. 返回保存成功的提示信息和文件路径\n\n请帮我:\n1. 设计 API 接口（路径、参数、返回格式）\n2. 给出实现代码\n3. 告诉我需要理解哪些关键部分\n\n参考 Demo 项目的现有代码结构,保持风格一致。\n```\n!===\n\n**Step 2: AI 生成代码**\n\n（AI 会生成完整的代码,包括 API 路由、Service 方法、数据模型等）\n\n**Step 3: 你理解关键部分**\n\n!===\n```python\n# 你需要理解的部分:\n@router.post(\"/save\")  # ← 新端点路径\nasync def save_document(request: SaveDocumentRequest):\n    # ← 接收的参数: title, content\n\n    file_path = f\"saved_documents/{request.title}.md\"\n    # ← 保存位置\n\n    return {\"success\": True, \"file_path\": file_path}\n    # ← 返回格式\n```\n!===\n\n**Step 4: 测试验证**\n\n!===\n```bash\ncurl -X POST http://localhost:8000/api/v1/playground/save \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"我的第一个文档\", \"content\": \"# Hello World\"}'\n\n# 检查 saved_documents/ 目录是否有文件\nls saved_documents/\n```\n!===\n\n**Step 5: 迭代优化**\n\n!===\n```\nPrompt: \"保存功能可以正常工作,但我想增加:\n1. 文件名自动添加时间戳（避免重名）\n2. 返回保存成功的提示信息\n3. 如果目录不存在,自动创建\n\n请修改代码。\"\n```\n!===\n\n---\n\n**4.3 小结**:\n\n你现在应该学会了:\n- ✅ 如何向 AI 描述后端需求(清晰、具体、提供上下文)\n- ✅ 5 个高频场景的 Prompt 模板(理解、调试、优化、测试、集成)\n- ✅ 代码审查清单(API 路由、MarkdownFlow 集成、错误处理、返回格式、第三方 API)\n- ✅ 测试与调试工作流(curl、日志、AI 辅助)\n- ✅ 完整的开发流程(描述需求 → AI 生成 → 理解关键部分 → 测试 → 迭代)\n\n接下来,我们将进入第四章的最后一部分:**Demo 项目实战**,动手完成三个渐进任务,巩固所学内容。\n"
    },
    {
      "outline_item_bid": "500bdfd36a4d42328392af962156d809",
      "title": "Demo项目实战",
      "type": 401,
      "hidden": 0,
      "parent_bid": "ec716ba63dad4e618178f02675c0c3bb",
      "position": "0404",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 实战准备 - 三个渐进任务\n\n欢迎来到第四章的最后一部分,{{sys_user_nickname}}!\n\n现在你已经学会了:\n- ✅ 后端架构的核心概念(API、前后端分离、数据流)\n- ✅ MarkdownFlow 的所有语法(变量、交互、块分隔、保留内容)\n- ✅ Vibe Coding 工作流(描述需求、审查代码、测试调试)\n\n接下来,我们要通过三个渐进任务,让你**动手实践**,将所学知识应用到 Demo 项目中。\n\n**三个任务的难度递增**:\n\n!===\n| 任务 | 难度 | 核心技能 | 预计时间 |\n|------|------|---------|---------|\n| 任务 1: 修改欢迎语 | ⭐ 简单 | MarkdownFlow 语法应用 | 15 分钟 |\n| 任务 2: 添加主题选择 | ⭐⭐ 中等 | 多块交互流程设计 | 30 分钟 |\n| 任务 3: 添加历史记录 | ⭐⭐⭐ 困难 | 完整 Vibe Coding 流程 | 45 分钟 |\n!===\n\n**准备工作**:\n1. ✅ 确保 Demo 项目已启动:`cd demo && uvicorn main:app --reload`\n2. ✅ 打开 `demo/AGENTS.md`,了解项目结构\n3. ✅ 准备好你的 AI 助手(Claude Code / ChatGPT / Cursor)\n\n结合你的项目想法'''{{project_idea}}''',完成这三个任务后,你将能够:\n- 修改 MarkdownFlow 内容,添加个性化交互\n- 设计多步骤的用户引导流程\n- 用 AI 从零开发一个完整的新功能\n\n准备好了吗?让我们从最简单的任务开始!\n\n---\n\n# 块 2: 实战任务 1 - 修改欢迎语（修改 MarkdownFlow 内容）\n\n**任务目标**: 修改 Playground 的欢迎语,添加你的个性化信息\n\n**当前内容**（假设在某个 MarkdownFlow 文件中）:\n!===\n```markdown\n欢迎使用 MarkdownFlow Playground!\n\n?[%{{action}} 开始创作|查看示例|了解更多]\n```\n!===\n\n**你要修改为**:\n!===\n```markdown\n你好 {{user_name}}! 👋\n\n欢迎来到 MarkdownFlow Playground,这是一个让你轻松创建 AI 应用的平台。\n\n?[%{{action}} 开始创作|查看示例|了解更多|...我想做其他事]\n\n---\n\n你选择了: '''{{action}}'''\n\n(根据选择生成不同内容)\n```\n!===\n\n**修改步骤**:\n\n**Step 1: 找到 MarkdownFlow 内容的位置**\n\n向 AI 提问:\n!===\n```\nPrompt: \"在 Demo 项目中,Playground 的欢迎语内容在哪个文件?\n请告诉我文件路径和具体位置。\"\n```\n!===\n\n**Step 2: 修改内容**\n\n- 添加变量 `{{user_name}}`\n- 添加\"我想做其他事\"选项(自由输入)\n- 添加第二个块,显示用户选择\n\n**Step 3: 测试验证**\n\n!===\n```bash\n# 重启后端\n# 打开浏览器访问 Demo 项目前端\n# 检查:\n# - 变量 {{user_name}} 是否正确替换?\n# - 交互选项是否正确渲染?\n# - 分块是否正常工作?\n```\n!===\n\n**检查清单**:\n!===\n- [ ] 变量 `{{user_name}}` 是否正确替换?\n- [ ] 交互选项是否正确渲染(包括\"我想做其他事\")?\n- [ ] 第二个块是否显示用户选择?\n- [ ] 分块分隔符 `---` 是否正确?\n!===\n\n**如果遇到问题**:\n\n**问题**: 变量没有替换\n!===\n```\nPrompt: \"我修改了 MarkdownFlow 内容,添加了 {{user_name}} 变量,\n但前端显示的是原样 {{user_name}},没有被替换。\n\n我的修改:\n[粘贴你的修改内容]\n\n请帮我定位问题。\"\n```\n!===\n\n**问题**: 交互选项没有渲染\n!===\n```\nPrompt: \"我添加了交互选项,但前端没有显示按钮。\n\n我的代码:\n?[%{{action}} 开始创作|查看示例|了解更多|...我想做其他事]\n\n请检查语法是否正确。\"\n```\n!===\n\n---\n\n# 块 3: 实战任务 2 - 添加主题选择（练习 MarkdownFlow 语法）\n\n**任务目标**: 在 Playground 中添加\"选择主题和风格\"功能,体验多块交互流程\n\n**需求**:\n!===\n```markdown\n# 块 0: 选择主题\n?[%{{theme}} 技术文章|产品介绍|营销文案|学术论文]\n\n---\n\n# 块 1: 选择风格\n你选择了 {{theme}},请选择写作风格:\n\n?[%{{style}} 正式|轻松|幽默|专业]\n\n---\n\n# 块 2: 生成内容\n根据 {{theme}} 和 {{style}} 风格,生成内容:\n\n(AI 生成的内容)\n```\n!===\n\n**修改步骤**:\n\n**Step 1: 设计 MarkdownFlow 内容**\n\n你已经在上面看到了完整的 3 块设计,现在需要:\n1. 理解每个块的作用\n2. 理解变量如何在块之间传递\n\n**Step 2: 向 AI 询问如何修改代码**\n\n!===\n```\nPrompt: \"我想在 Demo 项目中添加一个\"主题选择\"功能。\n\nMarkdownFlow 内容如下:\n[粘贴你设计的 3 块内容]\n\n请帮我:\n1. 找到应该修改哪个文件\n2. 如何在代码中更新 MarkdownFlow 内容\n3. 是否需要修改其他地方（如变量初始化）\n4. 给出完整的修改步骤\"\n```\n!===\n\n**Step 3: 应用 AI 的建议,修改代码**\n\n**Step 4: 测试验证**\n\n!===\n```bash\n# 重启后端,打开前端\n# 逐块测试:\n# - 块 0: 是否显示 4 个主题选项?\n# - 块 1: 是否显示\"你选择了 {{theme}}\"?\n# - 块 1: 是否显示 4 个风格选项?\n# - 块 2: AI 是否根据两个变量生成内容?\n```\n!===\n\n**检查清单**:\n!===\n- [ ] 块 0 的单选交互是否正常?\n- [ ] 块 1 是否正确显示用户在块 0 的选择?\n- [ ] 块 1 的单选交互是否正常?\n- [ ] 块 2 是否根据 theme 和 style 生成不同内容?\n- [ ] 变量是否正确传递(块 0 → 块 1 → 块 2)?\n!===\n\n**深入思考**:\n\n完成这个任务后,思考:\n- 如果要添加第 3 个块,让用户选择\"内容长度\",应该怎么设计?\n- 如果要在块 1 使用多选(选择多个风格),语法应该如何修改?\n\n你可以尝试自己设计,然后让 AI 帮你实现。\n\n---\n\n# 块 4: 实战任务 3 - 添加历史记录（完整 Vibe Coding 流程）\n\n**任务目标**: 用 AI 从零开发一个完整的\"历史记录\"功能\n\n**需求**:\n1. 新增 `/api/v1/playground/history` 端点(GET)\n2. 返回最近 5 条生成记录\n3. 每条记录格式:\n   ===\n   ```json\n   {\n     \"id\": 1,\n     \"created_at\": \"2025-12-12 10:30:00\",\n     \"content_preview\": \"前 50 个字...\",\n     \"block_count\": 3\n   }\n   ```\n   ===\n\n**这是一个完整的 Vibe Coding 流程示范**:\n\n**Step 1: 向 AI 描述需求**\n\n!===\n```\nPrompt: \"我想在 Demo 项目中添加\"历史记录\"功能。\n\n需求:\n1. 新增 GET /api/v1/playground/history 端点\n2. 返回最近 5 条生成记录（从内存中读取即可）\n3. 每条记录格式:\n   {\n     \"id\": 1,\n     \"created_at\": \"2025-12-12 10:30:00\",\n     \"content_preview\": \"前 50 个字...\",\n     \"block_count\": 3\n   }\n\n实现步骤:\n1. 在 PlaygroundService 中添加内存列表存储历史\n2. 在 generate 方法中记录每次生成\n3. 添加 get_history 方法\n4. 在 API 路由层添加 /history 端点\n\n请参考现有代码风格,给出完整实现,包括:\n- 数据模型定义（Pydantic）\n- Service 层方法\n- API 路由定义\n- 需要修改的所有文件\"\n```\n!===\n\n**Step 2: AI 生成代码**\n\nAI 会生成多个文件的代码,你需要:\n1. 仔细阅读 AI 的说明\n2. 按照 AI 的指示,复制代码到对应文件\n3. 理解关键部分(下面会讲)\n\n**Step 3: 理解关键部分**\n\n!===\n```python\n# app/services/playground.py\n\nclass PlaygroundService:\n    # ← 内存存储历史记录\n    _history = []  # 你需要理解: 这是一个类变量,所有实例共享\n\n    async def process_stream(self, ...):\n        # 生成完成后,记录历史\n        self._history.append({...})  # ← 理解: 在哪里记录\n\n    def get_history(self, limit=5):\n        return self._history[-limit:]  # ← 理解: 返回最近 5 条\n\n# app/api/v1/playground.py\n\n@router.get(\"/history\")  # ← 理解: GET 方法,不需要 POST\nasync def get_history():\n    service = PlaygroundService()\n    history = service.get_history()\n    return {\"success\": True, \"data\": history}\n```\n!===\n\n**Step 4: 测试验证**\n\n!===\n```bash\n# 先调用几次 generate,生成一些历史记录\ncurl -X POST http://localhost:8000/api/v1/playground/generate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"测试内容 1\", \"block_index\": 0, \"variables\": {}}'\n\ncurl -X POST http://localhost:8000/api/v1/playground/generate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"测试内容 2\", \"block_index\": 0, \"variables\": {}}'\n\n# 测试历史记录端点\ncurl http://localhost:8000/api/v1/playground/history\n\n# 检查返回结果是否正确:\n# - 是否返回了 2 条记录?\n# - 每条记录是否包含 id, created_at, content_preview, block_count?\n# - content_preview 是否是前 50 个字?\n```\n!===\n\n**Step 5: 迭代优化**\n\n如果功能可以正常工作,你可以让 AI 帮你改进:\n\n!===\n```\nPrompt: \"历史记录功能可以工作,但我想改进:\n1. 历史记录超过 100 条后,自动删除最旧的\n2. 添加\"清空历史\"端点（DELETE /api/v1/playground/history）\n3. 返回结果按时间倒序排列（最新的在最前面）\n\n请修改代码,给出完整实现。\"\n```\n!===\n\n**检查清单**:\n!===\n- [ ] `/history` 端点是否正常返回数据?\n- [ ] 数据格式是否正确?\n- [ ] 是否记录了所有生成操作?\n- [ ] 是否只返回最近 5 条?\n- [ ] 如果没有历史记录,返回空数组?\n!===\n\n---\n\n# 块 5: 实战总结与下一步\n\n**恭喜你,{{sys_user_nickname}}!** 你已经完成了第四章的所有实战任务!\n\n**你在这三个任务中学到了**:\n\n**任务 1: 修改欢迎语**\n- ✅ MarkdownFlow 变量的实际使用\n- ✅ 交互元素的语法(单选 + 自由输入)\n- ✅ 如何测试和验证 MarkdownFlow 修改\n\n**任务 2: 添加主题选择**\n- ✅ 多块交互流程的设计\n- ✅ 变量在块之间的传递\n- ✅ 如何让 AI 帮你找到需要修改的文件\n\n**任务 3: 添加历史记录**\n- ✅ 完整的 Vibe Coding 工作流(描述需求 → AI 生成 → 理解关键部分 → 测试 → 迭代)\n- ✅ 如何向 AI 描述一个完整功能的需求\n- ✅ 如何理解 AI 生成的代码(关键部分 vs 可以忽略的细节)\n- ✅ 如何测试一个新端点\n- ✅ 如何让 AI 帮你迭代优化\n\n**核心要点回顾**:\n\n!===\n| 要点 | 说明 |\n|------|------|\n| **MarkdownFlow 是核心** | 你必须精通 MarkdownFlow 语法,这是无法让 AI 代替的 |\n| **架构理解很重要** | 你需要理解系统如何工作(API → Service → Library),但不需要记住所有细节 |\n| **AI 是你的助手** | Python/FastAPI 代码可以让 AI 生成,你专注于设计和理解关键部分 |\n| **测试是必须的** | 每次修改后都要测试,确保功能正常 |\n| **迭代是常态** | 第一次生成的代码可能不完美,要学会让 AI 帮你优化 |\n!===\n\n**第四章总结**:\n\n你现在应该能够:\n- ✅ 理解后端架构(API、前后端分离、数据流、SSE)\n- ✅ 精通 MarkdownFlow 语法(变量、交互、块分隔、保留内容、调试)\n- ✅ 学会 Vibe Coding 工作流(描述需求、Prompt 模板、代码审查、测试调试)\n- ✅ 完成实战任务(修改内容、设计流程、添加功能)\n\n**下一步: 第五章预告**\n\n!===\n**第 5 章: AI 应用前端开发实战（React + markdown-flow-ui）**\n\n你将学习:\n1. 前端架构全景理解（组件、状态、SSE）\n2. markdown-flow-ui 组件库使用（MarkdownFlow、InteractionPanel 等）\n3. 用 AI 构建前端界面（UI 需求描述 + 代码审查）\n4. Demo 项目前端实战\n!===\n\n**继续保持 Vibe Coding 思维**:\n- 设计 > 实现\n- 理解 > 记忆\n- AI 协作 > 单打独斗\n\n结合你的项目想法'''{{project_idea}}''',你现在已经掌握了后端开发的核心技能。第五章我们将学习前端开发,完成一个完整的全栈 AI 应用!\n\n---\n\n**准备好了吗?让我们进入第五章,用 AI 构建精美的前端界面!** 🚀\n"
    },
    {
      "outline_item_bid": "0ee3261224e2464487fc972fad701fee",
      "title": "前端架构全景分析",
      "type": 401,
      "hidden": 0,
      "parent_bid": "0bc85fd1cd3a43a18c2cdc704910b505",
      "position": "0501",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 从第四章到第五章 - 进入前端世界\n\n欢迎来到第五章,{{sys_user_nickname}}!\n\n在第四章,你学会了用 AI 构建后端 API,精通了 MarkdownFlow 语法,理解了后端架构。现在,我们要学习前端开发,让你的 AI 应用拥有精美的用户界面。\n\n但在开始之前,我要先明确一个重要转变:**第五章的学习重点不是 React 或 TypeScript**。\n\n你可能会想:\"学前端开发不就是学写 React 代码吗?\" 过去确实如此,但在 Vibe Coding 时代,**学习重点发生了根本性转变**:\n\n!===\n| 传统前端学习 | Vibe Coding 前端学习 |\n|-------------|---------------------|\n| 记住 React Hooks | **理解组件层级和数据流**（知道系统如何工作） |\n| 记住 TypeScript 类型 | **掌握 markdown-flow-ui 组件库**（核心技能） |\n| 学会调试 bug | **学会描述 UI 需求给 AI**（Prompt 模板） |\n| 学会写单元测试 | **学会审查 AI 生成的代码**（检查清单） |\n!===\n\n**为什么会有这样的转变?**\n\n因为在 Vibe Coding 模式下,**React/TypeScript 代码可以让 AI 帮你写,但 markdown-flow-ui 组件库的使用和 UI 设计思维必须你自己掌握**。这就像装修房子:你需要理解空间布局和家具搭配(组件使用),但具体的木工活(React 代码)可以交给装修工人(AI)。\n\n结合你的背景'''{{sys_user_background}}''',这意味着:\n- 如果你是**前端新手**:不用担心记不住 React 语法,AI 会帮你生成代码\n- 如果你是**有经验的前端开发者**:可以专注于 UI 设计和用户体验,让 AI 处理重复性编码工作\n\n**前后端学习对比**:\n\n!===\n| 方面 | 后端（第 4 章） | 前端（第 5 章） |\n|------|---------------|---------------|\n| 核心技能 | MarkdownFlow 语法 | markdown-flow-ui 组件库 |\n| 架构理解 | API → Service → Library | 组件层级、状态管理、数据流 |\n| AI 工作流 | Prompt 模板、代码审查 | Prompt 模板、代码审查 |\n| 实战项目 | 添加 API 端点 | 修改样式、添加组件 |\n| 不需要记住 | Python/FastAPI 语法 | React/TypeScript 语法 |\n| 必须精通 | MarkdownFlow 语法 | markdown-flow-ui API |\n!===\n\n**所以,第五章你真正要掌握的是**:\n1. **理解前端架构**(15% 时间) - 知道组件、状态、数据流是什么\n2. **掌握 markdown-flow-ui 组件库**(30% 时间) - 这是前端开发的核心技能\n3. **学会用 AI 构建前端**(40% 时间) - 用 Prompt 模板描述 UI 需求,用检查清单审查代码\n4. **完成实战任务**(15% 时间) - 动手实践,巩固所学\n\n准备好了吗?让我们从理解\"什么是组件\"开始。\n\n---\n\n# 块 2: 什么是组件?什么是状态?\n\n**先用生活类比帮你理解组件**:\n\n想象你在搭乐高积木:\n- **组件** = **积木块** - 每个积木块有自己的形状和功能(按钮、输入框、卡片)\n- **组件嵌套** = **积木组合** - 小积木块组合成大积木块(按钮 + 输入框 → 表单)\n- **状态** = **积木的颜色/开关** - 积木的当前样子(按钮是否点击、输入框的内容)\n\n!===\n**技术翻译**:\n\n**组件（Component）**:\n- 就是可复用的 UI 模块,像\"按钮\"、\"输入框\"、\"卡片\"\n- 可以嵌套组合,像搭积木一样搭出复杂界面\n\n**状态（State）**:\n- 就是组件的当前数据,像\"输入框的文字\"、\"按钮是否被点击\"\n- 状态改变 → 界面自动更新\n!===\n\n**React 中的状态管理（简要介绍）**:\n\n在 React 中,我们用 `useState` 来管理状态。你**理解概念即可,AI 会帮你写代码**:\n\n!===\n```typescript\n// 理解即可,AI 会帮你写\nconst [text, setText] = useState('');\n//     ↑       ↑           ↑\n//   当前值  更新函数    初始值\n\n// 用户输入时,调用 setText 更新状态\n// 状态改变 → React 自动重新渲染界面\n```\n!===\n\n**生活类比**:\n- `useState` 就像一个**智能开关** - 你改变开关状态(setText),灯就自动亮/灭(界面更新)\n- 传统方式是**手动开灯** - 你要自己操作 DOM,很麻烦\n\n**重要提醒**:\n- ✅ **你需要理解**: 什么是状态,状态改变会更新界面\n- ❌ **你不需要记住**: `useState` 的所有用法细节,AI 会处理\n- 🎯 **你真正要做的**: 学会告诉 AI \"我需要一个输入框,内容存到变量中\"\n\n---\n\n# 块 3: Demo 项目的组件层级\n\n现在让我们看看 Demo 项目中,**组件是如何嵌套组合的**。\n\n这是一个**完整的组件层级图**,不用死记,理解即可:\n\n!===\n```\nPlayground（最外层容器）\n│\n├── EditPanel（左侧编辑面板）\n│   ├── DocumentSelector（文档选择器）\n│   ├── MarkdownEditor（Markdown 编辑器）\n│   └── BlockIndexSelector（块索引选择器）\n│\n├── VariableColumn（中间变量列）\n│   └── VariableEditor（变量编辑器）\n│\n└── MarkdownFlow（右侧预览区）⭐ 核心组件\n    ├── 内容渲染区\n    └── InteractionPanel（交互面板）\n```\n!===\n\n**数据流示意图**（理解系统如何工作）:\n\n!===\n```\n用户在 MarkdownEditor 编辑内容\n    ↓\nPlayground 状态更新（contentList）\n    ↓\n传递给 MarkdownFlow 组件\n    ↓\nMarkdownFlow 调用后端 API\n    ↓\n后端返回 SSE 流式数据\n    ↓\nMarkdownFlow 实时渲染内容\n    ↓\n用户看到打字机效果\n```\n!===\n\n**核心组件说明**:\n\n**1. Playground（最外层容器）**\n- **作用**: 管理整个应用的全局状态\n- **状态**: `contentList`（MarkdownFlow 内容）、`variables`（变量）、`blockIndex`（当前块索引）\n- **理解即可**: 这是\"总指挥\",协调所有子组件\n\n**2. EditPanel（左侧编辑面板）**\n- **作用**: 让用户编辑 MarkdownFlow 内容\n- **包含**: 文档选择、Markdown 编辑器、块索引选择\n- **理解即可**: 这是\"编辑区\",修改内容\n\n**3. VariableColumn（中间变量列）**\n- **作用**: 显示和编辑变量\n- **包含**: VariableEditor 组件\n- **理解即可**: 这是\"变量管理区\"\n\n**4. MarkdownFlow（右侧预览区）** ⭐\n- **作用**: **核心组件**,渲染 MarkdownFlow 内容并处理交互\n- **这是你必须掌握的组件**: 来自 `markdown-flow-ui` 组件库\n- **重点学习**: 5.2 节会详细讲解这个组件的所有用法\n\n**你需要理解的关键点**:\n- ✅ Playground 管理全局状态\n- ✅ 数据从 Playground 流向子组件（单向数据流）\n- ✅ MarkdownFlow 是核心组件,负责渲染和交互\n- ❌ 不需要记住每个组件的具体实现代码\n\n**理解程度检查**:如果你能回答以下问题,说明理解到位了:\n- Q:用户在编辑器中修改内容,MarkdownFlow 如何知道要更新?\n- A:Playground 的状态更新,传递新的 contentList 给 MarkdownFlow\n\n---\n\n# 块 4: 前端如何与后端通信(SSE)?\n\n在第四章,你已经学习了 SSE（Server-Sent Events）的后端实现。现在让我们简单回顾一下**前端如何接收 SSE 流**。\n\n**SSE 流式通信原理**（简单回顾,引用第 4 章）:\n\n!===\n```\n前端                          后端\n │                             │\n │  建立 SSE 连接               │\n ├──────────────────────────>  │\n │                             │\n │                             │ 生成内容\n │  ← data: {\"type\": \"content\", \"content\": \"你好\"}\n │  ← data: {\"type\": \"content\", \"content\": \"张三\"}\n │  ← data: {\"type\": \"interaction\", ...}\n │  ← data: {\"type\": \"done\"}\n │                             │\n```\n!===\n\n**前端代码（理解即可,AI 会帮你写）**:\n\n!===\n```typescript\n// 使用 fetchEventSource 建立 SSE 连接\nawait fetchEventSource('/api/v1/playground/generate', {\n  method: 'POST',\n  body: JSON.stringify({ content, variables, blockIndex }),\n  onmessage(event) {\n    // 接收到服务器推送的数据\n    const data = JSON.parse(event.data);\n    if (data.type === 'content') {\n      // 更新界面,显示新内容\n    }\n  }\n});\n```\n!===\n\n**重要提醒**:\n- ✅ **你需要理解**: 前端通过 `fetchEventSource` 建立连接,后端通过 SSE 持续推送数据\n- ❌ **你不需要记住**: `fetchEventSource` 的所有参数细节,AI 会处理\n- 🎯 **你真正要做的**: 学会告诉 AI \"我需要调用后端 API,实时显示生成的内容\"\n\n**markdown-flow-ui 已经封装好了 SSE 调用**:\n\n好消息是,`markdown-flow-ui` 组件库已经帮你封装好了 SSE 调用逻辑!\n\n你只需要:\n1. 使用 `<MarkdownFlow>` 组件\n2. 传入 `initialContentList` 和 `onSend` 回调\n3. 组件会自动处理 SSE 通信和打字机效果\n\n**这就是使用组件库的好处** - 你不需要关心底层实现,专注于使用即可。\n\n---\n\n# 块 5: 小结 - 你现在理解了什么?\n\n**你现在应该理解了**:\n\n✅ **前端开发的核心转变**\n- 从\"学 React 语法\"到\"学组件库使用 + AI 协作\"\n- 第五章重点:markdown-flow-ui 组件库(30%) + AI 工作流(40%)\n\n✅ **组件和状态的基本概念**\n- 组件 = 可复用的 UI 模块(像积木块)\n- 状态 = 组件的当前数据(像开关)\n- `useState` 管理状态(理解即可,AI 会写)\n\n✅ **Demo 项目的组件层级**\n- Playground 管理全局状态\n- MarkdownFlow 是核心组件(来自 markdown-flow-ui)\n- 数据流:Playground → 子组件(单向流动)\n\n✅ **前端与后端通信**\n- SSE 流式通信原理(引用第 4 章)\n- markdown-flow-ui 已封装好 SSE 调用\n\n**你不需要记住**:\n- ❌ React Hooks 的所有用法细节\n- ❌ TypeScript 类型定义细节\n- ❌ `fetchEventSource` 的参数细节\n- ❌ 每个组件的具体实现代码\n\n**接下来**,我们进入第五章最重要的部分:**markdown-flow-ui 组件库使用**。这是你必须掌握的核心技能,我们将用 30% 的时间深入学习这个组件库的所有用法。\n"
    },
    {
      "outline_item_bid": "740fd6ef6dd741c0a12a47b8e8faa615",
      "title": "markdown-flow-ui组件库使用",
      "type": 401,
      "hidden": 0,
      "parent_bid": "0bc85fd1cd3a43a18c2cdc704910b505",
      "position": "0502",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 为什么使用组件库?组件库的三大优势\n\n{{sys_user_nickname}},现在我们进入第五章最重要的部分:**markdown-flow-ui 组件库使用**。\n\n首先,让我解释一下**为什么要使用组件库,而不是手写所有代码**。\n\n**生活类比**:\n\n使用组件库就像去宜家买家具:\n- ❌ **手写组件** = 自己做木工 - 你要从木材开始,打磨、上漆、组装\n- ✅ **使用组件库** = 买现成家具 - 已经做好了,你只需要组装和摆放\n\n**组件库的三大优势**:\n\n!===\n| 优势 | 说明 | 示例 |\n|------|------|------|\n| **1. 开箱即用** | 不需要从零实现复杂功能 | `<MarkdownFlow>` 自动处理 SSE 通信、打字机效果 |\n| **2. 久经考验** | 组件经过充分测试,bug 少 | markdown-flow-ui 已在多个项目中使用 |\n| **3. 专注业务** | 你只需关心\"用什么组件\",不用关心\"怎么实现\" | 你只需传入 contentList,组件自动渲染 |\n!===\n\n**markdown-flow-ui vs 手写组件对比**:\n\n!===\n| 方面 | 手写组件 | markdown-flow-ui |\n|------|---------|-----------------|\n| SSE 流式通信 | 需要自己实现 `fetchEventSource` 逻辑 | ✅ 内置,自动处理 |\n| 打字机效果 | 需要自己写定时器逻辑 | ✅ 内置,一个属性开启 |\n| 交互处理 | 需要自己解析交互元素、渲染按钮 | ✅ 内置,自动识别并渲染 |\n| 变量管理 | 需要自己管理变量状态 | ✅ 内置,通过回调传递 |\n| 代码量 | ~500-1000 行 | ~10-20 行 |\n!===\n\n**重要提醒**:\n- ✅ **你需要掌握**: markdown-flow-ui 组件库的 API 用法(这是核心技能)\n- ❌ **你不需要关心**: 组件库的底层实现细节\n- 🎯 **学习目标**: 学会使用 `<MarkdownFlow>` 等核心组件,实现 MarkdownFlow 内容渲染和交互\n\n结合你的学习目标'''{{learning_goal}}''',掌握组件库意味着:\n- 你可以快速构建 MarkdownFlow 应用\n- 不需要从零实现复杂的流式通信逻辑\n- 专注于 UI 设计和用户体验\n\n---\n\n# 块 2: 核心组件 `<MarkdownFlow>` 完全指南\n\n`<MarkdownFlow>` 是 markdown-flow-ui 组件库的**核心组件**,负责渲染 MarkdownFlow 内容并处理用户交互。\n\n**基本用法**（理解即可,AI 会帮你写）:\n\n!===\n```tsx\nimport { MarkdownFlow } from 'markdown-flow-ui';\n\n<MarkdownFlow\n  initialContentList={[\n    \"你好 {{name}}!\",\n    \"?[%{{city}} 北京|上海|深圳]\"\n  ]}\n  enableTypewriter={true}\n  typingSpeed={30}\n  onSend={(data) => {\n    // 处理用户交互\n  }}\n/>\n```\n!===\n\n**核心属性详解**:\n\n**1. `initialContentList` - 初始内容列表**\n\n!===\n```tsx\ninitialContentList={[\n  \"第 0 块内容...\",\n  \"第 1 块内容...\",\n  \"第 2 块内容...\"\n]}\n```\n!===\n\n- **类型**: `string[]`\n- **作用**: 传入 MarkdownFlow 内容(按块分隔)\n- **说明**:\n  - 数组的每个元素对应一个块\n  - 块之间用 `---` 分隔(在传入前需要先分割成数组)\n  - 组件会按顺序渲染每个块\n\n**2. `enableTypewriter` - 启用打字机效果**\n\n!===\n```tsx\nenableTypewriter={true}\n```\n!===\n\n- **类型**: `boolean`\n- **作用**: 是否启用打字机效果(逐字显示)\n- **默认值**: `false`\n- **说明**:\n  - `true` - 内容会像打字一样逐字出现\n  - `false` - 内容直接全部显示\n\n**3. `typingSpeed` - 打字速度**\n\n!===\n```tsx\ntypingSpeed={30}  // 每 30ms 显示一个字符\n```\n!===\n\n- **类型**: `number`\n- **作用**: 控制打字机效果的速度(毫秒)\n- **默认值**: `50`\n- **说明**:\n  - 数值越小,打字越快\n  - 建议范围:20-100ms\n\n**4. `isFinished` - 控制打字机是否完成**\n\n!===\n```tsx\nconst [isFinished, setIsFinished] = useState(false);\n\n<MarkdownFlow\n  isFinished={isFinished}\n  onSend={() => setIsFinished(false)}\n/>\n```\n!===\n\n- **类型**: `boolean`\n- **作用**: 外部控制打字机效果是否完成\n- **说明**:\n  - `true` - 强制结束打字机效果,内容全部显示\n  - `false` - 允许打字机效果继续\n  - 通常与 `onSend` 配合使用\n\n**完整示例**（理解关键属性即可）:\n\n!===\n```tsx\n<MarkdownFlow\n  initialContentList={contentList}     // ← 内容数组\n  enableTypewriter={true}              // ← 启用打字机\n  typingSpeed={30}                     // ← 打字速度\n  isFinished={isFinished}              // ← 控制完成状态\n  onSend={handleSend}                  // ← 处理交互(下一块详讲)\n/>\n```\n!===\n\n**你需要理解的关键点**:\n- ✅ `initialContentList` 传入块数组\n- ✅ `enableTypewriter` 控制打字机效果\n- ✅ `typingSpeed` 控制打字速度\n- ✅ `isFinished` 控制打字机完成状态\n\n**你不需要记住**:\n- ❌ 组件的底层实现细节\n- ❌ 打字机效果的具体算法\n\n---\n\n# 块 3: 处理用户交互 - `onSend` 回调详解\n\n`onSend` 是 `<MarkdownFlow>` 组件最重要的属性之一,用于**处理用户的交互操作**（点击按钮、输入文本等）。\n\n**基本原理**:\n\n当用户与 MarkdownFlow 内容交互时（点击单选按钮、输入文本、选择多选项）,组件会调用 `onSend` 回调,并传入交互数据。\n\n**`onSend` 的三种参数形式**:\n\n!===\n**1. 单选按钮**:\n```tsx\nonSend={(data) => {\n  // data: { buttonText: \"北京\" }\n  console.log('用户点击了:', data.buttonText);\n});\n```\n\n**2. 文本输入**:\n```tsx\nonSend={(data) => {\n  // data: { variableName: \"user_input\", inputText: \"张三\" }\n  console.log('变量名:', data.variableName);\n  console.log('输入内容:', data.inputText);\n});\n```\n\n**3. 多选按钮**:\n```tsx\nonSend((data) => {\n  // data: { variableName: \"interests\", selectedValues: [\"技术\", \"商业\"] }\n  console.log('变量名:', data.variableName);\n  console.log('选中项:', data.selectedValues);\n});\n```\n!===\n\n**完整示例**（理解流程即可）:\n\n!===\n```tsx\nimport { useState } from 'react';\nimport { MarkdownFlow } from 'markdown-flow-ui';\n\nfunction App() {\n  const [variables, setVariables] = useState({});\n  const [blockIndex, setBlockIndex] = useState(0);\n\n  const handleSend = async (data) => {\n    // 步骤 1: 更新变量\n    let newVariables = { ...variables };\n\n    if (data.buttonText) {\n      // 单选按钮 - 根据 MarkdownFlow 语法提取变量名\n      // 实际项目中会自动识别,这里简化说明\n      newVariables.city = data.buttonText;\n    } else if (data.inputText) {\n      // 文本输入\n      newVariables[data.variableName] = data.inputText;\n    } else if (data.selectedValues) {\n      // 多选按钮\n      newVariables[data.variableName] = data.selectedValues;\n    }\n\n    setVariables(newVariables);\n\n    // 步骤 2: 调用后端 API,获取下一块内容\n    // (这部分 AI 会帮你写)\n    const response = await fetch('/api/v1/playground/generate', {\n      method: 'POST',\n      body: JSON.stringify({\n        content: contentList[blockIndex + 1],\n        variables: newVariables,\n        blockIndex: blockIndex + 1\n      })\n    });\n\n    // 步骤 3: 更新块索引\n    setBlockIndex(blockIndex + 1);\n  };\n\n  return (\n    <MarkdownFlow\n      initialContentList={contentList}\n      onSend={handleSend}\n    />\n  );\n}\n```\n!===\n\n**关键流程总结**:\n\n!===\n```\n用户交互（点击按钮/输入文本）\n    ↓\nonSend 回调被触发\n    ↓\n更新变量状态\n    ↓\n调用后端 API（传入新变量）\n    ↓\n后端返回下一块内容（SSE 流）\n    ↓\nMarkdownFlow 自动渲染新内容\n```\n!===\n\n**你需要理解的关键点**:\n- ✅ `onSend` 接收交互数据（单选、文本输入、多选）\n- ✅ 在回调中更新变量状态\n- ✅ 调用后端 API 获取下一块内容\n- ✅ 组件会自动渲染新内容\n\n**你不需要记住**:\n- ❌ 具体的变量提取逻辑（AI 会写）\n- ❌ API 调用的所有细节（AI 会写）\n\n---\n\n# 块 4: 启用打字机效果的完整配置\n\n打字机效果是 MarkdownFlow 应用的**标志性特性**,让内容像被\"打字\"一样逐字出现,提升用户体验。\n\n**打字机效果原理**（理解即可）:\n\n!===\n```\n后端返回 SSE 流:\ndata: {\"type\": \"content\", \"content\": \"你\"}\ndata: {\"type\": \"content\", \"content\": \"好\"}\ndata: {\"type\": \"content\", \"content\": \"张\"}\ndata: {\"type\": \"content\", \"content\": \"三\"}\n\n↓ markdown-flow-ui 处理\n\n前端逐字显示:\n\"你\" → \"你好\" → \"你好张\" → \"你好张三\"\n```\n!===\n\n**配置打字机效果**:\n\n!===\n```tsx\n<MarkdownFlow\n  enableTypewriter={true}      // ← 启用打字机\n  typingSpeed={30}             // ← 每 30ms 显示一个字符\n  isFinished={isFinished}      // ← 外部控制完成状态\n/>\n```\n!===\n\n**参数说明**:\n\n!===\n| 参数 | 类型 | 默认值 | 说明 |\n|------|------|--------|------|\n| `enableTypewriter` | boolean | false | 是否启用打字机效果 |\n| `typingSpeed` | number | 50 | 打字速度（毫秒/字符） |\n| `isFinished` | boolean | - | 外部控制是否完成 |\n!===\n\n**打字速度建议**:\n\n!===\n| 速度 | 毫秒 | 适用场景 |\n|------|------|---------|\n| 很快 | 20-30ms | 技术文档、代码生成 |\n| 正常 | 40-60ms | 对话、故事 |\n| 较慢 | 70-100ms | 强调、重点内容 |\n!===\n\n**控制打字机完成状态**:\n\n有时你希望用户可以\"跳过\"打字机效果,直接显示全部内容:\n\n!===\n```tsx\nconst [isFinished, setIsFinished] = useState(false);\n\n<MarkdownFlow\n  enableTypewriter={true}\n  isFinished={isFinished}\n  onSend={() => {\n    setIsFinished(false);  // 重置状态,允许下一块打字\n  }}\n/>\n\n{/* 添加\"跳过\"按钮 */}\n<button onClick={() => setIsFinished(true)}>\n  跳过动画\n</button>\n```\n!===\n\n**最佳实践**:\n\n!===\n**✅ 好的配置**:\n```tsx\n// 适中的打字速度,提供跳过选项\n<MarkdownFlow\n  enableTypewriter={true}\n  typingSpeed={40}\n  isFinished={isFinished}\n/>\n```\n\n**❌ 不好的配置**:\n```tsx\n// 速度太慢,用户体验差\n<MarkdownFlow\n  enableTypewriter={true}\n  typingSpeed={200}  // ← 太慢了!\n/>\n```\n!===\n\n---\n\n# 块 5: 其他辅助组件\n\nmarkdown-flow-ui 除了核心组件 `<MarkdownFlow>`,还提供了一些**辅助组件**,帮你快速构建完整的 MarkdownFlow 应用。\n\n**1. `<InteractionPanel>` - 交互面板**\n\n**作用**: 显示交互元素(按钮、输入框)的容器\n\n**用法**（理解即可）:\n\n!===\n```tsx\nimport { InteractionPanel } from 'markdown-flow-ui';\n\n<InteractionPanel\n  interactions={[\n    { type: 'button', text: '北京' },\n    { type: 'button', text: '上海' },\n    { type: 'input', placeholder: '请输入...' }\n  ]}\n  onSelect={(value) => console.log('选择:', value)}\n/>\n```\n!===\n\n**说明**:\n- 通常不需要单独使用,`<MarkdownFlow>` 会自动渲染交互面板\n- 适用于自定义交互布局的场景\n\n**2. `<VariableEditor>` - 变量编辑器**\n\n**作用**: 显示和编辑变量的组件\n\n**用法**（理解即可）:\n\n!===\n```tsx\nimport { VariableEditor } from 'markdown-flow-ui';\n\n<VariableEditor\n  variables={{ name: '张三', city: '北京' }}\n  onChange={(newVariables) => {\n    setVariables(newVariables);\n  }}\n/>\n```\n!===\n\n**说明**:\n- 用于调试和手动修改变量\n- Demo 项目的中间栏使用了这个组件\n\n**3. `<ScrollableMarkdownFlow>` - 自动滚动容器**\n\n**作用**: 包裹 `<MarkdownFlow>`,自动滚动到最新内容\n\n**用法**（理解即可）:\n\n!===\n```tsx\nimport { ScrollableMarkdownFlow } from 'markdown-flow-ui';\n\n<ScrollableMarkdownFlow\n  autoScroll={true}  // ← 自动滚动到底部\n>\n  <MarkdownFlow {...props} />\n</ScrollableMarkdownFlow>\n```\n!===\n\n**说明**:\n- 当内容超出容器高度时,自动滚动到最新内容\n- 提升长文本场景的用户体验\n\n**组件组合示例**（理解布局即可）:\n\n!===\n```tsx\n<div className=\"app-container\">\n  {/* 左侧：编辑器 */}\n  <MarkdownEditor />\n\n  {/* 中间：变量编辑器 */}\n  <VariableEditor variables={variables} />\n\n  {/* 右侧：MarkdownFlow 预览 */}\n  <ScrollableMarkdownFlow>\n    <MarkdownFlow\n      initialContentList={contentList}\n      enableTypewriter={true}\n      onSend={handleSend}\n    />\n  </ScrollableMarkdownFlow>\n</div>\n```\n!===\n\n**你需要理解**:\n- ✅ `<InteractionPanel>` 用于自定义交互布局\n- ✅ `<VariableEditor>` 用于调试变量\n- ✅ `<ScrollableMarkdownFlow>` 用于自动滚动\n\n**你不需要记住**:\n- ❌ 每个组件的所有属性细节\n- ❌ 组件的实现代码\n\n---\n\n# 块 6: 组件库使用的最佳实践\n\n现在让我总结一下使用 markdown-flow-ui 组件库的**最佳实践**,帮你避免常见错误。\n\n**最佳实践 1: 正确分割 contentList**\n\n!===\n**✅ 好的做法**:\n```tsx\n// 用 split 分割块\nconst contentList = content.split('\\n---\\n');\n\n<MarkdownFlow initialContentList={contentList} />\n```\n\n**❌ 不好的做法**:\n```tsx\n// 直接传入完整内容字符串\n<MarkdownFlow initialContentList={[content]} />\n// ← 错误!应该按块分割\n```\n!===\n\n**最佳实践 2: 合理设置打字速度**\n\n!===\n**✅ 好的做法**:\n```tsx\n// 根据内容类型调整速度\n<MarkdownFlow\n  typingSpeed={content.length > 1000 ? 20 : 40}\n/>\n```\n\n**❌ 不好的做法**:\n```tsx\n// 速度太慢,用户体验差\n<MarkdownFlow typingSpeed={200} />\n```\n!===\n\n**最佳实践 3: 处理 onSend 回调**\n\n!===\n**✅ 好的做法**:\n```tsx\nconst handleSend = async (data) => {\n  // 1. 更新变量\n  setVariables({ ...variables, ...extractVariables(data) });\n\n  // 2. 调用 API\n  await fetchNextBlock();\n\n  // 3. 更新状态\n  setBlockIndex(prev => prev + 1);\n};\n```\n\n**❌ 不好的做法**:\n```tsx\nconst handleSend = (data) => {\n  // 忘记更新变量状态\n  fetchNextBlock();  // ← 变量未传递,后端无法生成正确内容\n};\n```\n!===\n\n**最佳实践 4: 提供跳过按钮**\n\n!===\n**✅ 好的做法**:\n```tsx\nconst [isFinished, setIsFinished] = useState(false);\n\n<>\n  <MarkdownFlow isFinished={isFinished} />\n  <button onClick={() => setIsFinished(true)}>\n    跳过动画\n  </button>\n</>\n```\n\n**❌ 不好的做法**:\n```tsx\n// 没有跳过选项,用户只能等待\n<MarkdownFlow enableTypewriter={true} />\n```\n!===\n\n**最佳实践 5: 使用 ScrollableMarkdownFlow**\n\n!===\n**✅ 好的做法**:\n```tsx\n// 长内容自动滚动\n<ScrollableMarkdownFlow autoScroll={true}>\n  <MarkdownFlow {...props} />\n</ScrollableMarkdownFlow>\n```\n\n**❌ 不好的做法**:\n```tsx\n// 内容超出容器,用户看不到最新内容\n<div style={{ height: '400px', overflow: 'hidden' }}>\n  <MarkdownFlow {...props} />\n</div>\n```\n!===\n\n**常见错误总结**:\n\n!===\n| 错误 | 原因 | 解决方案 |\n|------|------|---------|\n| 打字机效果不显示 | 忘记设置 `enableTypewriter={true}` | 显式启用打字机 |\n| 交互后没反应 | 未实现 `onSend` 回调 | 正确处理 `onSend` |\n| 变量未传递到后端 | `onSend` 中未更新变量状态 | 在回调中更新 `variables` |\n| 内容看不到 | 容器高度过小且未滚动 | 使用 `ScrollableMarkdownFlow` |\n!===\n\n---\n\n# 块 7: 小结 - 你现在掌握了什么?\n\n**你现在应该掌握了**:\n\n✅ **为什么使用组件库**\n- 开箱即用,久经考验,专注业务\n- markdown-flow-ui vs 手写组件对比\n\n✅ **核心组件 `<MarkdownFlow>`**\n- `initialContentList` - 传入块数组\n- `enableTypewriter` - 启用打字机效果\n- `typingSpeed` - 控制打字速度\n- `isFinished` - 控制完成状态\n- `onSend` - 处理用户交互\n\n✅ **处理用户交互**\n- 单选按钮: `{ buttonText }`\n- 文本输入: `{ variableName, inputText }`\n- 多选按钮: `{ variableName, selectedValues }`\n\n✅ **打字机效果配置**\n- 速度建议: 20-100ms\n- 提供跳过选项\n\n✅ **辅助组件**\n- `<InteractionPanel>` - 交互面板\n- `<VariableEditor>` - 变量编辑器\n- `<ScrollableMarkdownFlow>` - 自动滚动\n\n✅ **最佳实践**\n- 正确分割 contentList\n- 合理设置打字速度\n- 处理 onSend 回调\n- 提供跳过按钮\n- 使用 ScrollableMarkdownFlow\n\n**你不需要记住**:\n- ❌ 组件的底层实现细节\n- ❌ 所有属性的默认值\n- ❌ 打字机效果的算法\n\n**接下来**,我们进入第五章的核心实战部分:**用 AI 构建前端界面**。这是本章篇幅最大的部分(40%),我们将学习如何用 AI Prompt 模板和代码审查清单,快速构建前端应用。\n"
    },
    {
      "outline_item_bid": "16b5be108ab547dfaceaceca0a4dee4f",
      "title": "Demo项目实战",
      "type": 401,
      "hidden": 0,
      "parent_bid": "0bc85fd1cd3a43a18c2cdc704910b505",
      "position": "0504",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 实战准备 - 三个渐进任务\n\n欢迎来到第五章的最后一部分,{{sys_user_nickname}}!\n\n现在你已经学会了:\n- ✅ 前端架构的核心概念(组件、状态、数据流)\n- ✅ markdown-flow-ui 组件库的使用\n- ✅ Vibe Coding 工作流(描述需求、审查代码、测试调试)\n\n接下来,我们要通过三个渐进任务,让你**动手实践**,将所学知识应用到 Demo 项目中。\n\n**三个任务的难度递增**:\n\n!===\n| 任务 | 难度 | 核心技能 | 预计时间 |\n|------|------|---------|---------|\n| 任务 1: 修改主题颜色 | ⭐ 简单 | 用 AI 修改样式 | 15 分钟 |\n| 任务 2: 添加\"复制\"按钮 | ⭐⭐ 中等 | 用 AI 添加新功能 | 30 分钟 |\n| 任务 3: 基于你的项目想法 | ⭐⭐⭐ 困难 | 完整 Vibe Coding 流程 | 45 分钟 |\n!===\n\n**准备工作**:\n1. ✅ 确保 Demo 项目已启动:`cd demo && npm run dev`\n2. ✅ 打开浏览器访问 `http://localhost:3000`\n3. ✅ 准备好你的 AI 助手(Claude Code / ChatGPT / Cursor)\n\n结合你的项目想法'''{{project_idea}}''',完成这三个任务后,你将能够:\n- 用 AI 修改样式,调整界面配色\n- 用 AI 添加新功能,增强用户体验\n- 在你自己的项目方向上应用 Vibe Coding 技能\n\n准备好了吗?让我们从最简单的任务开始!\n\n---\n\n# 块 2: 实战任务 1 - 修改主题颜色（练习用 AI 修改样式）\n\n**任务目标**: 将 Demo 项目的主色调从蓝色改为你喜欢的颜色\n\n**当前配色**:\n- 主色调: 蓝色 (#3b82f6)\n- 悬停色: 深蓝 (#2563eb)\n- 背景色: 浅蓝 (#eff6ff)\n\n**你要修改为**（选择一个你喜欢的颜色）:\n- 绿色系: #10b981 (翠绿)\n- 紫色系: #8b5cf6 (紫罗兰)\n- 橙色系: #f59e0b (琥珀)\n- 或自定义颜色\n\n**修改步骤**:\n\n**Step 1: 向 AI 询问需要修改哪些文件**\n\n!===\n```\nPrompt: \"在 Demo 项目中,我想把主色调从蓝色改为绿色 #10b981。\n\n请告诉我:\n1. 需要修改哪些文件?\n2. 需要修改哪些 CSS 变量或类名?\n3. 给出完整的修改方案。\n\n项目使用 Tailwind CSS 和 CSS 变量。\"\n```\n!===\n\n**Step 2: 应用 AI 的建议,修改配色**\n\nAI 可能会告诉你修改类似这样的文件:\n- `app/globals.css` - CSS 变量定义\n- 或使用 Tailwind CSS 的配置文件\n\n**Step 3: 测试验证**\n\n!===\n```bash\n# 在浏览器中测试:\n1. 刷新页面,查看颜色是否改变\n2. 检查按钮、链接、交互面板的颜色\n3. 检查悬停效果是否正确\n4. 使用 Chrome DevTools 检查 CSS 变量值\n```\n!===\n\n**检查清单**:\n!===\n- [ ] 主色调是否改变?\n- [ ] 悬停色是否改变?\n- [ ] 背景色是否改变?\n- [ ] 所有元素的颜色是否协调?\n- [ ] 是否有遗漏的元素?\n!===\n\n**如果遇到问题**:\n\n**问题**: 部分元素颜色没有改变\n!===\n```\nPrompt: \"我修改了 CSS 变量,但有些按钮的颜色没有改变。\n\n我修改的内容:\n[粘贴你的修改]\n\n哪些元素颜色改变了:\n- 主按钮 ✅\n- 链接 ✅\n\n哪些元素没有改变:\n- 交互按钮 ❌\n- 侧边栏 ❌\n\n请帮我定位问题并提供解决方案。\"\n```\n!===\n\n---\n\n# 块 3: 实战任务 2 - 添加\"复制\"按钮（练习用 AI 添加功能）\n\n**任务目标**: 在 MarkdownFlow 内容渲染区添加一个\"复制\"按钮,点击后复制内容到剪贴板\n\n**需求**:\n- 位置: MarkdownFlow 内容区的右上角\n- 功能: 点击后复制当前显示的内容\n- 样式: 圆形按钮,灰色背景,鼠标悬停时变深\n- 反馈: 复制成功后显示提示\"已复制!\"(2 秒后消失)\n\n**修改步骤**:\n\n**Step 1: 向 AI 描述需求**\n\n!===\n```\nPrompt: \"我想在 Demo 项目的 MarkdownFlow 组件中添加一个'复制'按钮。\n\n需求:\n1. 位置: MarkdownFlow 内容渲染区的右上角\n2. 功能: 点击后复制当前显示的内容到剪贴板\n3. 样式: 圆形按钮,灰色背景 #6b7280,悬停时 #4b5563\n4. 图标: 使用复制图标(可以用 emoji 📋 或图标库)\n5. 反馈: 复制成功后显示提示\"已复制!\",2 秒后消失\n\n实现要求:\n1. 使用 navigator.clipboard.writeText() 复制内容\n2. 使用 useState 管理\"已复制\"状态\n3. 使用 setTimeout 在 2 秒后重置状态\n\n请给出完整的组件代码,包括:\n1. 按钮组件定义\n2. 复制逻辑\n3. 样式定义\n4. 如何集成到现有的 MarkdownFlow 组件中\n```\n!===\n\n**Step 2: AI 生成代码**\n\nAI 会生成代码,你需要:\n1. 仔细阅读 AI 的说明\n2. 按照 AI 的指示,复制代码到对应文件\n3. 理解关键部分(下面会讲)\n\n**Step 3: 理解关键部分**\n\n!===\n```tsx\n// 你需要理解的关键部分:\n\n// 1. 状态管理 - 是否已复制\nconst [copied, setCopied] = useState(false);\n\n// 2. 复制逻辑\nconst handleCopy = async () => {\n  try {\n    await navigator.clipboard.writeText(content);  // ← 复制到剪贴板\n    setCopied(true);  // ← 显示\"已复制\"\n    setTimeout(() => setCopied(false), 2000);  // ← 2 秒后重置\n  } catch (err) {\n    console.error('复制失败:', err);\n  }\n};\n\n// 3. 按钮渲染\nreturn (\n  <button\n    onClick={handleCopy}  // ← 绑定事件\n    className=\"copy-button\"\n  >\n    {copied ? '已复制!' : '📋'}  {/* ← 根据状态显示文字 */}\n  </button>\n);\n```\n!===\n\n**Step 4: 测试验证**\n\n!===\n```bash\n# 在浏览器中测试:\n1. 点击复制按钮,查看是否显示\"已复制!\"\n2. 打开文本编辑器,粘贴内容,查看是否正确\n3. 等待 2 秒,查看按钮是否恢复为 📋\n4. 使用 React DevTools 查看 copied 状态变化\n```\n!===\n\n**检查清单**:\n!===\n- [ ] 复制按钮是否显示在正确位置?\n- [ ] 点击按钮是否复制内容?\n- [ ] 是否显示\"已复制!\"提示?\n- [ ] 2 秒后提示是否消失?\n- [ ] 按钮样式是否正确?\n- [ ] 复制失败是否有错误处理?\n!===\n\n**如果遇到问题**:\n\n**问题**: 复制不工作\n!===\n```\nPrompt: \"我添加了复制按钮,但点击后没有反应。\n\n浏览器控制台显示:\n[粘贴错误信息]\n\n我的代码:\n[粘贴代码]\n\n请帮我定位问题。\"\n```\n!===\n\n---\n\n# 块 4: 实战任务 3 - 基于你的项目想法（完整 Vibe Coding 流程）\n\n**任务目标**: 基于你的项目想法'''{{project_idea}}''',在 Demo 项目中实现一个相关功能\n\n这个任务是**开放式**的,让你在自己感兴趣的方向上应用 Vibe Coding 技能。\n\n**如果你还没有明确的项目想法**,可以从以下方向选择:\n\n!===\n**方向 1: 历史记录功能**\n- 记录用户的每次生成内容\n- 显示在侧边栏,点击可查看历史记录\n- 使用 localStorage 持久化存储\n\n**方向 2: 导出功能**\n- 添加\"导出为 Markdown\"按钮\n- 下载当前生成的内容为 .md 文件\n- 支持导出为 PDF(可选)\n\n**方向 3: 分享功能**\n- 生成分享链接\n- 其他人通过链接查看生成的内容\n- 需要后端支持(可选)\n\n**方向 4: 自定义功能**（推荐）\n- 基于你的项目想法实现一个功能\n- 例如:如果你想做\"AI 学习助手\",可以添加\"保存笔记\"功能\n- 例如:如果你想做\"内容生成器\",可以添加\"模板库\"功能\n!===\n\n**完整 Vibe Coding 流程**:\n\n**Step 1: 明确需求**\n\n基于你的项目想法,写下具体需求:\n\n!===\n```\n我的项目想法: [你的项目想法]\n\n我想实现的功能: [具体功能描述]\n\n具体需求:\n1. 界面: [描述界面布局和元素]\n2. 交互: [描述用户如何操作]\n3. 数据: [描述需要存储哪些数据]\n4. API: [是否需要后端 API 支持]\n```\n!===\n\n**Step 2: 向 AI 描述需求**\n\n!===\n```\nPrompt: \"我想在 Demo 项目中实现 [功能名称]。\n\n背景:\n我的项目想法是 [你的项目想法]。\n\n功能需求:\n1. [需求 1]\n2. [需求 2]\n3. [需求 3]\n\n技术要求:\n- 使用 React + TypeScript\n- 使用 markdown-flow-ui 组件库\n- 如果需要数据持久化,使用 localStorage\n- 保持与 Demo 项目的代码风格一致\n\n请帮我:\n1. 分析这个功能需要哪些组件\n2. 设计数据结构\n3. 给出实现步骤\n4. 提供完整的代码实现\n```\n!===\n\n**Step 3: AI 生成代码并理解关键部分**\n\nAI 会给你完整的实现方案,你需要:\n\n1. **理解整体架构**\n   - 需要创建哪些组件?\n   - 组件之间如何通信?\n   - 数据如何流动?\n\n2. **理解关键代码**\n   - 状态管理逻辑\n   - 数据持久化逻辑\n   - API 调用逻辑(如果有)\n\n3. **应用代码**\n   - 按照 AI 的指示创建文件\n   - 复制代码到对应位置\n   - 修改必要的导入路径\n\n**Step 4: 测试验证**\n\n根据功能的具体需求,逐一测试:\n- ✅ 界面是否正确显示?\n- ✅ 交互是否正常工作?\n- ✅ 数据是否正确存储?\n- ✅ 刷新页面数据是否保持?\n\n**Step 5: 迭代优化**\n\n如果基本功能可以工作,继续让 AI 帮你优化:\n- 添加加载状态\n- 添加错误处理\n- 优化样式\n- 添加动画效果\n\n**完整示例:实现\"历史记录\"功能**（如果你选择这个方向）\n\n!===\n```\nStep 1: 明确需求\n- 侧边栏显示历史记录列表\n- 每条记录显示: 时间、内容预览(前 50 字)\n- 点击记录,在主区域显示完整内容\n- 使用 localStorage 存储,最多保存 20 条\n\nStep 2: 向 AI 描述需求\n[完整的 Prompt,如上所示]\n\nStep 3: 理解关键代码\n- useState 管理历史记录数组\n- useEffect 从 localStorage 读取\n- 添加记录时更新数组和 localStorage\n- 点击记录时更新当前显示内容\n\nStep 4: 测试\n- 生成几次内容,查看历史记录是否保存\n- 点击历史记录,查看是否正确显示\n- 刷新页面,查看历史是否保持\n\nStep 5: 优化\n- 添加\"清空历史\"按钮\n- 添加\"删除单条记录\"功能\n- 添加时间格式化(如\"5 分钟前\")\n```\n!===\n\n**你需要做的**:\n1. ✅ 选择一个功能方向(推荐基于你的项目想法)\n2. ✅ 写下具体需求\n3. ✅ 向 AI 描述需求\n4. ✅ 理解 AI 生成的代码\n5. ✅ 应用代码并测试\n6. ✅ 迭代优化\n\n---\n\n# 块 5: 实战总结与第五章总结\n\n**恭喜你,{{sys_user_nickname}}!** 你已经完成了第五章的所有实战任务!\n\n**你在这三个任务中学到了**:\n\n**任务 1: 修改主题颜色**\n- ✅ 用 AI 修改样式的完整流程\n- ✅ 如何定位 CSS 变量和类名\n- ✅ 如何测试和验证样式修改\n\n**任务 2: 添加复制按钮**\n- ✅ 用 AI 添加新功能的完整流程\n- ✅ 状态管理(useState)\n- ✅ 事件处理和反馈提示\n- ✅ 浏览器 API 使用(navigator.clipboard)\n\n**任务 3: 基于你的项目想法**\n- ✅ 完整的 Vibe Coding 工作流\n- ✅ 如何明确需求和向 AI 描述\n- ✅ 如何理解 AI 生成的代码\n- ✅ 如何测试和迭代优化\n- ✅ 在自己的项目方向上应用技能\n\n**第五章总结**:\n\n你现在应该能够:\n- ✅ 理解前端架构(组件、状态、数据流)\n- ✅ 掌握 markdown-flow-ui 组件库使用\n- ✅ 学会用 AI 构建前端界面(Prompt 模板 + 代码审查)\n- ✅ 完成实战任务(修改样式、添加功能、基于项目想法开发)\n\n**核心要点回顾**:\n\n!===\n| 要点 | 说明 |\n|------|------|\n| **markdown-flow-ui 是核心** | 你必须掌握组件库的使用,这是无法让 AI 代替的 |\n| **架构理解很重要** | 你需要理解组件层级和数据流,但不需要记住所有细节 |\n| **AI 是你的助手** | React/TypeScript 代码可以让 AI 生成,你专注于设计和理解关键部分 |\n| **测试是必须的** | 每次修改后都要测试,确保功能正常 |\n| **迭代是常态** | 第一次生成的代码可能不完美,要学会让 AI 帮你优化 |\n!===\n\n**前后端开发对比**:\n\n!===\n| 方面 | 后端（第 4 章） | 前端（第 5 章） |\n|------|---------------|---------------|\n| 核心技能 | MarkdownFlow 语法 | markdown-flow-ui 组件库 |\n| 架构理解 | API → Service → Library | 组件层级、状态管理 |\n| AI 工作流 | Prompt 模板、代码审查 | Prompt 模板、代码审查 |\n| 实战任务 | 添加 API 端点 | 修改样式、添加组件 |\n!===\n\n**下一步: 第六章预告**\n\n!===\n**第 6 章: 项目总结与进阶路径**\n\n你将学习:\n1. 项目复盘 - 回顾完整的开发流程\n2. 进阶学习路径 - 如何继续深入学习\n3. 课程总结与展望\n!===\n\n**继续保持 Vibe Coding 思维**:\n- 设计 > 实现\n- 理解 > 记忆\n- AI 协作 > 单打独斗\n\n结合你的项目想法'''{{project_idea}}''',你现在已经掌握了前后端开发的核心技能。在第六章,我们将总结整个课程,并为你规划进阶学习路径!\n\n---\n\n**准备好了吗?让我们进入第六章,完成整个课程的学习!** 🚀\n"
    },
    {
      "outline_item_bid": "386d036a05fa41be8b19a4afe41b7649",
      "title": "Vibe Coding 开发模式回顾",
      "type": 401,
      "hidden": 0,
      "parent_bid": "7e10d317f3b444cabdfd70aa0e3e7a2c",
      "position": "0601",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 从第五章到第六章 - 课程收官\n\n恭喜你，{{sys_user_nickname}}！完成了前五章的学习。\n\n回顾一下这一路的旅程：\n\n!===\n**第 1 章**：课程导论 → 了解课程架构，配置开发环境\n**第 2 章**：工具生态全景 → 体验低代码平台，理解 MarkdownFlow 优势\n**第 3 章**：Vibe Coding 工作流 → 掌握 AI 辅助编程范式，了解 Demo 项目\n**第 4 章**：后端开发实战 → 精通 MarkdownFlow 语法，学会用 AI 构建 API\n**第 5 章**：前端开发实战 → 掌握组件库使用，学会用 AI 构建界面\n!===\n\n你已经掌握了从零到一开发 AI 应用的完整技能栈。现在，第六章要帮你做三件事：\n\n**1. 巩固核心知识**（30%）\n- 回顾 Vibe Coding 开发模式\n- 总结 MarkdownFlow 最佳实践\n- 提供自查清单，验证学习成果\n\n**2. 掌握项目部署**（30%）\n- 理解部署全流程（Docker + 云服务器）\n- 掌握前端部署思路（Vercel/Netlify）\n- 了解域名配置与 HTTPS\n\n**3. 规划进阶路径**（40%）\n- 根据你的目标推荐个性化学习路径\n- 提供进阶资源（官方文档、社区、课程）\n- 设置结业认证和进阶挑战\n\n让我们开始第六章的学习！\n\n---\n\n# 块 2: Vibe Coding 提效总结\n\n在第三章，你学习了 Vibe Coding 的核心理念:**人类设计 + AI 实现 + 人类验证**。\n\n现在，根据你的编程背景'''{{programming_experience}}'''，让我们总结 Vibe Coding 如何帮你提效。\n\n## 有编程基础：如何用 AI 加速 10 倍？\n\n如果你有编程基础（学过 Python/JavaScript 等），Vibe Coding 能让你的开发效率提升 **4-10 倍**。\n\n!===\n| 开发任务 | 传统开发耗时 | Vibe Coding 耗时 | 提效倍数 |\n|---------|------------|----------------|---------|\n| 添加新 API 端点 | 60 分钟（写代码 + 调试 + 测试） | 15 分钟（写 Prompt + 审查 + 测试） | 4x |\n| 修改前端样式 | 30 分钟（改 CSS + 调整布局） | 5 分钟（描述需求给 AI） | 6x |\n| 集成第三方 API | 120 分钟（查文档 + 写代码 + 调试） | 20 分钟（Prompt + 代码审查） | 6x |\n| 理解新项目架构 | 180 分钟（逐行阅读代码） | 30 分钟（阅读 AGENTS.md + 询问 AI） | 6x |\n| 学习新框架（如 FastAPI） | 3 天（看教程 + 写 Demo） | 6 小时（AI 讲解 + 实战） | 12x |\n!===\n\n**关键提效点**：\n1. **AGENTS.md** - 让 AI 快速理解项目上下文，减少 80% 的\"代码理解\"时间\n2. **AI Prompt 模板** - 标准化需求描述，减少 70% 的\"调试\"时间\n3. **代码审查清单** - 快速验证 AI 生成的代码，确保质量\n\n**适用场景**：\n- ✅ **原型开发** - 快速验证想法，2 小时搭建 MVP\n- ✅ **需求迭代** - 客户改需求？10 分钟重新生成代码\n- ✅ **学习新框架** - 用 AI 当导师，边学边做\n\n**不适用场景**：\n- ❌ **高性能优化** - AI 生成的代码可能不够优化，需要人工调优\n- ❌ **复杂算法** - AI 可能生成错误逻辑，需要人工验证\n- ❌ **安全敏感代码** - 必须人工审查，AI 只能辅助\n\n## 无编程基础：AI 成为你的编程导师\n\n如果你之前没有编程基础，Vibe Coding 能让你**从零到能开发 AI 应用**。\n\n!===\n**传统学习路径**（6-12 个月）：\n1. 学 Python 语法（1-2 个月）\n2. 学 Web 框架（FastAPI/Django，2-3 个月）\n3. 学前端（React/TypeScript，3-4 个月）\n4. 学部署（Docker/Nginx，1 个月）\n5. 做项目实战（1-2 个月）\n\n**Vibe Coding 学习路径**（2-4 周）：\n1. 理解核心概念（1 周） - 什么是 API、组件、状态\n2. 学 MarkdownFlow 语法（3 天） - 控制 AI 输出\n3. 用 AI 构建项目（1 周） - 边学边做，AI 讲解代码\n4. 部署上线（2 天） - 让项目可访问\n!===\n\n**AI 成为导师的 4 个阶段**：\n\n**阶段 1：看不懂代码**（第 1-2 章）\n- AI 帮你：生成代码 + 逐行讲解\n- 你学到：基本概念（函数、变量、循环）\n\n**阶段 2：能看懂代码**（第 3-4 章）\n- AI 帮你：生成代码 + 讲解架构\n- 你学到：分层架构（API → Service → Library）\n\n**阶段 3：能改代码**（第 4-5 章）\n- AI 帮你：生成修改方案 + 解释为什么这样改\n- 你学到：如何描述需求给 AI\n\n**阶段 4：能独立开发**（第 6 章后）\n- AI 帮你：审查代码 + 优化建议\n- 你学到：代码规范、最佳实践\n\n**关键转变**：\n- ❌ 传统：记住所有语法 → 容易忘记\n- ✅ Vibe Coding：理解架构 + 会描述需求 → 长期有效\n\n---\n\n# 块 3: MarkdownFlow 核心优势回顾\n\n在第二章，你学习了 MarkdownFlow 的三大优势。让我们快速回顾：\n\n!===\n**优势 1：精准控制 AI 输出**\n- **vs 纯 Prompt**：Prompt 容易\"跑偏\"，MarkdownFlow 用语法约束输出格式\n- **示例**：`===保留内容===` 确保代码块不被 AI 修改\n\n**优势 2：变量系统**\n- **个性化**：`{{sys_user_nickname}}` 让每个学员体验不同\n- **状态管理**：`{{project_idea}}` 贯穿整个课程\n\n**优势 3：交互式内容生成**\n- **收集用户信息**：`?[%{{next_step}} 选项1|选项2]`\n- **动态调整内容**：根据用户选择生成不同内容\n!===\n\n**与其他工具对比**（一句话总结）：\n\n**vs 低代码平台（扣子、Dify）**：\n- 低代码：快速搭建，但灵活性差，难以精确控制\n- MarkdownFlow：代码级灵活性，用 Markdown 语法降低门槛\n\n**vs 传统代码（LangChain、Python）**：\n- 传统代码：灵活但复杂，需要 200+ 行代码实现交互\n- MarkdownFlow：简洁，10 行 Markdown 实现同样功能\n\n**核心价值**：**用自然语言控制 AI 输出，同时保持代码级灵活性**。\n\n---\n\n# 块 4: 课程收获自查 + 收集反馈\n\n完成前五章的学习后，你应该掌握了这些核心技能。用下面的清单自查一下：\n\n!===\n**技能自查清单**：\n\n**1. Vibe Coding 工作流**\n- [ ] 能用自然语言描述需求给 AI\n- [ ] 能审查 AI 生成的代码（用第 4-5 章的检查清单）\n- [ ] 能用 AGENTS.md 让 AI 理解项目上下文\n\n**2. MarkdownFlow 语法**\n- [ ] 掌握基础语法（`===`、`{{变量}}`、`?[]`、`---`）\n- [ ] 会设计变量系统（系统级 vs 课程级）\n- [ ] 会设计交互流程（单选、多选、文本输入）\n\n**3. 后端开发**\n- [ ] 理解后端架构（API → Service → Library）\n- [ ] 能用 AI 添加新 API 端点\n- [ ] 能用 AI 集成第三方 API（天气、翻译等）\n\n**4. 前端开发**\n- [ ] 理解前端架构（组件层级、状态管理、数据流）\n- [ ] 掌握 markdown-flow-ui 组件库（`<MarkdownFlow>`、`InteractionPanel`）\n- [ ] 能用 AI 修改样式和添加功能\n\n**5. Demo 项目实战**\n- [ ] 完成第 4.4 章的三个渐进任务（修改内容 → 设计流程 → 添加功能）\n- [ ] 完成第 5.4 章的三个渐进任务（修改样式 → 添加按钮 → 基于项目想法开发）\n!===\n\n**你的课程反馈**：\n\n?[%{{course_feedback}}\n  通过这门课程,你对 Vibe Coding 和 MarkdownFlow 有什么感受？请分享你的收获、困惑或建议（可选填）。\n]\n\n感谢你的反馈！你的建议将帮助我们不断改进课程。\n\n接下来，让我们进入最佳实践总结。\n"
    },
    {
      "outline_item_bid": "3f44cddca033468cbcf37e4d0607e678",
      "title": "最佳实践总结",
      "type": 401,
      "hidden": 0,
      "parent_bid": "7e10d317f3b444cabdfd70aa0e3e7a2c",
      "position": "0602",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 变量设计原则（DO's and DON'Ts）\n\n在第四章，你学习了 MarkdownFlow 的变量系统。现在让我们总结**变量设计的最佳实践**。\n\n## 最佳实践 ✅\n\n!===\n**1. 命名规范**\n- ✅ 系统级变量用 `sys_` 前缀\n  - `sys_user_nickname`、`sys_user_background`、`sys_user_style`\n  - 全课程通用，避免重复收集\n- ✅ 使用下划线分隔单词\n  - `programming_experience` > `programmingExperience`（不用驼峰命名）\n- ✅ 变量名语义清晰\n  - `learning_goal` > `goal`（避免歧义）\n  - `course_feedback` > `feedback`（明确是\"课程\"反馈）\n- ✅ 避免缩写\n  - `background` > `bg`（保持可读性）\n\n**2. 收集时机**\n- ✅ 首次需要时收集\n  - 不要提前收集暂时用不到的变量\n  - 示例：`project_idea` 在第 3.3 章收集（AGENTS.md 实战前），而非第 1 章\n- ✅ 集中收集相关变量\n  - 同一主题的变量放在同一节收集\n  - 示例：第 1.2 章集中收集 `programming_experience` + `ai_experience`\n\n**3. 使用策略**\n- ✅ 复用已有变量\n  - 第 6.4 章使用第 3 章收集的 `{{project_idea}}`\n  - 避免重复收集同一信息\n- ✅ 用三引号强调变量\n  - `用户的学习目标是'''{{learning_goal}}'''，给出针对性建议。`\n  - 让 AI 注意到这是重要变量\n\n**4. 管理规范**\n- ✅ 在 `variables.md` 中登记所有变量\n  - 包含：变量名、类型、说明、收集位置、使用位置\n- ✅ 更新使用位置\n  - 每次使用变量时，在 `variables.md` 中添加章节编号\n!===\n\n## DON'Ts - 常见错误 ❌\n\n!===\n**1. 命名错误**\n- ❌ 使用缩写：`bg`、`exp`、`pref`\n  - 难以理解，容易混淆\n- ❌ 驼峰命名：`userName`、`userBackground`\n  - MarkdownFlow 推荐下划线风格\n- ❌ 歧义命名：`goal`、`feedback`、`idea`\n  - 不知道是什么目标、什么反馈\n\n**2. 收集错误**\n- ❌ 重复收集同一变量\n  - 第 1 章收集了 `sys_user_nickname`，第 3 章又问\"你叫什么名字？\"\n- ❌ 提前收集暂时用不到的变量\n  - 第 1 章就收集 `deployment_platform`，但第 6 章才用到\n- ❌ 收集但不使用的变量\n  - 收集了 `favorite_color`，但后续内容没有引用\n\n**3. 使用错误**\n- ❌ 使用未收集的变量\n  - 第 3 章引用 `{{ai_experience}}`，但第 1 章忘记收集\n- ❌ 变量名拼写错误\n  - 收集时写 `learning_goal`，使用时写 `learningGoal`\n- ❌ 忘记更新 `variables.md`\n  - 新增变量后不登记，导致重复收集\n\n**4. 管理错误**\n- ❌ 不使用 `variables.md` 统一管理\n  - 导致变量散落在各章节，难以查找\n- ❌ 变量说明不清晰\n  - 只写\"用户目标\"，不写\"学习目标（快速入门/深入学习/掌握工作流）\"\n!===\n\n**实战案例**（引用第 4 章）：\n\n在第 4.2 章学习变量设计时，你看到了这个示例：\n\n!===\n```markdown\n用户的编程经验是'''{{programming_experience}}'''，AI 经验是'''{{ai_experience}}'''，\n学习目标是'''{{learning_goal}}'''。\n\n根据这三个维度推荐学习路径:\n- 如果 programming_experience 是\"零基础\"，建议重点学习第 4.1 章（后端架构理解）\n- 如果 ai_experience 是\"没用过\"，建议重点学习第 4.3 章（AI Prompt 模板）\n- 如果 learning_goal 是\"深入 MarkdownFlow\"，建议重点学习第 4.2 章（语法深度掌握）\n```\n!===\n\n这个示例展示了**多变量组合使用**的最佳实践：\n- ✅ 变量命名清晰（`programming_experience` vs `ai_experience`）\n- ✅ 用三引号强调变量\n- ✅ 根据变量组合推荐个性化内容\n\n---\n\n# 块 2: 交互流程设计技巧\n\n在第 4-5 章，你学习了如何设计交互式内容。现在让我们总结**交互流程设计的最佳实践**。\n\n## 渐进式收集 vs 一次性收集\n\n!===\n**渐进式收集**（推荐）:\n- **特点**：分散到多个块，每次收集 1-2 个变量\n- **优势**：\n  - 减少学员负担（不会一次性看到 10 个问题）\n  - 增强对话感（像聊天一样逐步了解）\n  - 提高完成率（学员不会因为问题太多而放弃）\n- **适用场景**：\n  - 课程导论（第 1 章）：分 3 个块收集 7 个变量\n  - 实战章节（第 4-5 章）：边学边验证，收集反馈\n- **示例**：\n  ```markdown\n  # 块 1：课程概览\n  ?[%{{ai_dev_misconception}} AI 开发很难|AI 开发很简单]\n\n  # 块 2：课程适用人群\n  ?[%{{programming_experience}} 零基础|学过 Python|熟悉全栈开发]\n  ?[%{{ai_experience}} 没用过|用过 ChatGPT|熟悉 AI 工具]\n\n  # 块 3：学习路径推荐\n  ?[%{{learning_goal}} 快速入门|深入 MarkdownFlow|掌握 Vibe Coding 工作流]\n  ```\n\n**一次性收集**:\n- **特点**：集中在一个块，一次收集 3-5 个变量\n- **优势**：\n  - 快速收集信息（适合简单场景）\n  - 节省块数（不需要分散到多个块）\n- **劣势**：\n  - 学员负担重（一次性回答多个问题）\n  - 容易放弃（问题太多，学员直接跳过）\n- **适用场景**：\n  - 问卷调查（非教学内容）\n  - 快速配置（如选择部署平台、服务器区域等）\n- **示例**：\n  ```markdown\n  # 块 1：快速配置\n  ?[%{{deployment_platform}} 阿里云|腾讯云|AWS]\n  ?[%{{server_region}} 华北|华东|华南]\n  ?[%{{server_config}} 1核2G|2核4G|4核8G]\n  ```\n!===\n\n**选择建议**：\n- ✅ **教学内容**：用渐进式收集（增强对话感）\n- ✅ **配置/问卷**：用一次性收集（快速完成）\n\n## 单选 vs 多选 vs 文本输入\n\n!===\n```markdown\n单选\n?[%{{var}} 选项1|选项2|选项3]\n多选\n?[%{{var}} 选项1||选项2||选项3]\n文本输入\n?[%{{var}} 问题描述]\n```\n!===\n\n**最佳实践**：\n- ✅ **单选**：提供 3-5 个互斥选项\n  - 避免选项过多（超过 5 个会让学员选择困难）\n  - 避免选项过少（只有 2 个时考虑用对比表格代替）\n- ✅ **多选**：提供 3-6 个可组合选项\n  - 用 `||` 表示多选（vs 单选的 `|`）\n  - 适合收集\"已使用过的工具\"、\"感兴趣的方向\"等\n- ✅ **文本输入**：问题要清晰，提供示例\n  - 避免过于开放（\"你有什么想说的？\"→ 学员不知道说什么）\n  - 提供引导（\"请分享你的收获、困惑或建议\"→ 学员知道从哪些角度回答）\n\n## 交互位置设计\n\n!===\n**最佳位置**：\n\n**1. 引言后收集背景信息**\n- 块 1：引言（介绍章节目标）\n- 块 2：收集变量（了解学员背景）→ ✅ 最佳位置\n- 块 3-N：正式内容\n\n**2. 章节末收集学习反馈**\n- 块 1-N：正式内容\n- 块 N+1：小结 + 收集反馈 → ✅ 最佳位置\n\n**3. 关键决策点收集选择**\n- 块 3：讲解两种方案的优劣\n- 块 4：收集学员选择 → ✅ 最佳位置\n- 块 5：根据选择推荐不同内容\n!===\n\n**避免的位置**：\n- ❌ 正文中间突然收集（打断思路）\n- ❌ 收集后立刻进入下一章（没有给学员消化时间）\n\n---\n\n!===\n# 块 3: 常见问题与解决方案\n在前五章的学习中，你可能遇到过这些问题。这里提供快速解决方案：\n**问题 1：AI 生成的代码报错怎么办？**\n\n**解决方案**：\n1. 复制完整错误信息\n2. 告诉 AI：\"我运行代码时遇到这个错误：[粘贴错误信息]，请帮我分析原因并修复。\"\n3. AI 会分析错误原因 + 提供修复方案\n4. 用代码审查清单验证修复后的代码\n\n**预防措施**：\n- 用 Prompt 模板明确要求 AI 添加错误处理\n- 用代码审查清单检查是否有异常捕获\n\n\n**问题 2：如何让 AI 理解项目上下文？**\n\n**解决方案**：\n1. 编写 AGENTS.md（参考第 3.3 章）\n2. 告诉 AI：\"请先阅读 /demo/AGENTS.md，了解项目架构。\"\n3. 然后再描述具体需求\n\n**最佳实践**：\n- AGENTS.md 包含：项目概述、目录结构、核心模块、开发规范\n- 每次新建 Chat 时，先让 AI 读 AGENTS.md\n\n\n**问题 3：MarkdownFlow 语法记不住怎么办？**\n\n**解决方案**：\n1. 收藏第 4.2 章（MarkdownFlow 语法深度掌握）\n2. 用时查阅，不需要死记硬背\n3. 常用语法（3 个）：\n\n```markdown\n# 单行保留内容\n===xxxx=== \n# 多行保留内容\n!===\nxxxx\n!===  \n\n# 可替换变量\n{{variable}}\n\n# 交互元素\n?[%{{var}} 选项]\n```\n\n**问题 4：部署时端口被占用怎么办？**\n\n**解决方案**：\n1. 检查哪个程序占用端口：\n   ```bash\n   # macOS/Linux\n   lsof -i :8000\n   # Windows\n   netstat -ano | findstr :8000\n   ```\n2. 停止占用端口的程序，或换一个端口\n3. 修改配置文件中的端口号（如 `PORT=8001`）\n\n\n\n**问题 5：SSE 连接中断怎么办？**\n\n**解决方案**：\n1. 检查后端是否正常运行（访问 `http://localhost:8000/docs`）\n2. 检查前端 API_URL 配置是否正确\n3. 检查网络（是否有代理、防火墙拦截）\n4. 查看浏览器控制台的错误信息，告诉 AI 分析\n\n\n\n**问题 6：AI 生成的代码风格不一致怎么办？**\n\n**解决方案**：\n1. 在 Prompt 中明确要求：\"请遵循项目现有代码风格（参考 AGENTS.md）。\"\n2. 使用代码格式化工具：\n   - Python：`black`、`autopep8`\n   - JavaScript/TypeScript：`prettier`\n3. 配置编辑器的自动格式化（保存时格式化）\n\n\n\n**问题 7：如何调试 MarkdownFlow 生成的内容？**\n\n**解决方案**：\n1. 查看后端日志（`uvicorn` 输出）\n2. 在 MarkdownFlow 内容中添加调试信息：\n   ```markdown\n   调试信息：当前变量值 {{variable_name}}\n   ```\n3. 用浏览器控制台查看 SSE 返回的数据\n\n\n\n**问题 8：前端样式不生效怎么办？**\n\n**解决方案**：\n1. 检查 CSS 类名是否正确（Tailwind CSS 类名区分大小写）\n2. 检查浏览器缓存（强制刷新：Ctrl+Shift+R）\n3. 用浏览器 DevTools 查看元素的实际样式\n4. 告诉 AI：\"我添加了样式 `className=\"...\"`，但不生效，请帮我分析。\"\n\n**遇到其他问题**？\n- 查阅官方文档：https://markdownflow.ai/docs\n- 提问社区：Discord、GitHub Discussions\n- 直接询问 AI：\"我在使用 MarkdownFlow 时遇到 [问题描述]，请帮我分析。\"\n\n!===\n---\n!===\n# 块 4: 实战检查清单（通用版）\n\n在第 4.3、5.3 章，你学习了后端和前端的代码审查清单。现在让我们整合为**通用检查清单**。\n\n每次让 AI 生成代码后，用这个清单验证：\n\n\n**代码质量检查清单**\n\n**1. 可读性 📖**\n- [ ] 变量/函数命名是否语义清晰？\n  - ✅ `get_user_info()` > ❌ `get_data()`\n- [ ] 是否有必要的注释？\n  - ✅ 复杂逻辑加注释 > ❌ 所有代码都加注释\n- [ ] 代码结构是否清晰？\n  - ✅ 单一职责原则（一个函数做一件事）\n\n**2. 安全性 🔒**\n- [ ] API 密钥是否从环境变量读取？\n  - ✅ `os.getenv(\"OPENAI_API_KEY\")` > ❌ `api_key = \"sk-...\"`\n- [ ] 是否有输入验证？\n  - ✅ 验证用户输入类型和范围 > ❌ 直接使用用户输入\n- [ ] 是否有错误处理？\n  - ✅ `try-except` 包裹可能出错的代码\n\n**3. 性能 ⚡**\n- [ ] 是否有不必要的重复计算？\n  - ✅ 缓存结果 > ❌ 每次都重新计算\n- [ ] 是否使用异步（如果适用）？\n  - ✅ `async def` + `await` > ❌ 同步阻塞\n- [ ] 是否有内存泄漏？\n  - ✅ 及时释放资源（关闭文件、数据库连接）\n\n**4. 用户体验 🎨**\n- [ ] 是否有加载状态提示？\n  - ✅ \"加载中...\" > ❌ 白屏等待\n- [ ] 是否有错误提示？\n  - ✅ \"API 调用失败，请稍后重试\" > ❌ 报错但不提示\n- [ ] 是否有打字机效果（MarkdownFlow 场景）？\n  - ✅ `enableTypewriter={true}` 提升体验\n\n**5. 可维护性 🔧**\n- [ ] 是否模块化？\n  - ✅ API → Service → Library 分层 > ❌ 所有逻辑写在一个文件\n- [ ] 是否有文档？\n  - ✅ AGENTS.md、README.md、函数注释\n- [ ] 是否遵循项目规范？\n  - ✅ 参考 AGENTS.md 中的开发规范\n\n\n**使用方法**：\n1. AI 生成代码后，不要立刻运行\n2. 用这个清单逐项检查\n3. 发现问题 → 告诉 AI：\"代码没有错误处理，请添加 try-except。\"\n4. AI 修复 → 再次检查 → 确认无误 → 运行测试\n\n**关键提醒**：\n- ✅ **检查清单是最低标准**，不是完美标准\n- ✅ **优先级**：安全性 > 可读性 > 性能 > 用户体验 > 可维护性\n- ✅ **根据场景调整**：原型开发可以降低要求，生产环境必须严格\n\n接下来，让我们进入项目部署章节。\n!==="
    },
    {
      "outline_item_bid": "01f49f7d879b46a5b56dac0dd16a2ed9",
      "title": "Demo 项目全景导览",
      "type": 401,
      "hidden": 0,
      "parent_bid": "bf841234eae84d6dbf0ee3122354e06f",
      "position": "0302",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：Demo 项目功能演示\n\n现在让我带你全面了解我们的 Demo 项目：**MarkdownFlow Playground**。\n\n这是一个**本地教学演示项目**，你将在第 4-5 章亲手改进和扩展它。理解它的架构和设计思想，是接下来实战的基础。\n\n根据你对 Vibe Coding 的理解'''{{vibe_understanding}}'''，我会调整讲解的侧重点。\n\n!===\n## Demo 项目核心功能\n\n**MarkdownFlow Playground** 是一个 **AI 内容生成助手**，核心功能包括：\n\n### 1. MarkdownFlow 文档编辑\n- 左侧编辑器：用户可以编写 MarkdownFlow 文档\n- 支持语法高亮\n- 实时文档分析（自动提取变量和块信息）\n\n### 2. 实时预览与交互\n- 右侧预览区域：实时渲染 AI 生成的内容\n- 支持打字机效果（流式输出）\n- 支持交互元素：\n  - 按钮选择（单选/多选）\n  - 文本输入\n  - 混合交互\n\n### 3. 变量管理\n- 中间变量面板：显示已收集的变量\n- 变量值可以手动编辑\n- 支持多变量组管理（可创建多个配置）\n\n### 4. 流式输出\n- AI 生成内容逐字显示\n- 类似 ChatGPT 的打字机效果\n- 使用 SSE（Server-Sent Events）技术\n\n### 5. 块导航\n- 支持多个 MarkdownFlow 块\n- 用 `---` 分隔\n- 可以跳转到任意块\n\n### 6. 文档分析\n- 自动分析文档结构\n- 提取所有变量\n- 识别交互块和内容块\n\n### 7. LLM 配置\n- 支持 OpenAI 兼容的 LLM Provider（OpenAI、DeepSeek 等）\n- 可以调整 model、temperature 等参数\n- API Key 通过环境变量配置\n!===\n\n**为什么做这个项目？**\n\n这个 Demo 项目是专门为教学设计的，它包含了 AI 应用开发的**所有核心要素**：\n- ✅ 前端交互（React + Next.js）\n- ✅ 后端 API（Python + FastAPI）\n- ✅ LLM 集成（流式输出、变量管理）\n- ✅ 状态管理（前端变量同步）\n- ✅ 实时渲染（打字机效果）\n\n学会开发和扩展这个项目，你就掌握了 AI 应用开发的 80% 核心技能。\n\n---\n!===\n# 块 2：技术栈详解\n\n现在让我详细解释我们为什么选择这些技术，以及它们如何协作。\n\n\n## 后端技术栈\n\n### Python 3.10+\n**为什么选 Python？**\n- ✅ AI 开发的首选语言（大部分 LLM SDK 都是 Python 优先）\n- ✅ 语法简洁，容易学习\n- ✅ 丰富的生态（FastAPI、Pydantic、异步支持）\n\n**我们如何使用？**\n- 处理 MarkdownFlow 文档解析\n- 调用 LLM API\n- 管理流式输出\n\n### FastAPI\n**为什么选 FastAPI？**\n- ✅ 性能优秀（基于 Starlette 和 Pydantic）\n- ✅ 原生支持异步（async/await）\n- ✅ 自动生成 API 文档（Swagger UI）\n- ✅ 类型检查（基于 Python type hints）\n\n**我们如何使用？**\n- 提供 RESTful API\n- 处理流式响应（Server-Sent Events）\n- 验证请求参数\n\n### markdown-flow (Python 库)\n**为什么选择 markdown-flow？**\n- ✅ 专门为 Python 后端设计的 MarkdownFlow 处理库\n- ✅ 与 FastAPI 无缝集成\n- ✅ 提供流式生成接口\n- ✅ 支持文档解析、变量管理、LLM 集成\n\n**我们如何使用？**\n- 解析 MarkdownFlow 文档语法\n- 管理变量和上下文\n- 生成 LLM Prompt\n- 处理流式输出\n\n\n\n## 前端技术栈\n\n### React 19\n**为什么选 React？**\n- ✅ 生态最成熟（组件库、工具链丰富）\n- ✅ 社区活跃，问题容易找到答案\n- ✅ 就业市场需求大\n\n**我们如何使用？**\n- 构建交互式 UI\n- 管理组件状态\n- 处理用户输入\n\n### Next.js 15\n**为什么选 Next.js？**\n- ✅ React 的最佳实践框架\n- ✅ App Router 架构（现代化路由）\n- ✅ 内置 Turbopack（极速打包器）\n- ✅ 性能优化开箱即用\n\n**我们如何使用？**\n- 项目脚手架\n- 路由管理（`app/` 目录）\n- 开发服务器和生产打包\n\n### TypeScript\n**为什么选 TypeScript？**\n- ✅ 类型安全，减少 bug\n- ✅ 更好的 IDE 支持（自动补全、重构）\n- ✅ 更易维护（类型即文档）\n\n**我们如何使用？**\n- 定义接口和类型\n- 确保前后端数据格式一致\n\n\n\n## UI 库\n\n### markdown-flow-ui\n**这是什么？**\n- MarkdownFlow 的官方 React 组件库\n- 提供开箱即用的交互式渲染\n\n**主要组件**：\n- `<MarkdownFlow />` - 核心渲染组件\n- `<InteractionPanel />` - 交互面板\n- `<ScrollableMarkdownFlow />` - 可滚动的 MarkdownFlow 容器\n\n### remark-flow\n**这是什么？**\n- MarkdownFlow 的解析器（基于 remark）\n- 将 MarkdownFlow 文档解析为 AST（抽象语法树）\n\n**为什么需要？**\n- 前端需要知道哪些是普通内容，哪些是交互元素\n- 支持语法高亮和验证\n\n### shadcn/ui\n**这是什么？**\n- 基于 Radix UI 的 React 组件库\n- 组件源码直接包含在项目中（可完全定制）\n- 使用 Tailwind CSS 样式\n\n**使用的组件**：\n- Button, Input, Textarea\n- Dialog, Tabs, Badge\n- Label, Dropdown Menu\n- Scroll Area, Card, Tooltip\n!===\n\n---\n\n## 前后端协作流程\n\n让我用一个 Mermaid 序列图，展示一次完整的交互流程：\n\n```mermaid\nsequenceDiagram\n    participant U as 用户\n    participant F as 前端 (React)\n    participant B as 后端 (FastAPI)\n    participant M as markdown-flow 库\n    participant L as LLM (OpenAI 兼容)\n\n    U->>F: 1. 编写 MarkdownFlow 文档\n    F->>B: 2. POST /api/v1/playground/markdownflow_info<br/>（分析文档）\n    B->>M: 3. 解析文档结构\n    M-->>B: 4. 返回变量、块信息\n    B-->>F: 5. 显示变量面板\n    U->>F: 6. 填充变量值，点击\"运行\"\n    F->>B: 7. POST /api/v1/playground/generate<br/>{content, block_index, variables}\n    B->>M: 8. 解析当前块，替换变量\n    M->>L: 9. 调用 LLM API (流式请求)\n    L-->>M: 10. 返回流式响应 (逐 token)\n    M-->>B: 11. 转换为 SSE 消息\n    B-->>F: 12. SSE 流式返回\n    F->>F: 13. 逐字渲染 (打字机效果)\n    F->>U: 14. 显示完整内容\n```\n\n**关键步骤解释**：\n\n1-2. **文档编辑和分析**：用户编辑文档，前端自动调用分析 API\n\n3-5. **文档结构解析**：`markdown-flow` 库解析文档，返回变量、块数量、块类型等信息\n\n6. **用户配置**：用户填充变量值，点击运行\n\n7-8. **生成请求**：前端发送流式生成请求，后端解析当前块并替换变量\n\n9-10. **调用 LLM**：发送流式请求，LLM 逐 token 返回内容\n\n11-12. **流式转发**：后端通过 Server-Sent Events (SSE) 将数据流式返回给前端\n\n13-14. **前端渲染**：前端逐字显示，实现打字机效果\n\n---\n\n# 块 3：目录结构深度解析\n\n理解项目结构是 Vibe Coding 的基础。当你需要修改某个功能时，必须知道代码在哪里。\n\n!===\n## 完整目录结构\n\n```\ndemo/\n├── main.py                         # FastAPI 应用入口（根目录）\n├── requirements.txt                # Python 依赖（75 个包）\n├── .env.example                    # 环境变量模板\n├── .env                            # 实际环境变量（需自行创建）\n├── AGENTS.md                       # AI 编程助手说明文档 ⭐ (1148 行)\n├── README.md                       # 项目说明\n│\n└── app/                            # 核心应用目录\n    ├── core.py                     # FastAPI 应用工厂（创建 app 实例）\n    │\n    ├── api/                        # API 路由层（薄层，仅路由转发）\n    │   └── v1/\n    │       └── playground_api.py   # Playground 相关 API 端点\n    │\n    ├── services/                   # 业务逻辑层（纯委托，调用 library）\n    │   └── playground_service.py   # Playground 服务（委托给 library）\n    │\n    ├── library/                    # 可重用库（核心逻辑）\n    │   └── llm/\n    │       ├── markdownflow_llm_client.py  # MarkdownFlow LLM 客户端\n    │       └── markdownflow_llm_models.py  # 数据模型\n    │\n    ├── models/                     # 数据模型层（Pydantic 模型）\n    │   └── playground_models.py    # Playground 的请求/响应模型\n    │\n    ├── middleware/                 # 中间件（日志、CORS 等）\n    │   └── logging_middleware.py\n    │\n    ├── utils/                      # 工具函数\n    │   └── logger.py               # 日志工具\n    │\n    └── config/                     # 配置管理\n        └── settings.py             # 环境变量读取（使用 Pydantic Settings）\n\nfrontend/                           # Next.js 15 前端（与 demo/ 同级）\n├── package.json                    # Node.js 依赖\n├── tsconfig.json                   # TypeScript 配置\n├── next.config.ts                  # Next.js 配置\n│\n└── src/\n    ├── app/                        # Next.js App Router\n    │   ├── layout.tsx              # 根布局\n    │   ├── page.tsx                # 首页（重定向到 /playground）\n    │   └── playground/\n    │       └── page.tsx            # Playground 页面\n    │\n    ├── components/                 # React 组件\n    │   └── playground/\n    │       ├── playground-editor.tsx         # Markdown 编辑器\n    │       ├── playground-preview.tsx        # 内容预览（打字机效果）\n    │       ├── playground-variable-panel.tsx # 变量面板\n    │       └── playground-variable-group-selector.tsx  # 变量组选择器\n    │\n    ├── lib/                        # 工具库\n    │   └── api-client.ts           # API 调用封装\n    │\n    ├── types/                      # TypeScript 类型\n    │   └── index.ts\n    │\n    ├── config/                     # 前端配置\n    │   └── api.ts                  # API 基础 URL 配置\n    │\n    └── hooks/                      # 自定义 Hooks\n        └── use-markdownflow-stream.ts  # 流式数据处理\n```\n!===\n\n\n\n!===\n**关键文件说明**：\n| 文件路径 | 作用 | 在第几章会修改 |\n|---------|------|--------------|\n| `demo/main.py` | FastAPI 应用入口（根目录） | 第 4 章 |\n| `demo/app/core.py` | FastAPI 应用工厂，创建 app 实例，配置 CORS 和中间件 | 第 4 章 |\n| `demo/app/api/v1/playground_api.py` | API 路由层，定义所有 `/api/v1/playground/*` 端点 | 第 4 章 |\n| `demo/app/services/playground_service.py` | 业务逻辑层，纯委托模式（调用 library 层） | 第 4 章 |\n| `demo/app/library/llm/markdownflow_llm_client.py` | 核心逻辑：markdown-flow 库封装，处理流式生成 | 第 4 章 |\n| `demo/app/models/playground_models.py` | Pydantic 数据模型，定义 API 请求/响应格式 | 第 4 章 |\n| `frontend/src/app/playground/page.tsx` | Playground 页面主组件，整合编辑器、预览、变量面板 | 第 5 章 |\n| `frontend/src/components/playground/playground-editor.tsx` | Markdown 编辑器组件，支持语法高亮和实时分析 | 第 5 章 |\n| `frontend/src/components/playground/playground-preview.tsx` | 内容预览组件，使用 markdown-flow-ui 渲染，支持打字机效果 | 第 5 章 |\n| `frontend/src/components/playground/playground-variable-panel.tsx` | 变量面板组件，展示和编辑收集到的变量 | 第 5 章 |\n| `frontend/src/lib/api-client.ts` | API 调用封装，处理 SSE 流式响应 | 第 5 章 |\n| `frontend/src/hooks/use-markdownflow-stream.ts` | 自定义 Hook，管理流式数据和状态 | 第 5 章 |\n| `demo/AGENTS.md` | **最重要的文件**，告诉 AI 如何理解这个项目（1148 行） | 第 3-5 章 |\n!===\n\n**重点目录说明**：\n\n**后端三层架构**：\n- **API 层** (`demo/app/api/v1/`)：薄层，仅处理 HTTP 请求/响应，转发给 Service 层\n- **Service 层** (`demo/app/services/`)：纯委托模式，不包含复杂逻辑，直接调用 Library 层\n- **Library 层** (`demo/app/library/`)：可重用的核心逻辑，`markdownflow_llm_client.py` 是核心，封装了 `markdown-flow` Python 库\n\n**为什么这样设计？**\n- ✅ 关注点分离：API 管路由，Service 管委托，Library 管核心逻辑\n- ✅ 易于测试：Library 层可独立测试，不依赖 FastAPI\n- ✅ 易于复用：Library 层可在其他项目中直接复用\n\n**前端 `frontend/src/components/playground/`**：\n- 所有 Playground 相关组件都在这个目录\n- 组件命名规范：`playground-*.tsx`\n- 核心组件：editor（编辑器）、preview（预览）、variable-panel（变量面板）\n\n**前端 `frontend/src/lib/`**：\n- `api-client.ts`：封装所有 API 调用，处理 SSE 流式响应\n\n**前端 `frontend/src/hooks/`**：\n- `use-markdownflow-stream.ts`：自定义 Hook，管理流式数据接收、状态更新、错误处理\n\n---\n!===\n# 块 4：数据流与 API 设计\n\n最后，让我详细讲解前后端如何通过 API 交互，数据如何流动。\n\n\n## 核心 API 端点\n\n所有 API 都在 `/api/v1/playground` 路径下：\n\n### 1. `POST /api/v1/playground/markdownflow_info`\n**作用**：分析 MarkdownFlow 文档结构，返回变量、块信息\n\n**请求体**：\n```json\n{\n  \"content\": \"?[%{{name}} What's your name?]\\n\\n---\\n\\nHello {{name}}!\",\n  \"variables\": {}\n}\n```\n\n**响应**：\n```json\n{\n  \"blocks\": [\n    {\n      \"index\": 0,\n      \"type\": \"interaction\",\n      \"variables_collected\": [\"name\"]\n    },\n    {\n      \"index\": 1,\n      \"type\": \"content\",\n      \"variables_used\": [\"name\"]\n    }\n  ],\n  \"all_variables\": [\"name\"],\n  \"total_blocks\": 2\n}\n```\n!===\n---\n!===\n### 2. `POST /api/v1/playground/generate`\n**作用**：生成指定块的内容，返回 AI 流式输出\n\n**请求体**：\n```json\n{\n  \"content\": \"?[%{{name}} What's your name?]\\n\\n---\\n\\nHello {{name}}!\",\n  \"block_index\": 1,\n  \"variables\": {\"name\": \"Alice\"},\n  \"llm_config\": {\n    \"provider\": \"openai\",\n    \"model\": \"gpt-4o\",\n    \"api_key\": \"sk-...\",\n    \"base_url\": \"https://api.openai.com/v1\",\n    \"temperature\": 0.7\n  }\n}\n```\n\n**响应**：流式返回（Server-Sent Events）\n```\ndata: {\"type\": \"content\", \"delta\": \"Hello\"}\ndata: {\"type\": \"content\", \"delta\": \" Alice\"}\ndata: {\"type\": \"content\", \"delta\": \"!\"}\ndata: {\"type\": \"done\"}\n```\n\n**流式消息类型**：\n- `content`：内容片段（delta 字段）\n- `interaction`：交互元素（question、options 字段）\n- `variable_collected`：变量收集完成（name、value 字段）\n- `done`：生成完成\n- `error`：发生错误（message 字段）\n!===\n\n---\n!===\n## 数据流详解\n\n让我用一个具体例子，展示数据如何在整个系统中流动。\n\n**场景**：用户在编辑器中输入一个简单的 MarkdownFlow 文档，点击运行。\n\n**MarkdownFlow 文档**：\n```markdown\n?[%{{name}} What's your name?]\n\nHello {{name}}! Nice to meet you.\n```\n\n**数据流步骤**：\n\n1. **前端 → 后端**（用户编辑文档后，自动分析）\n   ```json\n   POST /api/v1/playground/markdownflow_info\n   {\n     \"content\": \"?[%{{name}} What's your name?]\\n\\n---\\n\\nHello {{name}}! Nice to meet you.\",\n     \"variables\": {}\n   }\n   ```\n\n2. **后端解析**（`markdownflow_llm_client.py` 调用 `markdown-flow` 库）\n   - 解析文档，识别出 2 个块\n   - 块 0：交互块，收集变量 `name`\n   - 块 1：内容块，使用变量 `name`\n\n3. **后端 → 前端**（返回文档结构）\n   ```json\n   {\n     \"blocks\": [\n       {\"index\": 0, \"type\": \"interaction\", \"variables_collected\": [\"name\"]},\n       {\"index\": 1, \"type\": \"content\", \"variables_used\": [\"name\"]}\n     ],\n     \"all_variables\": [\"name\"],\n     \"total_blocks\": 2\n   }\n   ```\n\n4. **前端显示**（变量面板）\n   - 显示变量 `name`，值为空\n   - 用户可以手动填入，或通过交互收集\n\n5. **前端 → 后端**（用户点击\"运行块 0\"）\n   ```json\n   POST /api/v1/playground/generate\n   {\n     \"content\": \"...\",\n     \"block_index\": 0,\n     \"variables\": {},\n     \"llm_config\": {...}\n   }\n   ```\n\n6. **后端 → 前端**（流式返回交互提示）\n   ```\n   data: {\"type\": \"interaction\", \"question\": \"What's your name?\", \"variable\": \"name\"}\n   data: {\"type\": \"done\"}\n   ```\n\n7. **用户输入**：\"Alice\"\n\n8. **前端收集变量**\n   - 将 `{\"name\": \"Alice\"}` 存储到变量面板\n\n9. **前端 → 后端**（用户点击\"运行块 1\"）\n   ```json\n   POST /api/v1/playground/generate\n   {\n     \"content\": \"...\",\n     \"block_index\": 1,\n     \"variables\": {\"name\": \"Alice\"},\n     \"llm_config\": {...}\n   }\n   ```\n\n10. **后端处理**\n    - markdown-flow 库替换变量：`Hello {{name}}!` → `Hello Alice!`\n    - 调用 LLM 生成内容（如果需要）\n\n11. **后端 → 前端**（流式返回）\n    ```\n    data: {\"type\": \"content\", \"delta\": \"Hello Alice! Nice to meet you.\"}\n    data: {\"type\": \"done\"}\n    ```\n\n12. **前端渲染**（打字机效果显示）\n    - 用户看到：\"Hello Alice! Nice to meet you.\"\n\n**数据流总结**：\n\n\n```mermaid\ngraph LR\n    A[用户输入] --> B[前端组件]\n    B --> C{需要 AI?}\n    C -->|是| D[发送到后端]\n    C -->|否| E[本地渲染]\n    D --> F[解析 MarkdownFlow]\n    F --> G[调用 LLM]\n    G --> H[流式返回]\n    H --> B\n    B --> I[打字机渲染]\n    I --> J[显示给用户]\n```\n!===\n---\n\n好了，现在你应该对 Demo 项目有了全面的理解：\n- ✅ 知道它能做什么（7 大核心功能）\n- ✅ 知道它用什么技术（前后端技术栈）\n- ✅ 知道代码在哪里（目录结构）\n- ✅ 知道数据怎么流动（API 和序列图）\n\n在下一节，我会教你一个**非常关键的技能**：如何编写 **AGENTS.md**，让 AI 深入理解这个项目，成为你的高效编程助手。\n\n根据你喜欢的讲课风格'''{{sys_user_style}}'''，鼓励 {{sys_user_nickname}} 继续学习。告诉 ta，AGENTS.md 是 Vibe Coding 的核心工具，掌握它，你就掌握了与 AI 协作的钥匙。\n"
    },
    {
      "outline_item_bid": "cd85a52fb3914a83bcdc2276dcbf72c2",
      "title": "AGENTS.md：让 AI 理解你的项目",
      "type": 401,
      "hidden": 0,
      "parent_bid": "bf841234eae84d6dbf0ee3122354e06f",
      "position": "0303",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：什么是 AGENTS.md？\n\n现在你已经理解了 Demo 项目的架构。但有一个问题：**AI 怎么知道这些架构？**\n\n当你用 Cursor 或 Claude Code 问 AI\"帮我添加一个新的 API 端点\"时，AI 如何知道：\n- 应该在哪个文件里写代码？\n- 应该遵循什么代码风格？\n- 应该用什么数据结构？\n- 应该如何测试？\n\n答案就是：**AGENTS.md**。\n---\n!===\n**AGENTS.md 是什么？**\n\nAGENTS.md 是一个专门为 AI 编程助手设计的项目说明文档，它告诉 AI：\n- ✅ 这个项目是做什么的（项目概述）\n- ✅ 用了什么技术（技术栈）\n- ✅ 代码在哪里（目录结构）\n- ✅ 如何修改代码（开发指南）\n- ✅ 应该遵循什么规范（代码规范）\n- ✅ 常见任务如何完成（示例）\n\n**为什么需要 AGENTS.md？**\n\nAI 虽然强大，但它是**无状态**的：\n- ❌ 它不会记住上次对话的内容\n- ❌ 它不知道你的项目结构\n- ❌ 它不知道你的代码风格\n\n每次你打开新的对话，AI 都是\"从零开始\"。如果没有 AGENTS.md，你需要每次都解释：\n- \"我的项目是 Python + React\"\n- \"后端在 backend/ 目录\"\n- \"API 路由在 routes.py\"\n- \"我们用 FastAPI 框架\"\n- ...\n\n有了 AGENTS.md，AI 会**自动读取**这个文件（Cursor 和 Claude Code 都支持），就像给 AI 一份\"项目使用手册\"。\n\n**Demo 项目的 AGENTS.md 示例**（节选关键部分）：\n\n\n```markdown\n# markdown-flow-playground\n\n## 项目概述\n\n这是一个 MarkdownFlow 在线编辑器和 AI 内容生成平台，用户可以：\n- 编写 MarkdownFlow 文档\n- 实时预览 AI 生成的内容\n- 管理变量和交互元素\n- 分享 AI 应用\n\n## 技术栈\n\n**后端**：\n- Python 3.9+\n- FastAPI (异步 Web 框架)\n- MarkdownFlow Agent (Go 版本，通过 subprocess 调用)\n\n**前端**：\n- React 19\n- Next.js 15\n- TypeScript\n- markdown-flow-ui (UI 组件库)\n\n## 目录结构\n\n```\nbackend/\n  app/\n    main.py           # FastAPI 应用入口\n    api/\n      routes.py       # API 路由定义\n    services/\n      markdownflow_service.py  # MarkdownFlow 核心逻辑\n      llm_service.py           # LLM 调用封装\n```\n\n## 核心模块说明\n\n### backend/app/api/routes.py\n\n**作用**：定义所有 API 端点\n\n**主要端点**：\n- `POST /api/process` - 处理 MarkdownFlow 文档，返回 AI 生成的内容\n- `POST /api/validate` - 验证用户输入\n- `POST /api/share` - 生成分享链接\n\n**示例**：添加新端点的代码模板...\n\n## 代码规范\n\n- Python 代码遵循 PEP 8\n- 使用 type hints\n- 函数都要有 docstring\n- API 响应统一用 Pydantic Model\n\n## 常见任务\n\n### 添加新的 API 端点\n\n1. 在 `app/api/models.py` 定义请求/响应模型\n2. 在 `app/api/routes.py` 添加路由\n3. 在 `app/services/` 实现业务逻辑\n4. 在前端 `lib/api.ts` 添加调用函数\n```\n\n\n看到了吗？有了这个文件，AI 就能**快速理解**你的项目，生成的代码会：\n- ✅ 放在正确的文件里\n- ✅ 遵循你的代码风格\n- ✅ 使用正确的技术栈\n- ✅ 符合项目架构\n!===\n---\n!===\n# 块 2：AGENTS.md 文件结构\n\n现在让我详细讲解如何编写一个高质量的 AGENTS.md。\n\n\n## 推荐的文件结构\n\n```markdown\n# 项目名称\n\n## 项目概述\n- 一句话简介\n- 核心功能列表\n- 目标用户\n\n## 技术栈\n- 后端技术\n- 前端技术\n- 数据库/存储\n- 第三方服务\n\n## 目录结构\n- 完整的目录树\n- 关键文件说明\n\n## 核心模块说明\n- 每个核心模块的详细说明\n- 包括：文件路径、作用、关键函数/类、使用示例\n\n## 数据模型\n- 数据库表结构（如果有）\n- API 请求/响应格式\n- 前端状态结构\n\n## API 文档\n- 所有 API 端点列表\n- 每个端点的请求/响应示例\n\n## 代码规范\n- 命名规范\n- 代码风格\n- 注释要求\n- 测试要求\n\n## 开发工作流\n- 如何启动项目\n- 如何添加新功能\n- 如何调试\n- 如何部署\n\n## 常见任务示例\n- 添加新 API 端点\n- 添加新前端组件\n- 修改数据模型\n- 集成第三方服务\n\n## 注意事项\n- 常见陷阱\n- 已知问题\n- 最佳实践\n```\n**每个部分的编写要点**：\n\n### 1. 项目概述\n**目的**：让 AI 快速理解项目是做什么的\n\n**要点**：\n- ✅ 一句话简介（不超过 20 字）\n- ✅ 3-5 个核心功能\n- ✅ 目标用户是谁\n\n**示例**：\n```markdown\n## 项目概述\n\n一个在线 MarkdownFlow 编辑器，用于快速创建 AI 交互式内容。\n\n**核心功能**：\n- 实时编辑和预览 MarkdownFlow 文档\n- 流式 AI 内容生成\n- 交互元素（按钮、文本输入）\n- 变量管理和持久化\n- 分享功能\n\n**目标用户**：内容创作者、教育工作者、AI 应用开发者\n```\n\n\n\n### 2. 技术栈\n**目的**：让 AI 知道应该用什么技术\n\n**要点**：\n- ✅ 列出所有主要技术和版本\n- ✅ 说明为什么选择这些技术\n- ✅ 列出核心依赖包\n\n**示例**：\n```markdown\n## 技术栈\n\n**后端**：\n- Python 3.9+ (AI 生态首选)\n- FastAPI (高性能异步框架)\n- Pydantic (数据验证)\n\n**前端**：\n- React 19 (UI 框架)\n- TypeScript (类型安全)\n- Vite (构建工具)\n\n**关键依赖**：\n- `markdown-flow-ui@^1.0.0` - UI 组件库\n- `remark-flow@^1.0.0` - MarkdownFlow 解析器\n```\n\n\n\n### 3. 核心模块说明\n**目的**：让 AI 知道每个文件的作用\n\n**要点**：\n- ✅ 文件路径\n- ✅ 功能说明\n- ✅ 关键函数/类\n- ✅ 使用示例\n\n**示例**：\n```markdown\n## 核心模块说明\n\n### backend/app/services/llm_service.py\n\n**作用**：封装 LLM API 调用，支持多个 Provider（OpenAI、DeepSeek、Claude）\n\n**关键类**：\n- `LLMService` - LLM 调用的统一接口\n  - `generate_stream(prompt, model, temperature)` - 流式生成\n  - `generate_complete(prompt, model)` - 一次性生成\n\n**使用示例**：\n```python\nfrom app.services.llm_service import LLMService\n\nllm = LLMService()\nasync for chunk in llm.generate_stream(\n    prompt=\"Write a poem\",\n    model=\"deepseek-chat\",\n    temperature=0.7\n):\n    print(chunk)\n```\n\n\n\n### 4. 代码规范\n**目的**：让 AI 生成符合规范的代码\n\n**要点**：\n- ✅ 命名规范\n- ✅ 代码风格\n- ✅ 注释要求\n- ✅ 错误处理\n\n**示例**：\n```markdown\n## 代码规范\n\n**Python**：\n- 遵循 PEP 8\n- 函数名用 `snake_case`\n- 类名用 `PascalCase`\n- 所有函数都要有 type hints 和 docstring\n\n**TypeScript**：\n- 使用 ESLint + Prettier\n- 组件名用 `PascalCase`\n- 函数名用 `camelCase`\n- 所有参数和返回值都要有类型\n\n**错误处理**：\n- 后端用自定义异常类\n- 前端用 try-catch 包裹 API 调用\n```\n\n\n\n### 5. 常见任务示例\n**目的**：让 AI 知道如何完成常见任务\n\n**要点**：\n- ✅ 分步骤说明\n- ✅ 提供代码模板\n- ✅ 指出注意事项\n\n**示例**：\n```markdown\n## 常见任务示例\n\n### 添加新的 API 端点\n\n1. **定义数据模型**（`app/api/models.py`）\n   ```python\n   class NewFeatureRequest(BaseModel):\n       param1: str\n       param2: int\n\n   class NewFeatureResponse(BaseModel):\n       result: str\n   ```\n\n2. **添加路由**（`app/api/routes.py`）\n   ```python\n   @router.post(\"/new-feature\", response_model=NewFeatureResponse)\n   async def new_feature(request: NewFeatureRequest):\n       result = await some_service.process(request)\n       return NewFeatureResponse(result=result)\n   ```\n\n3. **实现业务逻辑**（`app/services/some_service.py`）\n\n4. **前端调用**（`frontend/src/lib/api.ts`）\n   ```typescript\n   export async function callNewFeature(param1: string, param2: number) {\n       const response = await fetch('/api/new-feature', {\n           method: 'POST',\n           body: JSON.stringify({ param1, param2 })\n       });\n       return response.json();\n   }\n   ```\n\n!===\n\n---\n!===\n# 块 3：高质量 AGENTS.md 的三大原则\n\n编写 AGENTS.md 不是简单地罗列信息，而是要让 AI **真正理解**你的项目。以下是三大核心原则：\n\n\n## 原则 1：结构化清晰\n\n**AI 喜欢结构化的信息**，而不是散乱的描述。\n\n**不好的示例**：\n```markdown\n这个项目用 Python 和 React 开发，后端在 backend 目录，\n前端在 frontend 目录，API 有好几个端点，主要是 process 和 validate，\n还有一些工具函数在 utils 里...\n```\n\n**好的示例**：\n\n## 技术栈\n- 后端：Python 3.10 + FastAPI\n- 前端：React 19 + TypeScript\n\n## 目录结构\n```bash\nbackend/\n  app/\n    api/      # API 路由\n    services/ # 业务逻辑\n    utils/    # 工具函数\nfrontend/\n  src/\n    components/ # React 组件\n    lib/        # 工具库\n```\n\n## 核心 API\n- POST /api/process - 处理文档\n- POST /api/validate - 验证输入\n\n**关键点**：\n- ✅ 使用 Markdown 标题层级\n- ✅ 使用列表、表格、代码块\n- ✅ 分段清晰，一段说一件事\n\n\n\n## 原则 2：提供上下文\n\n**不要假设 AI 知道任何背景**，要主动提供上下文。\n\n**不好的示例**：\n\n## API 端点\n\n- /api/process\n- /api/validate\n\n**好的示例**：\n\n## API 端点\n\n### POST /api/process\n**作用**：处理 MarkdownFlow 文档，调用 LLM 生成内容\n\n**请求体**：\n```json\n{\n  \"document\": \"MarkdownFlow 文档内容\",\n  \"blockIndex\": 0,\n  \"variables\": {}\n}\n```\n\n**响应**：Server-Sent Events 流式返回\n\n**何时调用**：用户点击\"运行\"按钮，或块之间导航时\n\n**相关文件**：\n- 后端：`app/api/routes.py:process_document()`\n- 前端：`lib/api.ts:processDocument()`\n\n\n**关键点**：\n- ✅ 说明**为什么**需要这个功能\n- ✅ 说明**何时**使用\n- ✅ 提供**完整的**请求/响应示例\n- ✅ 关联**相关文件**\n\n\n\n## 原则 3：示例驱动\n\n**AI 通过示例学习最快**，提供具体的代码示例比抽象描述有效 100 倍。\n\n**不好的示例**：\n```markdown\n使用 FastAPI 的依赖注入系统来管理服务实例。\n```\n\n**好的示例**：\n```markdown\n### 依赖注入\n\n使用 FastAPI 的 `Depends` 来注入服务实例：\n\n```python\nfrom fastapi import Depends\nfrom app.services.llm_service import LLMService\n\ndef get_llm_service() -> LLMService:\n    return LLMService()\n\n@router.post(\"/generate\")\nasync def generate(\n    prompt: str,\n    llm_service: LLMService = Depends(get_llm_service)\n):\n    result = await llm_service.generate(prompt)\n    return {\"result\": result}\n```\n\n**注意**：不要直接 `llm_service = LLMService()`，这样无法利用 FastAPI 的生命周期管理。\n\n\n**关键点**：\n- ✅ 提供**可直接运行**的代码示例\n- ✅ 用注释解释关键步骤\n- ✅ 指出**常见错误**和**注意事项**\n\n!===\n\n---\n\n# 块 4：收集项目想法 + 过渡到实战\n\n现在你已经理解了 AGENTS.md 的作用和编写方法。在进入第一次 AI 辅助编程之前，我想了解一下你的想法。\n\n**你想开发什么样的 AI 应用？**\n\n这个想法不需要很完整，可以是一个模糊的概念，比如：\n- \"一个帮助我写周报的 AI 助手\"\n- \"一个根据用户性格推荐书籍的应用\"\n- \"一个教小朋友学编程的 AI 老师\"\n- \"一个帮我分析股票的 AI 顾问\"\n\n告诉我你的想法，在第 4-5 章的实战环节，我们可以尝试把它实现出来！\n\n?[%{{project_idea}} ...学完这门课程后，你想开发什么样的 AI 应用？请简单描述（一两句话即可）。]\n\n---\n\n太好了！你想开发的是：'''{{project_idea}}'''。\n\n这是一个很棒的想法！在第 4-5 章，我们会基于 Demo 项目的架构，逐步实现类似的功能。你会学到：\n- 如何设计 MarkdownFlow 文档来收集用户信息\n- 如何设计 Prompt 让 LLM 生成高质量内容\n- 如何用 Python 实现后端逻辑\n- 如何用 React 实现前端交互\n\n现在，让我们进入最激动人心的环节：**第一次 AI 辅助编程实战**！\n\n在下一节，你会：\n1. 用 Cursor 或 Claude Code 修改 Demo 项目的一个小功能\n2. 体验完整的 Vibe Coding 流程\n3. 学会如何写出高质量的 Prompt\n4. 理解如何审查 AI 生成的代码\n\n根据你的背景'''{{sys_user_background}}'''和编程经验'''{{programming_experience}}'''，我会选择合适难度的实战任务。\n\n用你喜欢的讲课风格'''{{sys_user_style}}'''，鼓励 {{sys_user_nickname}} 继续下一节。告诉 ta，这是从\"理解概念\"到\"动手实践\"的关键转折点，完成这一节后，ta 就真正掌握了 Vibe Coding 的精髓！\n"
    },
    {
      "outline_item_bid": "150776fadf6d4afead7e83da3d5c8615",
      "title": "第一次 Vibe Coding 实战：添加一个小功能",
      "type": 401,
      "hidden": 0,
      "parent_bid": "bf841234eae84d6dbf0ee3122354e06f",
      "position": "0304",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1：实战任务说明\n\n欢迎来到第三章的最后一节，{{sys_user_nickname}}！\n\n现在是时候真正动手了。在这一节，你会完成**第一次 AI 辅助编程**，亲身体验 Vibe Coding 的完整流程。\n\n根据你的编程经验'''{{programming_experience}}'''，我为你选择了一个合适难度的实战任务。\n---\n!===\n## 实战任务\n\n**任务目标**：用 Cursor 或 Claude Code 修改 Demo 项目的欢迎语\n\n**具体要求**：\n1. 修改首页的欢迎文案，加入你的个性化内容\n2. 在欢迎语中添加一个\"快速开始\"按钮\n3. 点击按钮后，自动加载一个示例 MarkdownFlow 文档\n\n**难度**：⭐⭐（入门级）\n\n**涉及文件**：\n- `frontend/src/pages/index.tsx` - 首页组件\n- `frontend/src/components/Welcome.tsx` - 欢迎组件（如果有）\n\n**预计时间**：15-20 分钟\n\n\n**如果你是零基础**：\n不用担心！我会手把手带你完成每一步。你只需要：\n- 安装 Cursor（或使用已安装的 Claude Code）\n- 跟随我的指引，复制粘贴 Prompt\n- 观察 AI 如何生成代码\n- 测试功能是否正常\n\n**如果你有编程经验**：\n这个任务对你来说可能比较简单，重点是**学习 Prompt 设计技巧**：\n- 如何清晰表达意图\n- 如何提供足够的上下文\n- 如何引导 AI 生成高质量代码\n- 如何迭代优化\n!===\n\n---\n!===\n# 块 2：Prompt 设计实战\n\n在开始动手之前，让我先教你如何设计一个**高质量的 Prompt**。这是 Vibe Coding 的核心技能。\n\n\n## 好的 Prompt 的 5 个要素\n\n### 1. **背景（Context）**\n告诉 AI 项目的基本信息和当前状态。\n\n**示例**：\n```\n我正在开发一个 MarkdownFlow 在线编辑器，使用 React 19 + TypeScript。\n首页在 src/pages/index.tsx，目前有一个简单的欢迎文案。\n```\n\n\n\n### 2. **目标（Goal）**\n清晰说明你要做什么。\n\n**示例**：\n```\n我想修改首页的欢迎文案，让它更有吸引力，并添加一个\"快速开始\"按钮。\n```\n!===\n---\n!===\n### 3. **约束（Constraints）**\n说明需要遵守的规则或限制。\n\n**示例**：\n```\n要求：\n- 保持现有的代码风格（使用 Tailwind CSS）\n- 欢迎文案不超过 50 字\n- 按钮要使用项目已有的 Button 组件\n- 不要修改其他功能\n```\n\n\n### 4. **示例（Examples）**\n提供具体的例子或参考。\n\n**示例**：\n```markdown\n欢迎文案参考：\n\"欢迎使用 MarkdownFlow Playground！用自然语言控制 AI 输出，创建个性化的交互式内容。\"\n\n按钮点击后，加载以下示例文档：\n?[%{{name}} What's your name?]\n---\nHello {{name}}!\n```\n!===\n---\n!===\n### 5. **验收标准（Acceptance Criteria）**\n说明如何判断任务完成。\n\n**示例**：\n```\n验收标准：\n- 首页显示新的欢迎文案\n- 有一个明显的\"快速开始\"按钮\n- 点击按钮后，编辑器自动加载示例文档\n- 不影响其他功能\n```\n!===\n\n---\n!===\n## Prompt 对比：不好 vs 好\n\n让我用具体例子对比一下不好的 Prompt 和好的 Prompt。\n\n\n### 不好的 Prompt ❌\n\n```\n帮我改一下首页\n```\n\n**问题**：\n- ❌ 没有说明要改什么\n- ❌ 没有提供项目信息\n- ❌ AI 不知道从何下手\n\n\n\n### 稍好的 Prompt ⚠️\n\n```\n我想在首页加一个按钮\n```\n\n**问题**：\n- ⚠️ 有了目标，但太简单\n- ❌ 没有说明按钮做什么\n- ❌ 没有说明按钮的样式和位置\n\n\n\n### 好的 Prompt ✅\n\n```\n我正在开发一个 React + TypeScript 项目，首页在 src/pages/index.tsx。\n\n请帮我：\n1. 在首页顶部添加一个欢迎文案：\"欢迎使用 MarkdownFlow Playground！用自然语言控制 AI 输出，创建个性化的交互式内容。\"\n2. 在欢迎文案下方添加一个\"快速开始\"按钮\n3. 点击按钮后，调用 setDocument() 函数加载示例文档\n\n要求：\n- 使用 Tailwind CSS 样式\n- 按钮颜色用蓝色（bg-blue-500）\n- 示例文档内容：\n  ?[%{{name}} What's your name?]\n  ---\n  Hello {{name}}!\n\n请只修改 index.tsx，不要改其他文件。\n```\n\n**优点**：\n- ✅ 提供了项目背景\n- ✅ 目标清晰具体\n- ✅ 有明确的约束和要求\n- ✅ 提供了示例内容\n- ✅ 说明了验收标准\n!===\n\n---\n!===\n# 块 3：与 AI 协作的完整流程\n\n现在，让我带你走一遍完整的 AI 辅助编程流程。\n\n\n## 流程总览\n\n```mermaid\ngraph TD\n    A[1. 阅读 AGENTS.md<br/>理解项目上下文] --> B[2. 定位要修改的文件]\n    B --> C[3. 编写 Prompt<br/>描述修改意图]\n    C --> D[4. 让 AI 生成代码]\n    D --> E{5. 审查代码}\n    E -->|不满意| F[6. 调整 Prompt<br/>继续对话]\n    E -->|满意| G[7. 应用代码]\n    G --> H[8. 测试验证]\n    H -->|有问题| F\n    H -->|通过| I[9. 完成任务]\n    F --> D\n\n    style A fill:#e1f5ff\n    style I fill:#d4edda\n```\n!===\n---\n\n!===\n## 步骤详解\n\n### 步骤 1：阅读 AGENTS.md，理解项目上下文\n\n**操作**：\n1. 打开项目根目录的 `AGENTS.md`\n2. 快速浏览以下部分：\n   - 项目概述（了解项目是做什么的）\n   - 技术栈（知道用了什么技术）\n   - 目录结构（知道代码在哪里）\n   - 代码规范（知道应该遵循什么风格）\n\n**时间**：2-3 分钟\n\n**目的**：让你的大脑和 AI 的大脑\"同步\"，知道项目的全貌。\n\n\n\n### 步骤 2：定位要修改的文件\n\n**操作**：\n1. 根据任务需求，找到需要修改的文件\n2. 打开文件，快速浏览代码结构\n\n**技巧**：\n- 如果不确定文件在哪里，问 AI：\"首页组件在哪个文件里？\"\n- AI 会根据 AGENTS.md 告诉你准确的路径\n\n**本次任务**：\n- 文件：`frontend/src/pages/index.tsx`\n\n\n\n### 步骤 3：编写 Prompt，描述修改意图\n\n**操作**：\n1. 打开 Cursor/Claude Code 的聊天窗口\n2. 按照\"5 个要素\"编写 Prompt\n3. 附上当前文件的代码（让 AI 看到现状）\n\n**本次任务的 Prompt**：\n\n\n我正在修改 markdown-flow-playground 项目的首页（src/pages/index.tsx）。\n\n当前首页有一个基础的布局，包括编辑器、预览区、变量面板。\n\n请帮我在页面顶部添加一个欢迎区域：\n\n1. 欢迎文案：\n   \"欢迎来到 MarkdownFlow Playground！\n   用自然语言控制 AI 输出，轻松创建个性化的交互式内容。\"\n\n2. 一个\"快速开始\"按钮：\n   - 使用 Tailwind CSS\n   - 蓝色背景（bg-blue-500 hover:bg-blue-600）\n   - 白色文字\n   - 圆角（rounded-lg）\n   - 点击后加载示例文档\n\n3. 示例文档内容：\n   ```markdown\n   ?[%{{name}} What's your name?]\n\n   ---\n\n   Hello {{name}}! Welcome to MarkdownFlow Playground.\n   ```\n\n要求：\n- 欢迎区域在页面最顶部\n- 使用 flexbox 布局，居中对齐\n- 不影响现有的编辑器、预览区等功能\n- 保持代码风格一致\n\n请给出完整的修改后的代码。\n\n!===\n---\n!===\n### 步骤 4：让 AI 生成代码\n\n**操作**：\n1. 发送 Prompt\n2. 等待 AI 生成代码（通常 10-30 秒）\n\n**AI 会做什么**：\n- 读取 AGENTS.md（自动）\n- 理解你的需求\n- 生成符合项目规范的代码\n- 给出修改说明\n\n\n### 步骤 5：审查代码\n\n**重要**：永远不要盲目接受 AI 生成的代码！\n\n**审查清单**：\n- [ ] 代码是否放在了正确的位置？\n- [ ] 是否遵循了项目的代码风格？\n- [ ] 是否正确使用了框架和库？\n- [ ] 是否有明显的 bug？\n- [ ] 是否理解了每一行代码的作用？\n\n**如果不理解某段代码**：\n- 直接问 AI：\"这段代码是做什么的？\"\n- AI 会给出详细解释\n\n### 步骤 6：调整 Prompt，继续对话（如果需要）\n\n**常见调整场景**：\n\n**场景 1**：样式不满意\n```\n按钮太小了，能不能改大一点？padding 改成 px-6 py-3\n```\n\n**场景 2**：功能不对\n```\n点击按钮后没有加载文档，能检查一下 setDocument 函数的调用吗？\n```\n\n**场景 3**：想要改进\n```\n能不能在按钮旁边加一个\"查看文档\"链接？链接到 MarkdownFlow 官网\n```\n\n**关键点**：\n- ✅ 保持对话连续性，AI 会记住之前的上下文\n- ✅ 每次只改一个小地方\n- ✅ 逐步迭代到满意\n\n!===\n---\n!===\n\n### 步骤 7：应用代码\n\n**操作**：\n1. 复制 AI 生成的代码\n2. 粘贴到对应文件\n3. 保存\n\n**Cursor/Claude Code 提示**：\n- Cursor 可以直接点击\"Apply\"按钮\n- Claude Code 可以点击\"Insert\"\n\n\n### 步骤 8：测试验证\n\n**操作**：\n1. 确保开发服务器正在运行（`npm run dev`）\n2. 在浏览器中打开 http://localhost:3000\n3. 检查：\n   - 欢迎文案是否正确显示？\n   - 按钮是否显示？\n   - 点击按钮后，编辑器是否加载了示例文档？\n   - 其他功能是否正常？\n\n**如果有问题**：\n- 回到步骤 6，告诉 AI 具体的问题\n- 让 AI 修复\n\n\n\n### 步骤 9：完成任务\n\n**操作**：\n1. 确认所有功能正常\n2. 可选：添加 git commit\n3. 庆祝 🎉\n\n**反思**：\n- 这次 AI 辅助编程用了多长时间？\n- 哪里最顺利？哪里遇到了困难？\n- 如果重新做一次，Prompt 可以怎么改进？\n!===\n\n---\n!===\n# 块 4：常见问题与解决方案\n\n在第一次 AI 辅助编程中，你可能会遇到一些问题。这里列出了最常见的 4 个问题和解决方案。\n\n\n## 问题 1：AI 生成的代码不符合预期\n\n**表现**：\n- AI 生成的代码功能不对\n- 或者理解错了你的意图\n\n**原因**：\n- Prompt 描述不够清晰\n- 没有提供足够的上下文\n\n**解决方案**：\n1. **不要重新发送 Prompt**，而是继续对话\n2. 指出具体的问题：\n   ```\n   你生成的代码有个问题：按钮点击后没有加载文档。\n\n   我期望的行为是：点击按钮后，调用 setDocument(exampleDoc) 函数。\n\n   请修复这个问题。\n   ```\n3. 如果还是不对，提供更多细节或示例\n\n**真实案例**：\n```markdown\n用户：帮我在首页加一个按钮\n\nAI：[生成了一个没有任何功能的按钮]\n\n用户：这个按钮点击后没有反应，我希望点击后加载示例文档。\n      示例文档内容是：?[%{{name}} What's your name?]\n\nAI：[修复代码，添加 onClick 处理函数]\n```\n\n\n\n## 问题 2：AI 修改了不该修改的地方\n\n**表现**：\n- AI 改了其他无关的代码\n- 或者删除了重要的功能\n\n**原因**：\n- Prompt 没有明确限定范围\n- AI 过度优化\n\n**解决方案**：\n1. 在 Prompt 中明确说明：\n   ```\n   请只修改欢迎区域的代码，不要改动编辑器、预览区、变量面板等其他部分。\n   ```\n2. 如果 AI 已经改了，告诉它恢复：\n   ```\n   你改了太多地方，我只需要修改顶部的欢迎区域。\n   请保持其他代码不变，只添加欢迎区域的 JSX。\n   ```\n\n\n## 问题 3：不知道从哪里开始\n\n**表现**：\n- 看着项目代码一头雾水\n- 不知道要修改哪个文件\n\n**解决方案**：\n1. **先问 AI**：\n   ```\n   我想修改首页的欢迎文案，应该修改哪个文件？\n   ```\n2. **读 AGENTS.md**：\n   - 查看\"目录结构\"部分\n   - 查看\"核心模块说明\"部分\n3. **用 Cursor 的搜索功能**：\n   - 搜索关键词（如\"Welcome\"、\"首页\"）\n   - 找到对应的文件\n\n\n## 问题 4：AI 生成的代码看不懂\n\n**表现**：\n- 代码能运行，但不理解原理\n- 担心有隐藏的 bug\n\n**解决方案**：\n1. **问 AI 解释**：\n   ```\n   这段代码我不太理解：\n   [粘贴代码]\n\n   能逐行解释一下吗？特别是 useCallback 和 useMemo 的作用。\n   ```\n2. **要求简化**：\n   ```\n   这段代码太复杂了，能写得更简单一点吗？\n   我是初学者，希望代码容易理解。\n   ```\n3. **对比学习**：\n   ```\n   能给我两个版本的代码吗？\n   - 版本 1：最简单的实现（容易理解）\n   - 版本 2：优化后的实现（性能更好）\n\n   我想看看两者的区别。\n   ```\n\n**记住**：理解代码是你的责任，不要盲目接受你看不懂的代码。\n!===\n\n---\n\n# 块 5：第三章总结与第四章预告\n\n恭喜你，{{sys_user_nickname}}！你已经完成了第三章的全部内容，并且完成了第一次 AI 辅助编程实战！\n\n让我们回顾一下第三章的收获：\n\n\n## 第三章收获清单\n\n**理论部分**：\n- ✅ 理解了 Vibe Coding 的核心理念：人类设计 + AI 实现 + 人类验证\n- ✅ 掌握了 Vibe Coding 的三大原则：\n  1. 描述意图而非细节\n  2. 迭代优化而非一次完美\n  3. 保持主导，AI 是助手\n- ✅ 理解了传统开发 vs Vibe Coding 的本质区别\n\n**项目理解**：\n- ✅ 熟悉了 Demo 项目的 7 大核心功能\n- ✅ 理解了前后端技术栈和选择原因\n- ✅ 掌握了完整的目录结构和关键文件作用\n- ✅ 理解了前后端数据流和 API 设计\n\n**实战技能**：\n- ✅ 学会了编写高质量 AGENTS.md 的三大原则\n- ✅ 掌握了 Prompt 设计的 5 个要素\n- ✅ 完成了第一次 AI 辅助编程实战\n- ✅ 体验了完整的 Vibe Coding 流程（9 个步骤）\n\n**个人规划**：\n- ✅ 明确了自己想开发的 AI 应用：{{project_idea}}\n\n\n**你现在的能力**：\n\n根据你对 Vibe Coding 的理解'''{{vibe_understanding}}'''和你的编程经验'''{{programming_experience}}'''，你现在已经具备了：\n- 与 AI 高效协作的能力\n- 理解项目架构的能力\n- 独立完成小功能开发的能力\n\n**下一步**：\n\n在第四章《AI 应用后端开发实战（Python + MarkdownFlow）》中，你会：\n\n1. **深入 MarkdownFlow 语法**\n   - 6 种交互类型的详细用法\n   - 变量系统的高级技巧\n   - 保留内容和块分隔符\n\n2. **后端开发核心技能**\n   - 用 Python + FastAPI 开发 API\n   - 集成 MarkdownFlow Agent\n   - 实现流式响应（SSE）\n   - 处理变量管理和验证\n\n3. **LLM 集成实战**\n   - 设计高质量 Prompt\n   - 处理流式输出\n   - 错误处理和重试机制\n\n4. **实战项目**\n   - 基于 Demo 项目添加新功能\n   - 或者开始实现你的想法：{{project_idea}}\n\n**学习建议**：\n\n结合你喜欢的讲课风格'''{{sys_user_style}}'''，给你以下建议：\n\n- **如果你是零基础**：第四章会涉及更多的代码，建议你提前复习一下 Python 基础（变量、函数、类）。不用担心，我会配合大量示例和 AI 辅助，确保你能跟上。\n\n- **如果你有编程基础**：第四章是你大显身手的时候！重点放在理解 MarkdownFlow 的设计思想和 LLM 集成的最佳实践上。\n\n- **如果你想开发自己的项目**：第四章学完后，你就可以开始实现'''{{project_idea}}'''的后端部分了！\n\n**最后的鼓励**：\n\n用你喜欢的讲课风格'''{{sys_user_style}}'''，热烈祝贺 {{sys_user_nickname}} 完成第三章！\n\n你已经从\"理解概念\"跨越到了\"动手实战\"，这是一个巨大的进步。第四章会更具挑战性，但也更有成就感。相信我，当你亲手用 Python 实现一个 AI API，看到它在浏览器中流式输出内容时，那种成就感是无与伦比的！\n\n准备好了吗？让我们开始第四章的旅程！🚀\n"
    },
    {
      "outline_item_bid": "f15259aee98b4f82bb6dc16af6ee87fd",
      "title": "后端架构全景分析",
      "type": 401,
      "hidden": 0,
      "parent_bid": "ec716ba63dad4e618178f02675c0c3bb",
      "position": "0401",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 从第三章到第四章 - 进入后端世界\n\n欢迎来到第四章,{{sys_user_nickname}}!\n\n在第三章,你已经了解了 Demo 项目的整体架构,掌握了 Vibe Coding 的核心理念:**人类设计 + AI 实现 + 人类验证**。现在,我们要深入后端开发,学习如何用 AI 构建一个真正可运行的后端应用。\n\n但在开始之前,我要先明确一个重要转变:**第四章的学习重点不是 Python 或 FastAPI**。\n\n你可能会想:\"学后端开发不就是学写 Python 代码吗?\" 过去确实如此,但在 Vibe Coding 时代,**学习重点发生了根本性转变**:\n\n!===\n| 传统后端学习 | Vibe Coding 后端学习 |\n|-------------|---------------------|\n| 记住 Python 语法 | **理解系统架构**（知道如何设计） |\n| 记住 FastAPI 装饰器 | **精通 MarkdownFlow 语法**（核心技能） |\n| 学会调试 bug | **学会描述需求给 AI**（Prompt 模板） |\n| 学会写单元测试 | **学会审查 AI 生成的代码**（检查清单） |\n!===\n\n**为什么会有这样的转变?**\n\n因为在 Vibe Coding 模式下,**Python 代码可以让 AI 帮你写,但 MarkdownFlow 语法和架构设计思维必须你自己掌握**。这就像开车:你需要理解交通规则和路线规划(架构设计),但具体的引擎运转细节(代码实现)可以交给汽车本身(AI)。\n\n结合你的背景'''{{sys_user_background}}''',这意味着:\n- 如果你是**编程新手**:不用担心记不住 Python 语法,AI 会帮你生成代码\n- 如果你是**有经验的开发者**:可以专注于架构设计和业务逻辑,让 AI 处理重复性编码工作\n\n**所以,第四章你真正要掌握的是**:\n1. **理解后端架构**(15% 时间) - 知道系统如何工作\n2. **精通 MarkdownFlow 语法**(40% 时间) - 这是必须掌握的核心技能\n3. **学会用 AI 构建后端**(30% 时间) - 用 Prompt 模板描述需求,用检查清单审查代码\n4. **完成实战任务**(15% 时间) - 动手实践,巩固所学\n\n准备好了吗?让我们从理解\"什么是 API\"开始。\n\n---\n\n# 块 2: 什么是 API?为什么需要前后端分离?\n\n**先用生活类比帮你理解 API**:\n\n想象你去餐厅吃饭:\n- **你**(前端):想吃红烧肉,但不会做菜\n- **服务员**(API):记录你的需求,传达给厨房\n- **厨房**(后端):根据菜谱做好红烧肉\n- **服务员**(API):把菜端给你\n\n这个过程中,**你不需要知道厨房在哪里,厨师是谁,怎么做菜** - 你只需要告诉服务员你想吃什么,剩下的交给餐厅系统处理。\n\n!===\n**技术翻译**:\n```\n用户浏览器（前端）\n    ↓ HTTP 请求（\"我要红烧肉\"）\nAPI 接口（后端入口,像服务员）\n    ↓ 调用\n业务逻辑（后端,像厨房）\n    ↓ 调用\nLLM / 数据库（外部服务,像食材库）\n    ↑ 返回结果（\"红烧肉做好了\"）\n用户浏览器（展示结果）\n```\n!===\n\n**为什么需要前后端分离?**\n\n让我举个例子,假设你要开发一个\"智能学习助手\":\n\n!===\n**不分离的问题**（传统方式）:\n- 网页版:写一套代码（HTML + JavaScript + Python 混在一起）\n- 手机 App 版:又要写一套代码（iOS Swift + Python）\n- 微信小程序版:再写一套代码（小程序 + Python）\n→ **重复劳动,难以维护**\n\n**分离后的优势**（现代方式）:\n- 后端 API:只写一套 Python 代码,提供 `/chat` `/history` 等接口\n- 前端（网页 / App / 小程序）:分别调用同一套 API\n→ **一次开发,多端复用**\n!===\n\n**前后端分离的 4 大好处**:\n\n1. **职责清晰**:前端专注\"好看\"(用户界面),后端专注\"好用\"(业务逻辑)\n2. **复用性强**:一个后端 API 可以服务多个前端(网页、手机 App、小程序)\n3. **安全性好**:敏感信息(API Key、数据库密码)放在后端,用户看不到\n4. **易于扩展**:前后端可以独立开发、独立部署,互不影响\n\n结合你的学习目标'''{{learning_goal}}''',理解前后端分离能让你:\n- 构建**可扩展的 AI 应用**,而不是只能在网页上运行的 demo\n- 保护**API Key 安全**,避免被恶意用户盗用\n- 为未来的**多端部署**打下基础\n\n---\n\n# 块 3: Demo 项目的完整数据流\n\n现在让我们看看 Demo 项目中,**用户点击\"生成\"按钮后,背后发生了什么**。\n\n这是一个**完整的数据流图**,不用死记,理解即可:\n\n!===\n```bash\n┌─────────────┐\n│ 用户浏览器   │\n│（React 前端）│\n└──────┬──────┘\n       │ 1. 点击\"生成\"按钮，发送请求\n       │    POST /api/v1/playground/generate\n       │    { content: \"你好{{name}}\", variables: {name: \"张三\"} }\n       ↓\n┌─────────────────────────────────────┐\n│ FastAPI 后端                         │\n│                                     │\n│  ┌──────────────────────────────┐  │\n│  │ API 层（app/api/v1/）        │  │ 2. 接收请求\n│  │ - playground.py              │  │    验证参数、提取数据\n│  │   /playground/generate       │  │\n│  └────────┬─────────────────────┘  │\n│           │                         │\n│           ↓                         │\n│  ┌──────────────────────────────┐  │\n│  │ Service 层（app/services/）  │  │ 3. 调用 MarkdownFlow\n│  │ - playground.py              │  │    生成内容（纯委托）\n│  │   PlaygroundService          │  │\n│  └────────┬─────────────────────┘  │\n│           │                         │\n│           ↓                         │\n│  ┌──────────────────────────────┐  │\n│  │ Library 层（app/library/）   │  │ 4. 与 LLM 通信\n│  │ - llmclient.py               │  │    调用 OpenAI API\n│  │ - llm_provider.py            │  │\n│  └────────┬─────────────────────┘  │\n└───────────┼─────────────────────────┘\n            │\n            ↓\n     ┌──────────────┐\n     │ LLM API      │ 5. 调用大模型\n     │（OpenAI 等） │    生成\"你好张三\"\n     └──────┬───────┘\n            │ 6. 返回流式结果（SSE）\n            │    data: {\"type\": \"content\", \"content\": \"你好\"}\n            │    data: {\"type\": \"content\", \"content\": \"张三\"}\n            ↓\n     【通过 SSE 逐块返回给前端】\n            ↓\n     ┌──────────────┐\n     │ 前端实时渲染  │ 7. 打字机效果显示\n     │ \"你好张三\"    │    用户看到内容逐字出现\n     └──────────────┘\n```\n!===\n\n**关键概念解释**:\n\n**1. SSE（Server-Sent Events）**\n- **作用**:服务器主动推送数据给浏览器,实现流式输出\n- **类比**:像直播一样,数据生成一点,就立刻传给前端一点,而不是等全部生成完再返回\n- **好处**:用户体验好,看到\"打字机效果\",不会觉得卡顿\n\n**2. 三层架构**（API → Service → Library）\n- **API 层**:负责接收请求、验证参数、返回响应（不实现具体逻辑）\n- **Service 层**:负责调用 MarkdownFlow 库（纯委托模式,也不实现具体逻辑）\n- **Library 层**:负责与 LLM 通信（真正的业务逻辑在这里）\n\n**3. 纯委托模式**\n- **意思**:Service 层不实现具体逻辑,只是调用 markdown-flow 库\n- **好处**:代码简洁,逻辑清晰,易于维护\n\n**理解程度检查**:如果你能回答以下问题,说明理解到位了:\n- Q:为什么需要三层架构,不直接在 API 层调用 LLM?\n- A:分层后职责清晰,代码易于维护和扩展\n\n---\n!===\n# 块 4: Demo 项目的核心文件与 API 端点\n\n**Demo 项目目录结构**（⭐ 标记的是你需要关注的核心文件）:\n\n\n```\ndemo/backend/\n├── main.py                     # 应用入口（26 行）\n├── requirements.txt            # Python 依赖（75 行）\n├── AGENTS.md                   # ⭐ Vibe Coding 指南（1148 行）\n└── app/                        # 核心应用目录\n    ├── core.py                 # FastAPI 应用工厂\n    ├── api/v1/                 # ⭐ API 路由层\n    │   └── playground.py       # 4 个 API 端点\n    ├── services/               # ⭐ 业务逻辑层\n    │   └── playground.py       # PlaygroundService（纯委托）\n    ├── models/                 # 数据模型层\n    │   └── playground.py       # Pydantic 模型\n    ├── library/                # ⭐ 可重用库\n    │   ├── llmclient.py        # LLM 客户端\n    │   └── llm_provider.py     # MarkdownFlow 适配器\n    ├── middleware/             # 中间件（CORS 等）\n    ├── utils/                  # 工具函数\n    └── config/                 # 配置管理\n```\n\n\n**你需要关注的核心文件**（⭐ 标记）:\n1. **AGENTS.md**:告诉 AI 如何理解这个项目（Vibe Coding 的关键）\n2. **app/api/v1/playground.py**:API 端点定义\n3. **app/services/playground.py**:调用 MarkdownFlow 的地方\n4. **app/library/**:LLM 通信层\n\n**你不需要深入理解的文件**:\n- 中间件、工具函数、配置管理（这些 AI 会帮你处理）\n!===\n---\n!===\n**Demo 项目的 4 个 API 端点**:\n\n\n| 端点 | 方法 | 功能 | 使用场景 |\n|------|------|------|---------|\n| `GET /health` | GET | 健康检查 | 确认后端是否正常运行 |\n| `POST /api/v1/playground/generate` | POST | 流式生成内容（SSE） | ⭐ 核心功能：实时生成内容 |\n| `POST /api/v1/playground/markdownflow_info` | POST | 获取文档结构信息 | 提取变量、块信息 |\n| `POST /api/v1/playground/generate-complete` | POST | 非流式完整生成 | 预留功能：一次性返回结果 |\n\n!===\n\n---\n\n!===\n**核心端点详解**: `/api/v1/playground/generate`\n\n**作用**:接收 MarkdownFlow 内容和参数,调用 LLM 流式生成结果\n\n**请求示例**:\n\n```json\n{\n  \"content\": \"你好 {{name}}!\\n\\n?[%{{city}} 北京|上海|深圳]\\n\\n---\\n\\n欢迎来到'''{{city}}'''!\",\n  \"block_index\": 0,\n  \"variables\": {\"name\": \"张三\"},\n  \"user_input\": null\n}\n```\n\n\n**响应**: SSE 流（分块返回）\n\n```\ndata: {\"type\": \"content\", \"content\": \"你好 \"}\ndata: {\"type\": \"content\", \"content\": \"张三\"}\ndata: {\"type\": \"interaction\", \"variable\": \"city\", \"options\": [\"北京\", \"上海\", \"深圳\"]}\ndata: {\"type\": \"done\"}\n```\n!===\n---\n!===\n\n**重要提醒**:\n- ✅ **理解即可**:知道请求/响应的大致格式\n- ❌ **不需要记住**:具体的字段名称、错误处理、流式输出实现（AI 会帮你生成）\n- 🎯 **真正要做的**:学会如何向 AI 描述\"我想要一个流式生成的 API 端点\"（这在 4.3 节详细讲解）\n!===\n---\n!===\n**4.1 小结**:\n\n你现在应该理解了:\n- ✅ 什么是 API,为什么需要前后端分离\n- ✅ Demo 项目的完整数据流(7 个步骤)\n- ✅ Demo 项目的目录结构和核心文件\n- ✅ 4 个 API 端点的作用\n\n但你**不需要记住**:\n- ❌ 具体的代码实现细节\n- ❌ SSE 的底层原理\n- ❌ FastAPI 的装饰器语法\n\n接下来,我们进入第四章最重要的部分:**MarkdownFlow 语法深度掌握**。这是你必须精通的核心技能,我们将用 40% 的时间深入学习。\n!==="
    },
    {
      "outline_item_bid": "775b0f05a75345348d95f09c6ab689b0",
      "title": "用AI构建前端界面",
      "type": 401,
      "hidden": 0,
      "parent_bid": "0bc85fd1cd3a43a18c2cdc704910b505",
      "position": "0503",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: Vibe Coding 工作流 - 你不需要手写所有代码\n\n{{sys_user_nickname}},现在我们进入第五章的核心实战部分:**用 AI 构建前端界面**。\n\n首先,我要再次强调 Vibe Coding 的核心理念:**你不需要手写所有前端代码,你需要学会如何让 AI 帮你写**。\n\n传统的前端开发教程会教你:\n- ❌ React Hooks 的各种用法\n- ❌ TypeScript 类型定义的细节\n- ❌ CSS 样式的所有属性\n- ❌ 事件处理的各种模式\n\n但在 Vibe Coding 模式下,你真正需要学会的是:\n- ✅ **描述 UI 需求** - 如何清晰地告诉 AI 你想要什么样的界面\n- ✅ **理解关键部分** - AI 生成的代码中哪些是你需要理解的\n- ✅ **审查代码质量** - 用检查清单验证 AI 生成的代码是否符合要求\n- ✅ **测试与迭代** - 如何快速验证功能,并让 AI 优化\n\n**Vibe Coding 工作流**（与第 4 章一致）:\n!===\n```\n1. 描述需求（你负责）\n   ↓\n2. AI 生成代码（AI 负责）\n   ↓\n3. 理解关键部分（你负责）\n   ↓\n4. 测试验证（你负责）\n   ↓\n5. 迭代优化（你 + AI 协作）\n```\n!===\n\n结合你的编程经验'''{{programming_experience}}''',这意味着:\n- 如果你是**前端新手**:完全不用担心,AI 会生成所有 React 代码,你只需要理解关键部分\n- 如果你是**有经验的前端开发者**:可以专注于 UI 设计和用户体验,让 AI 处理重复性编码\n\n本节内容:\n- **如何向 AI 描述 UI 需求**（Prompt 模板）\n- **AI Prompt 模板库**（理解代码、调试错误、样式调整、性能优化、动画效果）\n- **代码审查清单**（组件层级、状态管理、事件处理、组件库使用、样式响应式）\n- **测试与调试工作流**\n- **实战案例**:用 AI 添加主题切换功能\n\n---\n\n# 块 2: 如何向 AI 描述 UI 需求 - 清晰、具体、提供上下文\n\n**向 AI 描述 UI 需求的三个原则**（与第 4 章一致）:\n1. **清晰** - 明确说明界面效果、交互行为\n2. **具体** - 提供示例、边界条件、样式要求\n3. **提供上下文** - 告诉 AI 参考哪些现有代码,保持风格一致\n\n**模板 1: 添加新组件**\n\n!===\n```\n我需要在 Demo 项目中添加一个\"复制\"按钮。\n\n需求:\n1. 位置: MarkdownFlow 内容渲染区的右上角\n2. 功能: 点击后复制当前显示的内容到剪贴板\n3. 样式: 圆形按钮,灰色背景,鼠标悬停时变深\n4. 反馈: 复制成功后显示提示\"已复制!\"(2 秒后消失)\n\n参考:\n- 使用 markdown-flow-ui 的样式规范\n- 参考 Demo 项目现有的按钮样式\n- 使用浏览器的 navigator.clipboard API\n\n请给出完整实现,包括:\n1. 组件代码\n2. 样式定义\n3. 复制逻辑\n4. 提示显示逻辑\n```\n!===\n\n**AI 会生成代码,你需要理解的关键部分**:\n!===\n```tsx\n// 你需要理解的部分:\nconst [copied, setCopied] = useState(false);  // ← 状态管理\n\nconst handleCopy = async () => {\n  await navigator.clipboard.writeText(content);  // ← 复制逻辑\n  setCopied(true);  // ← 显示提示\n  setTimeout(() => setCopied(false), 2000);  // ← 2 秒后隐藏\n};\n\nreturn (\n  <button onClick={handleCopy}>  {/* ← 事件处理 */}\n    {copied ? '已复制!' : '复制'}\n  </button>\n);\n```\n!===\n\n**你不需要记住的部分**:\n- ❌ `useState` 的底层原理\n- ❌ `navigator.clipboard` 的所有方法\n- ❌ CSS 样式的具体写法\n\n**模板 2: 修改现有功能**\n\n!===\n```\n修改 MarkdownFlow 组件的打字机效果,\n增加\"暂停/继续\"功能。\n\n需求:\n1. 添加一个\"暂停\"按钮,点击后暂停打字机效果\n2. 暂停时按钮文字变为\"继续\"\n3. 再次点击恢复打字机效果\n4. 按钮位置在右上角,样式与\"跳过\"按钮一致\n\n参考:\n- 查看 markdown-flow-ui 的 isFinished 属性\n- 使用 useState 管理暂停状态\n```\n!===\n\n**模板 3: 样式调整**\n\n!===\n```\n调整 Demo 项目的整体配色,从蓝色主题改为绿色主题。\n\n需求:\n1. 主色调: #10b981 (绿色)\n2. 悬停色: #059669 (深绿)\n3. 背景色: #f0fdf4 (浅绿)\n4. 需要修改的元素: 按钮、链接、交互面板边框\n\n参考:\n- 使用 CSS 变量统一管理颜色\n- 保持与现有样式的一致性\n\n请给出需要修改的 CSS 变量定义。\n```\n!===\n\n**好的需求描述 vs 不好的需求描述对比**:\n\n!===\n| **不好的描述** | **好的描述** | **说明** |\n|--------------|------------|---------|\n| \"添加一个按钮\" | \"添加复制按钮,位置在右上角,点击复制内容\" | 具体说明功能和位置 |\n| \"改成绿色\" | \"主色调改为 #10b981,包括按钮、链接、边框\" | 明确颜色值和影响范围 |\n| \"参考现有代码\" | \"参考 Demo 项目的 EditPanel 组件样式\" | 具体指出参考哪个文件 |\n!===\n\n---\n\n# 块 3: AI Prompt 模板库 - 5 个高频场景（增强版）\n\n**场景 1: 理解现有代码**\n\n!===\n```\nPrompt: \"解释 Demo 项目中 MarkdownFlow 组件的使用方式,\n重点说明:\n1. initialContentList 如何传入\n2. onSend 回调如何处理用户交互\n3. 打字机效果如何配置\n请用简单的语言解释,我是前端新手。\"\n```\n!===\n\n**场景 2: 调试错误**\n\n!===\n```\nPrompt: \"我在使用 MarkdownFlow 组件时遇到错误:\nTypeError: Cannot read property 'map' of undefined\n\n相关代码:\n[粘贴报错的代码]\n\n浏览器控制台显示:\n[粘贴控制台错误信息]\n\n请帮我:\n1. 定位错误原因\n2. 提供修复方案\n3. 解释为什么会出现这个错误\"\n```\n!===\n\n**场景 3: 样式调整**\n\n!===\n```\nPrompt: \"我需要调整 MarkdownFlow 内容区的样式。\n\n当前问题:\n- 内容过宽,超出容器\n- 代码块没有背景色\n- 标题字体太小\n\n期望效果:\n- 内容宽度最大 800px\n- 代码块灰色背景,圆角 4px\n- 标题字体大小增加 20%\n\n请给出修改后的 CSS 代码。\"\n```\n!===\n\n**场景 4: 性能优化**\n\n!===\n```\nPrompt: \"我的 MarkdownFlow 组件在长文本场景下渲染很慢。\n\n当前实现:\n[粘贴代码]\n\n性能问题:\n- 打字机效果卡顿\n- 页面滚动不流畅\n\n请帮我:\n1. 分析可能的性能瓶颈\n2. 提供优化建议\n3. 给出优化后的代码示例\"\n```\n!===\n\n**场景 5: 添加动画效果**（新增）\n\n!===\n```\nPrompt: \"我想为交互按钮添加点击动画效果。\n\n需求:\n1. 点击时按钮缩小到 95%\n2. 松开时恢复到 100%\n3. 动画时长 150ms\n4. 使用缓动函数 ease-out\n\n请给出 CSS 动画代码,使用 Tailwind CSS 实现。\"\n```\n!===\n\n**Prompt 模板使用技巧**:\n\n!===\n| 技巧 | 说明 | 示例 |\n|------|------|------|\n| **具体化** | 明确说明期望效果的每个细节 | \"按钮宽度 120px,高度 40px\" |\n| **提供上下文** | 告诉 AI 参考哪些文件 | \"参考 `EditPanel.tsx` 的样式\" |\n| **分步骤** | 把复杂任务拆分为步骤 | \"1. 添加状态 2. 添加按钮 3. 绑定事件\" |\n| **给示例** | 提供预期效果的示例 | \"效果类似于 GitHub 的代码高亮\" |\n!===\n\n---\n\n# 块 4: 代码审查清单 - 确保 AI 生成的代码符合要求\n\n**当 AI 生成代码后,你需要检查以下几点**:\n\n**检查清单 1: 组件层级是否合理?**\n\n!===\n```tsx\n// ✅ 检查嵌套层级\n<Container>\n  <MarkdownFlow>  {/* ← 核心组件在合理位置 */}\n    <InteractionPanel />\n  </MarkdownFlow>\n</Container>\n\n// ❌ 避免过深嵌套\n<div><div><div><div><MarkdownFlow /></div></div></div></div>\n```\n!===\n\n**检查清单 2: 状态管理是否正确?**\n\n!===\n```tsx\n// ✅ 状态在合适的组件中\nconst [variables, setVariables] = useState({});  // ← 父组件管理共享状态\n\n// ✅ 状态更新正确\nsetVariables(prev => ({ ...prev, city: 'Beijing' }));  // ← 使用函数更新\n\n// ❌ 错误的状态更新\nvariables.city = 'Beijing';  // ← 直接修改 state,错误!\n```\n!===\n\n**检查清单 3: 事件处理是否正确?**\n\n!===\n```tsx\n// ✅ 正确的事件处理\n<button onClick={handleClick}>点击</button>\n\n// ✅ 带参数的事件处理\n<button onClick={() => handleClick(param)}>点击</button>\n\n// ❌ 错误:直接调用函数\n<button onClick={handleClick()}>点击</button>  // ← 会立即执行!\n```\n!===\n\n**检查清单 4: 组件库使用是否正确?**\n\n!===\n```tsx\n// ✅ 正确使用 MarkdownFlow\n<MarkdownFlow\n  initialContentList={contentList}  // ← 数组格式\n  enableTypewriter={true}\n  onSend={handleSend}\n/>\n\n// ❌ 错误:传入字符串\n<MarkdownFlow initialContentList={content} />  // ← 应该是数组\n```\n!===\n\n**检查清单 5: 样式和响应式是否正确?**\n\n!===\n```tsx\n// ✅ 响应式设计\n<div className=\"w-full max-w-4xl mx-auto\">  {/* ← 最大宽度限制 */}\n  <MarkdownFlow />\n</div>\n\n// ✅ 移动端适配\n<div className=\"px-4 md:px-8 lg:px-16\">  {/* ← 不同屏幕不同间距 */}\n\n// ❌ 固定宽度,不响应式\n<div style={{ width: '1200px' }}>  // ← 小屏幕会溢出\n```\n!===\n\n**完整的代码审查清单**:\n\n!===\n- [ ] 组件层级是否清晰合理?\n- [ ] 状态管理是否正确?\n- [ ] 事件处理是否正确绑定?\n- [ ] markdown-flow-ui 组件使用是否正确?\n- [ ] 样式是否响应式?\n- [ ] 是否有错误处理?\n- [ ] 是否有加载状态提示?\n- [ ] 是否符合 Demo 项目的代码风格?\n!===\n\n---\n\n# 块 5: 测试与调试工作流 - 快速验证功能\n\n**步骤 1: 使用浏览器开发者工具**\n\n!===\n```bash\n# Chrome DevTools 快捷键\n- 打开控制台: Cmd/Ctrl + Option/Alt + J\n- 打开元素面板: Cmd/Ctrl + Option/Alt + I\n- 查看网络请求: Network 标签\n\n# 常用调试技巧:\n1. Console 查看日志和错误\n2. Elements 检查 DOM 结构和样式\n3. Network 查看 API 请求\n4. React DevTools 查看组件状态\n```\n!===\n\n**步骤 2: 使用 React DevTools**\n\n!===\n```\n安装 React DevTools:\n- Chrome: 搜索 \"React Developer Tools\" 扩展\n\n使用方法:\n1. 打开 DevTools,切换到 \"Components\" 标签\n2. 选择组件,查看 Props 和 State\n3. 修改 State 实时查看效果\n4. 查看组件层级关系\n```\n!===\n\n**步骤 3: 让 AI 帮助定位问题**\n\n!===\n```\nPrompt: \"我的 MarkdownFlow 组件渲染后,打字机效果没有显示。\n\n浏览器控制台没有错误。\n\n我的代码:\n[粘贴代码]\n\n我的 props:\ninitialContentList: [...]\nenableTypewriter: true\ntypingSpeed: 30\n\n请帮我定位问题并提供解决方案。\"\n```\n!===\n\n**常见问题调试指南**:\n\n!===\n| 问题 | 可能原因 | 解决方案 |\n|------|---------|---------|\n| 组件不显示 | contentList 为空或格式错误 | 检查 console.log(contentList) |\n| 打字机不工作 | enableTypewriter 未设置 | 显式设置 `enableTypewriter={true}` |\n| 交互无反应 | onSend 未实现或有错误 | 检查 onSend 回调逻辑 |\n| 样式不生效 | CSS 类名错误或优先级低 | 使用 !important 或检查类名 |\n| API 调用失败 | 后端未启动或 URL 错误 | 检查 Network 标签 |\n!===\n\n**调试技巧总结**:\n\n!===\n1. **先看控制台** - 大多数错误会显示在 Console\n2. **用 React DevTools** - 查看组件的 Props 和 State\n3. **检查网络请求** - Network 标签查看 API 调用\n4. **添加 console.log** - 在关键位置打印变量值\n5. **让 AI 帮忙** - 把错误信息和代码粘贴给 AI\n!===\n\n---\n\n# 块 6: 实战案例 - 用 AI 添加主题切换功能\n\n**需求**: 添加深色/浅色主题切换功能\n\n**Step 1: 向 AI 描述需求**\n\n!===\n```\n我想在 Demo 项目中添加主题切换功能。\n\n需求:\n1. 添加一个主题切换按钮(太阳/月亮图标)\n2. 支持两种主题:浅色主题(默认)、深色主题\n3. 点击按钮切换主题\n4. 主题选择保存到 localStorage,刷新页面保持\n5. 深色主题配色:\n   - 背景: #1f2937\n   - 文字: #f9fafb\n   - 主色: #3b82f6\n\n实现步骤:\n1. 使用 useState 管理主题状态\n2. 使用 useEffect 从 localStorage 读取保存的主题\n3. 切换主题时更新 CSS 变量\n4. 保存主题到 localStorage\n\n请参考 Demo 项目的代码风格,给出完整实现。\n```\n!===\n\n**Step 2: AI 生成代码**\n\n（AI 会生成代码,你需要复制到对应位置）\n\n**Step 3: 理解关键部分**\n\n!===\n```tsx\n// 你需要理解的关键部分:\n\n// 1. 主题状态管理\nconst [theme, setTheme] = useState<'light' | 'dark'>('light');\n\n// 2. 从 localStorage 读取主题\nuseEffect(() => {\n  const savedTheme = localStorage.getItem('theme') as 'light' | 'dark';\n  if (savedTheme) {\n    setTheme(savedTheme);\n  }\n}, []);\n\n// 3. 切换主题并保存\nconst toggleTheme = () => {\n  const newTheme = theme === 'light' ? 'dark' : 'light';\n  setTheme(newTheme);\n  localStorage.setItem('theme', newTheme);  // ← 保存到本地\n};\n\n// 4. 应用主题(修改 CSS 变量)\nuseEffect(() => {\n  document.documentElement.setAttribute('data-theme', theme);\n}, [theme]);\n```\n!===\n\n**Step 4: 测试验证**\n\n!===\n```bash\n# 在浏览器中测试:\n1. 点击主题切换按钮,查看颜色是否改变\n2. 刷新页面,查看主题是否保持\n3. 打开 Application 标签 → LocalStorage,查看是否保存了 theme\n4. 使用 React DevTools 查看 theme 状态\n```\n!===\n\n**Step 5: 迭代优化**\n\n如果基本功能可以工作,你可以让 AI 帮你改进:\n\n!===\n```\nPrompt: \"主题切换功能可以工作,但我想改进:\n1. 添加切换动画(fade 效果,300ms)\n2. 按钮位置改为右上角固定\n3. 添加悬停提示\"切换到深色模式\"\n4. 使用图标库(如 lucide-react)的太阳/月亮图标\n\n请修改代码。\"\n```\n!===\n\n**检查清单**:\n!===\n- [ ] 主题切换按钮是否显示?\n- [ ] 点击按钮是否切换主题?\n- [ ] 刷新页面主题是否保持?\n- [ ] localStorage 是否保存了主题?\n- [ ] 深色主题的配色是否正确?\n- [ ] 是否有切换动画?\n!===\n\n---\n\n# 块 7: 小结 - 你现在学会了什么?\n\n**你现在应该学会了**:\n\n✅ **Vibe Coding 工作流**\n- 描述需求 → AI 生成 → 理解关键部分 → 测试 → 迭代\n- 专注于\"如何描述 UI 需求\"而非\"如何写代码\"\n\n✅ **如何向 AI 描述 UI 需求**\n- 清晰、具体、提供上下文\n- 模板 1: 添加新组件\n- 模板 2: 修改现有功能\n- 模板 3: 样式调整\n\n✅ **AI Prompt 模板库**\n- 场景 1: 理解现有代码\n- 场景 2: 调试错误\n- 场景 3: 样式调整\n- 场景 4: 性能优化\n- 场景 5: 添加动画效果\n\n✅ **代码审查清单**\n- 组件层级是否合理?\n- 状态管理是否正确?\n- 事件处理是否正确?\n- 组件库使用是否正确?\n- 样式和响应式是否正确?\n\n✅ **测试与调试工作流**\n- Chrome DevTools 使用\n- React DevTools 使用\n- 让 AI 帮助定位问题\n\n✅ **实战案例**\n- 完整流程:描述需求 → AI 生成 → 理解 → 测试 → 迭代\n- 主题切换功能实现\n\n**你不需要记住**:\n- ❌ React Hooks 的所有用法细节\n- ❌ TypeScript 类型定义细节\n- ❌ CSS 属性的所有可能值\n- ❌ localStorage API 的所有方法\n\n**接下来**,我们进入第五章的最后一部分:**Demo 项目实战**。你将完成三个渐进式任务,巩固所学内容,其中最后一个任务将基于你的项目想法'''{{project_idea}}'''。\n"
    },
    {
      "outline_item_bid": "8d3dbf94ec1443ca930a37ba690d4f07",
      "title": "进阶学习路径",
      "type": 401,
      "hidden": 0,
      "parent_bid": "7e10d317f3b444cabdfd70aa0e3e7a2c",
      "position": "0604",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 下一步计划\n\n恭喜你，{{sys_user_nickname}}！完成了《借助 Vibe Coding 开发 AI 应用》的全部学习。\n\n从第一章的环境配置，到第六章的项目部署，你已经掌握了 AI 应用开发的完整技能栈：\n\n!===\n✅ **Vibe Coding 工作流** - 人类设计 + AI 实现 + 人类验证\n✅ **MarkdownFlow 语法** - 用自然语言控制 AI 输出\n✅ **后端开发** - FastAPI + SSE 流式输出\n✅ **前端开发** - React + Next.js + markdown-flow-ui\n✅ **项目部署** - Docker + 云服务器 + Vercel\n!===\n\n现在，是时候规划你的下一步了。\n\n**学完这门课程后,你的下一步计划是什么？**\n\n?[%{{next_step}}继续深入 MarkdownFlow|开发自己的 AI 项目|探索其他 AI 框架|加入开源社区贡献代码|暂时先消化吸收]\n\n---\n\n# 块 2: 个性化进阶路径推荐\n\n根据你的选择'''{{next_step}}'''，这里为你推荐个性化的进阶学习路径。\n\n## 路径 1：继续深入 MarkdownFlow\n\n如果你选择\"继续深入 MarkdownFlow\"，说明你对 MarkdownFlow 非常感兴趣，想成为 MarkdownFlow 专家。\n\n!===\n**学习路线图**：\n\n**阶段 1：高级特性**（1-2 周）\n- **多轮对话管理**：\n  - 如何保持对话上下文\n  - 如何实现\"记住用户偏好\"\n  - 参考：`markdown-flow-agent-py` 中的 `context_manager.py`\n- **条件分支**：\n  - 根据变量值生成不同内容\n  - 示例：`if {{programming_experience}} == \"零基础\" then ... else ...`\n- **自定义交互组件**：\n  - 扩展 `markdown-flow-ui` 组件\n  - 实现滑块、日期选择器等\n\n**阶段 2：复杂场景实战**（2-3 周）\n- **多步骤工作流**：\n  - 设计包含 10+ 步的复杂流程\n  - 示例：在线课程（收集信息 → 生成学习计划 → 每日打卡 → 结业认证）\n- **集成外部服务**：\n  - 数据库（PostgreSQL、MongoDB）\n  - 支付（Stripe、微信支付）\n  - 第三方 API（天气、翻译、地图）\n- **多语言支持**：\n  - i18n 国际化\n  - 动态切换语言\n\n**阶段 3：性能优化**（1 周）\n- **流式输出优化**：\n  - 减少首字延迟\n  - 优化 SSE 连接\n- **缓存策略**：\n  - LLM 响应缓存\n  - 变量缓存\n- **并发处理**：\n  - 异步生成多个内容块\n!===\n\n**学习资源**：\n\n!===\n**官方文档**：\n- MarkdownFlow 官网：https://markdownflow.ai\n- GitHub 仓库：\n  - Python 版本：https://github.com/ai-shifu/markdown-flow-agent-py\n  - UI 组件库：https://github.com/ai-shifu/markdown-flow-ui\n  - 解析器：https://github.com/ai-shifu/remark-flow\n\n**示例项目**：\n- Playground（本课程的 Demo 项目）\n- AI 学习助手（扣子平台示例）\n- 职业规划助手（Dify 平台示例）\n\n!===\n\n## 路径 2：开发自己的 AI 项目\n\n如果你选择\"开发自己的 AI 项目\"，说明你想把所学知识应用到实际项目中。\n\n结合你的项目想法'''{{project_idea}}'''，这里给你一些具体建议：\n\n!===\n**开发路线图**（MVP → 迭代 → 上线）：\n\n**第 1 周：MVP（最小可行产品）**\n- **目标**：用最少的功能验证核心价值\n- **步骤**：\n  1. 用 AI 帮你设计架构：\n     ```\n     Prompt: 我想开发一个 [项目描述]，请帮我设计后端 API 和前端界面。\n     技术栈：Python + FastAPI + React + MarkdownFlow\n     ```\n  2. 基于 Demo 项目改造（不要从零开始）\n  3. 只实现核心功能（1-2 个场景）\n  4. 本地测试，验证可行性\n\n**第 2-3 周：迭代优化**\n- **目标**：完善功能，优化用户体验\n- **步骤**：\n  1. 收集用户反馈（朋友、同学试用）\n  2. 用 AI 帮你优化：\n     - 添加新功能\n     - 优化 UI 样式\n     - 修复 Bug\n  3. 用第 6.2 章的检查清单审查代码\n\n**第 4 周：部署上线**\n- **目标**：让项目可访问\n- **步骤**：\n  1. 用第 6.3 章的部署方案部署\n  2. 购买域名（可选）\n  3. 分享给用户\n\n**持续运营**：\n- 定期更新功能\n- 收集用户反馈\n- 用 AI 协助快速迭代\n!===\n\n**技术选型建议**：\n\n!===\n| 需求 | MarkdownFlow | LangChain | AutoGPT |\n|------|-------------|-----------|---------|\n| **交互式内容生成** | ✅ 最佳选择 | ❌ 不适合 | ❌ 不适合 |\n| **复杂工作流编排** | ⚠️ 可以但复杂 | ✅ 最佳选择 | ✅ 最佳选择 |\n| **知识库问答** | ⚠️ 需要自己实现 | ✅ 内置 Vector Store | ✅ 内置检索 |\n| **Agent 自主决策** | ❌ 不支持 | ✅ 支持 | ✅ 最佳选择 |\n| **学习成本** | ⭐ 低（本课程已掌握） | ⭐⭐⭐ 中高 | ⭐⭐⭐⭐ 高 |\n!===\n\n**选择建议**：\n- 如果你的项目核心是\"**个性化内容生成**\"（如在线课程、咨询助手），选 **MarkdownFlow**\n- 如果你的项目核心是\"**知识库问答**\"（如企业客服、文档助手），选 **LangChain**\n- 如果你的项目核心是\"**自主决策**\"（如自动化任务、AI Agent），选 **AutoGPT**\n\n## 路径 3：探索其他 AI 框架\n\n如果你选择\"探索其他 AI 框架\"，说明你想拓展 AI 开发的技能树。\n\n!===\n**推荐学习顺序**（从易到难）：\n\n**1. LangChain**（⭐⭐⭐ 推荐优先学习）\n- **适用场景**：知识库问答、文档助手、企业客服\n- **核心概念**：\n  - Chains（链式调用）\n  - Agents（自主决策）\n  - Vector Stores（向量数据库）\n  - Memory（对话记忆）\n- **学习资源**：\n  - 官方文档：https://python.langchain.com\n  - 中文教程：https://www.langchain.asia\n  - 推荐课程：《LangChain 实战》\n- **学习时间**：2-3 周\n\n**2. LlamaIndex**（⭐⭐ 适合知识库场景）\n- **适用场景**：文档检索、知识图谱、RAG（检索增强生成）\n- **核心概念**：\n  - Index（索引）\n  - Query Engine（查询引擎）\n  - Retriever（检索器）\n- **学习资源**：\n  - 官方文档：https://docs.llamaindex.ai\n  - GitHub：https://github.com/run-llama/llama_index\n- **学习时间**：1-2 周\n\n**3. Semantic Kernel**（⭐⭐ 微软官方框架）\n- **适用场景**：企业应用、微软生态集成\n- **核心概念**：\n  - Skills（技能）\n  - Planners（规划器）\n  - Memory（记忆）\n- **学习资源**：\n  - 官方文档：https://learn.microsoft.com/semantic-kernel\n  - GitHub：https://github.com/microsoft/semantic-kernel\n- **学习时间**：1-2 周\n\n**4. AutoGPT / BabyAGI**（⭐⭐⭐⭐ 高级，自主 Agent）\n- **适用场景**：自动化任务、AI Agent、自主决策\n- **核心概念**：\n  - 目标分解\n  - 自主规划\n  - 工具调用\n- **学习资源**：\n  - AutoGPT：https://github.com/Significant-Gravitas/AutoGPT\n  - BabyAGI：https://github.com/yoheinakajima/babyagi\n- **学习时间**：3-4 周\n!===\n\n**学习建议**：\n- 不要同时学多个框架，逐个攻破\n- 每学一个框架，做一个小项目巩固\n- 用 AI 辅助学习（询问 AI 框架的核心概念和最佳实践）\n\n## 路径 4：加入开源社区贡献代码\n\n如果你选择\"加入开源社区贡献代码\"，说明你想回馈社区，成为开源贡献者。\n\n!===\n**贡献方式**（从易到难）：\n\n**1. 报告 Bug**（⭐ 最简单）\n- **步骤**：\n  1. 在使用 MarkdownFlow 时遇到问题\n  2. 访问 GitHub Issues\n  3. 用模板提交 Bug 报告：\n     ```markdown\n     **问题描述**：[简短描述]\n     **复现步骤**：[1. 2. 3.]\n     **期望行为**：[应该怎样]\n     **实际行为**：[实际怎样]\n     **环境**：[Python 版本、操作系统]\n     ```\n- **价值**：帮助项目改进\n\n**2. 改进文档**（⭐⭐ 容易上手）\n- **步骤**：\n  1. 发现文档的错误或不清楚的地方\n  2. Fork 项目到自己的 GitHub\n  3. 修改 Markdown 文档\n  4. 提交 Pull Request\n- **价值**：降低新用户学习成本\n\n**3. 添加示例**（⭐⭐ 实用）\n- **步骤**：\n  1. 用 MarkdownFlow 开发一个有趣的示例\n  2. 提交到 `examples/` 目录\n  3. 添加 README 说明用法\n- **价值**：为其他开发者提供参考\n\n**4. 修复 Bug**（⭐⭐⭐ 有挑战）\n- **步骤**：\n  1. 在 GitHub Issues 找标记为 `good first issue` 的 Bug\n  2. 阅读代码，理解问题原因\n  3. 用 AI 协助修复：\n     ```\n     Prompt: 这段代码有个 Bug：[粘贴代码]\n     错误信息：[粘贴错误]\n     请帮我分析原因并提供修复方案。\n     ```\n  4. 提交 Pull Request\n- **价值**：直接改进项目质量\n\n**5. 开发新功能**（⭐⭐⭐⭐ 高级）\n- **步骤**：\n  1. 在 GitHub Discussions 提议新功能\n  2. 与维护者讨论设计方案\n  3. 开发功能（用 AI 协助）\n  4. 提交 Pull Request\n- **价值**：为项目增加新能力\n!===\n\n**Pull Request 流程**：\n\n!===\n**步骤**：\n1. Fork 项目到自己的 GitHub\n2. Clone 到本地：\n   ```bash\n   git clone https://github.com/your-username/markdown-flow-agent-py.git\n   ```\n3. 创建新分支：\n   ```bash\n   git checkout -b fix-typo-in-readme\n   ```\n4. 修改代码\n5. 提交：\n   ```bash\n   git add .\n   git commit -m \"Fix typo in README\"\n   git push origin fix-typo-in-readme\n   ```\n6. 在 GitHub 上创建 Pull Request\n7. 等待维护者 Review\n8. 根据反馈修改\n9. 合并！\n\n**最佳实践**：\n- ✅ 提交前先测试\n- ✅ 遵循项目的代码规范\n- ✅ Pull Request 描述清晰\n- ✅ 回复维护者的 Review 意见\n!===\n\n**MarkdownFlow 社区资源**：\n- **GitHub 仓库**：https://github.com/ai-shifu/markdown-flow-agent-py\n\n## 路径 5：暂时先消化吸收\n\n如果你选择\"暂时先消化吸收\"，说明你需要时间巩固所学知识。\n\n!===\n**复习建议**：\n\n**第 1 周：重点章节回顾**\n- **第 4.2 章**：MarkdownFlow 语法深度掌握\n  - 重新阅读所有语法示例\n  - 尝试自己编写一个简单的 MarkdownFlow 内容\n- **第 5.2 章**：markdown-flow-ui 组件库使用\n  - 重新阅读组件 API\n  - 尝试修改 Demo 项目的样式\n\n**第 2-3 周：实战练习**\n- 基于 Demo 项目完成 **10 个小任务**（见下面列表）\n- 每个任务预计 30-60 分钟\n- 全部用 AI 协助完成\n\n**第 4 周：总结与分享**\n- 写一篇学习总结（博客/公众号）\n- 分享你的学习心得（朋友圈）\n- 鼓励朋友也来学习 Vibe Coding\n!===\n\n**10 个实战小任务**（渐进式难度）：\n\n!===\n**后端任务**（第 4 章）：\n1. ⭐ 修改欢迎消息的文案\n2. ⭐ 添加一个新的系统级变量（如 `sys_user_email`）\n3. ⭐⭐ 添加一个新的 API 端点（如 `/health` 健康检查）\n4. ⭐⭐ 集成天气 API（显示实时天气）\n5. ⭐⭐⭐ 实现对话历史记录（保存到数据库）\n\n**前端任务**（第 5 章）：\n6. ⭐ 修改主题颜色（Primary Color）\n7. ⭐ 添加一个\"返回顶部\"按钮\n8. ⭐⭐ 实现深色模式切换\n9. ⭐⭐ 添加\"导出对话\"功能（导出为 Markdown）\n10. ⭐⭐⭐ 实现\"语音输入\"功能（Web Speech API）\n!===\n\n---\n\n# 块 3: 学习资源推荐\n\n无论你选择哪条进阶路径，这里推荐一些通用学习资源。\n\n## 官方资源\n\n!===\n**MarkdownFlow 官方**：\n- 官网：https://markdownflow.ai\n- 文档：https://docs.markdownflow.ai\n- GitHub（Python 版本）：https://github.com/ai-shifu/markdown-flow-agent-py\n- GitHub（UI 组件库）：https://github.com/ai-shifu/markdown-flow-ui\n- GitHub（解析器）：https://github.com/ai-shifu/remark-flow\n!===\n\n\n\n\n\n---\n\n# 块 4: 结业认证与获取帮助\n\n## 结业要求\n\n完成以下清单，即可获得课程结业认证：\n\n!===\n**结业清单**：\n- [ ] 完成第 1-5 章所有实战任务\n  - [ ] 第 3.4 章：第一次 AI 辅助编程\n  - [ ] 第 4.4 章：三个后端实战任务\n  - [ ] 第 5.4 章：三个前端实战任务\n- [ ] 基于 Demo 项目完成一个自定义功能\n  - 示例：添加\"导出对话\"、\"深色模式\"、\"语音输入\"等\n- [ ] 提交项目截图或 GitHub 链接\n  - 发送到：（讲师邮箱/社区提交链接）\n!===\n\n**结业认证**：\n- 获得电子证书（PDF）\n- 加入校友群（持续交流）\n- 优先参与进阶课程内测\n\n## 进阶挑战（可选）\n\n如果你想挑战更高难度，可以尝试这些进阶任务：\n\n!===\n**挑战 1：实现多语言支持**（⭐⭐⭐）\n- **目标**：让 Demo 项目支持中英文切换\n- **技术点**：i18n、语言检测、动态翻译\n- **预计时间**：4-6 小时\n\n**挑战 2：接入第三方 API**（⭐⭐⭐）\n- **目标**：集成天气 API、翻译 API、地图 API 等\n- **技术点**：API 调用、错误处理、数据缓存\n- **预计时间**：3-5 小时\n\n**挑战 3：优化打字机效果性能**（⭐⭐⭐⭐）\n- **目标**：减少首字延迟，提升流畅度\n- **技术点**：SSE 优化、前端渲染优化、缓存策略\n- **预计时间**：6-8 小时\n\n**挑战 4：实现对话历史记录**（⭐⭐⭐⭐）\n- **目标**：保存用户对话到数据库，支持查看历史\n- **技术点**：数据库设计、API 设计、前端列表渲染\n- **预计时间**：8-10 小时\n\n**挑战 5：开发一个完整的 AI 应用**（⭐⭐⭐⭐⭐）\n- **目标**：基于'''{{project_idea}}'''开发完整应用并上线\n- **技术点**：全栈开发、部署、运营\n- **预计时间**：2-4 周\n!===\n\n## 获取帮助\n\n遇到问题时，按以下顺序寻求帮助：\n\n!===\n**1. 查阅文档**（优先推荐）\n- 本课程内容（第 1-6 章）\n- MarkdownFlow 官方文档\n- FastAPI 官方文档\n- Next.js 官方文档\n\n**2. 搜索已有问题**\n- GitHub Issues：搜索是否有人遇到同样的问题\n\n**3. 询问 AI**\n- 用 ChatGPT、Claude、Cursor 等\n- 提供完整上下文（代码 + 错误信息）\n\n!===\n\n## 常见问题 FAQ\n\n!===\n**Q1：课程内容会过时吗？**\nA：MarkdownFlow 语法相对稳定，核心概念不会变。框架细节（FastAPI、React）可能更新，但用 AI 协助可以快速适应新版本。\n\n**Q2：没有编程基础能学会吗？**\nA：能！本课程设计时考虑了零基础学员，强调\"理解架构 > 记住语法\"。用 Vibe Coding 模式，AI 会帮你生成代码并讲解。\n\n**Q3：学完后能找到工作吗？**\nA：这门课程教的是 AI 应用开发技能，适合：\n- 转型 AI 开发的工程师\n- 想提升效率的开发者\n- 想开发 AI 产品的创业者\n具体就业情况取决于个人背景和市场需求。\n\n**Q4：Demo 项目可以商用吗？**\nA：可以！Demo 项目采用 MIT 开源协议，可以自由使用、修改、商用。\n\n!===\n\n## 结业寄语\n\n{{sys_user_nickname}}，祝贺你完成了这门课程！\n\n回想起你在第一章填写的学习目标'''{{learning_goal}}'''，现在的你，已经拥有了用 AI 开发应用的能力。\n\n你的反馈'''{{course_feedback}}'''对我们非常重要，感谢你的分享。\n\n**记住**：\n- ✅ **Vibe Coding 不是\"不学代码\"，而是\"学会与 AI 协作\"**\n- ✅ **AI 是工具，不是替代品** - 人类负责设计，AI 负责实现\n- ✅ **持续学习** - AI 技术日新月异，保持好奇心\n\n**未来的你，可以**：\n- 用 2 小时开发一个 AI 应用原型\n- 用 AI 快速学习新框架、新技术\n- 用 MarkdownFlow 构建个性化内容生成系统\n- 成为 AI 应用开发的专家\n\n**这不是结束，而是新的开始。**\n\n期待看到你开发的 AI 应用！\n\n\n再见，{{sys_user_nickname}}！祝你在 AI 应用开发的道路上越走越远！ 🚀\n"
    },
    {
      "outline_item_bid": "1f14b2129cce49f98de46fadd842c9d5",
      "title": "项目部署与发布",
      "type": 401,
      "hidden": 0,
      "parent_bid": "7e10d317f3b444cabdfd70aa0e3e7a2c",
      "position": "0603",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 部署全景 - 从本地到生产\n\n恭喜'''{{sys_user_nickname}}'''完成了 Demo 项目的开发！现在让我们把项目部署到生产环境，让其他人也能访问你的 AI 应用。\n\n**部署流程全景**：\n\n!===\n```\n本地开发（localhost:3000 / localhost:8000）\n    ↓\nDocker 容器化（打包环境 + 依赖）\n    ↓\n云服务器部署（阿里云 / 腾讯云 / 华为云）\n    ↓\n域名配置 + HTTPS（让用户通过域名访问）\n    ↓\n生产环境（yourapp.com）\n```\n!===\n\n**国内主流部署方式对比**：\n\n!===\n| 方式 | 优势 | 劣势 | 适用场景 | 成本 |\n|------|------|------|---------|------|\n| **云服务器**<br>（阿里云/腾讯云） | 完全控制<br>性能稳定 | 需要运维知识<br>配置复杂 | 生产环境<br>正式项目 | ¥60-300/月 |\n| **学生机**<br>（阿里云/腾讯云） | 超低价格<br>适合学习 | 配置较低<br>有使用期限 | 学习练习<br>小型项目 | ¥9.9/月起 |\n| **容器平台**<br>（Docker） | 环境一致性<br>易于迁移 | 学习成本高<br>资源开销大 | 微服务<br>团队协作 | 按服务器计费 |\n!===\n\n**推荐方案**（基于 Demo 项目，面向大学生）：\n\n!===\n**完整方案**：阿里云/腾讯云学生机 + Docker + Nginx\n\n**为什么选择学生机**：\n- ✅ **超低价格**：¥9.9/月起（学生认证后）\n- ✅ **完整体验**：和生产环境一样的完整部署流程\n- ✅ **学习价值**：掌握云服务器、Docker、Nginx 等核心技能\n- ✅ **可用于简历**：实际可访问的项目，面试加分\n\n**成本估算**（学生方案）：\n- 云服务器：¥9.9-30/月（学生机）\n- 域名：¥30-100/年（可选，.cn 域名更便宜）\n- **总计**：~¥10-50/月（含域名约 ¥20-60/月）\n!===\n\n**部署前的准备**：\n\n!===\n**1. 购买云服务器**\n\n**学生优惠申请**：\n- 阿里云学生机：https://developer.aliyun.com/plan/student\n- 腾讯云学生机：https://cloud.tencent.com/act/campus\n- 华为云学生机：https://developer.huaweicloud.com/campus\n\n**推荐配置**：\n- CPU：2核\n- 内存：2G-4G（Demo 项目 2G 够用）\n- 硬盘：40G\n- 操作系统：Ubuntu 22.04 LTS\n- 区域：选择离你最近的区域（如华东、华北）\n\n**2. 购买域名**（可选，但推荐）\n\n**为什么需要域名**：\n- ✅ 更专业（yourapp.com vs 120.78.123.45:8000）\n- ✅ 更好记\n- ✅ 可以配置 HTTPS\n- ✅ 简历加分项\n\n**推荐平台**：\n- 阿里云万网：https://wanwang.aliyun.com\n- 腾讯云 DNSPod：https://dnspod.cloud.tencent.com\n- 西部数码：https://www.west.cn\n\n**成本**：\n- `.cn` 域名：~¥30-50/年（国内域名，需要实名认证）\n- `.com` 域名：~¥60-100/年（国际域名）\n- `.top`、`.site` 域名：~¥10-30/年（新兴域名，更便宜）\n\n**备案说明**：\n- 使用国内云服务器 + 域名，需要备案（1-2 周）\n- 只用 IP 访问，不需要备案\n- 学习阶段可以先用 IP，后续再配置域名\n\n**3. 准备环境变量**\n- `OPENAI_API_KEY`、`DEEPSEEK_API_KEY` 等敏感信息\n- 不要写在代码里，用环境变量管理\n!===\n\n接下来，让我们详细了解后端和前端的部署思路。\n\n---\n\n# 块 2: 后端部署思路（Docker + 云服务器）\n\n## 为什么用 Docker？\n\nDocker 解决了\"在我电脑上能跑，在服务器上不能跑\"的问题。\n\n!===\n**传统部署的痛点**：\n- ❌ 服务器 Python 版本不一致（本地 3.11，服务器 3.8）\n- ❌ 依赖包版本冲突（本地 FastAPI 0.104，服务器 0.95）\n- ❌ 环境变量未设置\n- ❌ 手动配置繁琐，容易出错\n\n**Docker 的解决方案**：\n- ✅ **环境一致性**：打包完整环境（Python 版本 + 依赖包 + 环境变量）\n- ✅ **一次构建，到处运行**：本地、测试、生产环境完全一致\n- ✅ **隔离性**：不影响服务器的其他应用\n- ✅ **可复现**：删除容器后可快速重建\n!===\n\n## Docker 核心概念（5 分钟快速理解）\n\n!===\n**镜像（Image）vs 容器（Container）**：\n\n| 概念 | 类比 | 说明 | 示例 |\n|------|------|------|------|\n| **镜像** | 程序安装包 | 静态文件，包含代码 + 环境 | `my-ai-app:v1.0` |\n| **容器** | 运行中的程序 | 镜像的运行实例，可启动/停止 | `docker run my-ai-app` |\n\n**关系**：镜像 → 启动 → 容器（一个镜像可以启动多个容器）\n!===\n\n## 用 Vibe Coding 生成 Dockerfile\n\n还记得我们在第 4 章学过的\"用 AI 构建后端\"吗？部署配置文件（Dockerfile）也可以用 AI 生成！\n\n**步骤 1：理解 Dockerfile 的关键配置点**\n\n向'''{{sys_user_nickname}}'''讲解 Dockerfile 的 6 个核心部分：基础镜像、工作目录、安装依赖、复制代码、暴露端口、启动命令。用表格列出每个部分的作用和示例命令。\n\n**步骤 2：用 AI 生成 Dockerfile**\n\n引导'''{{sys_user_nickname}}'''不要手写 Dockerfile，而是用 Vibe Coding 让 AI 生成。向 ta 展示一个通用的 Prompt 模板，包含项目信息（Python 版本、依赖文件、入口文件、监听端口）和要求（使用 slim 镜像、优化缓存、添加注释等）。提醒 ta：AI 会生成完整的 Dockerfile（约 10-15 行）并且已经优化好。\n\n**步骤 3：用 AI 生成 .dockerignore**\n\n解释 .dockerignore 的作用（类似 .gitignore，告诉 Docker 哪些文件不要打包）。向'''{{sys_user_nickname}}'''展示一个 Prompt 模板，要求 AI 生成排除虚拟环境、Git 文件、开发工具配置、测试文档的规则。强调使用 .dockerignore 的三个好处：减少镜像大小、提高构建速度、提高安全性。\n\n## Docker 镜像构建与运行（实战）\n\n有了 Dockerfile 后，指导'''{{sys_user_nickname}}'''如何构建镜像并运行容器。\n\n**步骤 1：构建 Docker 镜像**\n\n向'''{{sys_user_nickname}}'''展示如何让 AI 教 ta 构建镜像。提供一个提问示例：\"我已经有了 Dockerfile，现在要构建镜像。项目名叫 my-ai-app，版本是 v1.0。请告诉我：1) 构建镜像的完整命令 2) 每个参数的含义 3) 如何验证镜像是否构建成功\"。\n\n**步骤 2：运行 Docker 容器**\n\n引导'''{{sys_user_nickname}}'''询问 AI 如何运行容器。提供一个提问示例，包含具体需求：后台运行、容器名称、端口映射（8000:8000）、传入环境变量（OPENAI_API_KEY）、持久化数据（如果需要）。强调让 AI 给出完整的 docker run 命令并解释每个参数。\n\n**步骤 3：验证容器运行状态**\n\n告诉'''{{sys_user_nickname}}'''如何验证容器是否正常运行。提供一个提问示例：如何查看容器状态、如何查看容器日志、如何测试 API（FastAPI 的 /docs 端点）、如果容器启动失败如何排查问题。\n\n## 云服务器部署完整流程\n\n现在指导'''{{sys_user_nickname}}'''把 Docker 容器部署到云服务器上。整个流程可以分为 5 个步骤。\n\n**步骤 1：连接到云服务器**\n\n告诉'''{{sys_user_nickname}}'''购买云服务器后会得到一个公网 IP，需要用 SSH 连接。向 ta 展示一个提问示例：假设购买了阿里云/腾讯云服务器（IP: 120.78.123.45，用户名 root），询问 AI 三个问题：1) 如何通过 SSH 连接 2) 连接后应该做哪些安全配置（禁用 root、创建普通用户、配置防火墙）3) 如何配置 SSH 密钥登录。\n\n**步骤 2：在服务器上安装 Docker**\n\n引导'''{{sys_user_nickname}}'''向 AI 询问如何在 Ubuntu 22.04 系统上安装 Docker。提供三个关键问题：1) 完整的安装命令 2) 如何验证安装成功 3) 如何让当前用户可以运行 Docker 命令（不用 sudo）。\n\n**步骤 3：上传代码到服务器**\n\n向'''{{sys_user_nickname}}'''介绍两种上传方式：Git 克隆（推荐，方便更新代码）和 SCP 上传（本地代码）。提供一个提问示例：询问 AI 如何用 Git 克隆项目到服务器（如果代码在 GitHub/Gitee），或者如何用 SCP 上传本地代码，以及如何验证代码完整性。\n\n**步骤 4：在服务器上构建并运行 Docker 容器**\n\n提醒'''{{sys_user_nickname}}'''：代码上传后，在服务器上构建镜像并运行容器的步骤和本地操作一样（参考前面的步骤 1-3）。\n\n**步骤 5：配置 Nginx 反向代理**\n\n向'''{{sys_user_nickname}}'''解释为什么需要 Nginx：1) 处理 HTTPS 2) 隐藏后端端口（用户访问 80/443，不是 8000）3) 负载均衡 4) 静态文件服务。\n\n提供一个提问示例：假设 FastAPI 应用运行在 localhost:8000，询问 AI 四个问题：1) 如何安装 Nginx 2) 如何生成配置文件（监听 80 端口，转发到 localhost:8000）3) 如何启用和验证配置 4) 如何处理 CORS 跨域问题（假设前端域名是 yourapp.com）。\n\n---\n\n# 块 3: 前端部署思路（云服务器 + Nginx / 对象存储）\n\n前端部署有两种主流方案，都适合国内环境。\n\n## 方案对比\n\n!===\n| 方案 | 优势 | 劣势 | 适用场景 | 成本 |\n|------|------|------|---------|------|\n| **云服务器 + Nginx**<br>（推荐） | 和后端一起部署<br>完全控制<br>无额外成本 | 需要配置 Nginx<br>不支持 CDN 加速 | 学习项目<br>前后端一体部署 | ¥0（复用后端服务器） |\n| **对象存储 + CDN**<br>（阿里云 OSS/腾讯云 COS） | CDN 加速<br>访问速度快<br>稳定性高 | 需要额外付费<br>配置稍复杂 | 生产环境<br>高流量应用 | ~¥10-50/月 |\n!===\n\n**推荐学习路径**：\n- **方案 1**：先用云服务器 + Nginx 部署（和后端一起，零额外成本）\n- **方案 2**：如果需要更好的性能，再考虑对象存储 + CDN\n\n## 方案 1: 云服务器 + Nginx（推荐新手）\n\n向'''{{sys_user_nickname}}'''介绍最简单的方案：前端和后端部署在同一台服务器上。\n\n**部署流程（4 步）**：\n\n**步骤 1：构建前端静态文件**\n\n告诉'''{{sys_user_nickname}}'''：Next.js 项目需要先构建成静态文件。提供一个提问示例：询问 AI 如何配置 next.config.ts 使用静态导出（output: 'export'）、如何运行构建命令、构建后的静态文件在哪个目录（通常是 out/）、如何验证构建成功。\n\n**步骤 2：上传静态文件到服务器**\n\n引导'''{{sys_user_nickname}}'''向 AI 询问：如何用 SCP 上传 out/ 目录到服务器的 /var/www/my-app 目录、上传后如何设置正确的文件权限、如何验证文件上传完整。\n\n**步骤 3：配置 Nginx 托管静态文件**\n\n提供一个提问示例：询问 AI 如何用 Nginx 托管前端静态文件，要求包括：1) 静态文件位于 /var/www/my-app 2) 监听 80 端口 3) 支持 Next.js 的路由（所有路由都指向 index.html）4) 配置 API 代理（/api/* 转发到 localhost:8000）。强调让 AI 生成 Nginx 配置文件并告诉如何启用。\n\n**步骤 4：配置环境变量**\n\n向'''{{sys_user_nickname}}'''解释：前端需要知道后端 API 地址。提供一个提问示例：询问 AI 四个问题：1) 如何在 .env.production 文件中设置 API 地址 2) Next.js 环境变量的命名规则（NEXT_PUBLIC_ 前缀）3) 如何在前端代码中读取环境变量 4) 构建时如何加载 .env.production 文件。\n\n总结方案 1 的优劣：优势是前后端一体部署管理方便、零额外成本（复用后端服务器）、学习完整的 Nginx 配置；劣势是没有 CDN 加速（访问速度取决于服务器位置）、单点故障（服务器挂了前后端都挂）。\n\n---\n\n## 方案 2: 对象存储 + CDN（生产环境推荐）\n\n向'''{{sys_user_nickname}}'''介绍进阶方案：对象存储（OSS/COS）是云服务商提供的文件存储服务，天然支持 CDN 加速。\n\n**部署流程（4 步）**：\n\n**步骤 1：购买对象存储服务**\n\n提供一个提问示例：询问 AI 如何使用阿里云 OSS / 腾讯云 COS 部署前端，包含四个问题：1) 如何开通对象存储服务 2) 如何创建存储桶（Bucket）3) 如何配置公开访问权限 4) 学生优惠有哪些（如果有）。\n\n---\n\n**步骤 2：上传静态文件到对象存储**\n\n引导'''{{sys_user_nickname}}'''向 AI 询问：如何把 Next.js 构建后的静态文件上传到 OSS/COS，包含四个问题：1) 如何安装命令行工具 2) 如何上传 out/ 目录到存储桶 3) 如何设置文件的 MIME 类型（确保 .html/.js/.css 能正确访问）4) 如何配置默认首页（index.html）。\n\n---\n\n**步骤 3：配置 CDN 加速**\n\n提供一个提问示例：询问 AI 如何为对象存储配置 CDN 加速，包含四个问题：1) 如何开通 CDN 服务 2) 如何绑定存储桶到 CDN 域名 3) 如何配置缓存策略（静态文件缓存 1 天，HTML 不缓存）4) 如何配置 HTTPS（免费 SSL 证书）。\n\n---\n\n**步骤 4：配置自定义域名（可选）**\n\n提供一个提问示例：询问 AI 如何为 CDN 绑定自定义域名（假设是 yourapp.com），包含四个问题：1) 如何在 DNS 中添加 CNAME 记录指向 CDN 域名 2) 如何在 CDN 控制台添加自定义域名 3) 如何配置 HTTPS 证书 4) 如何验证域名配置成功。\n\n---\n\n总结方案 2 的优劣和成本。优势：CDN 全国加速访问速度快、高可用（云服务商保证 99.9% 可用性）、自动扩容（不担心流量暴增）。劣势：需要额外付费（~¥10-50/月）、配置稍复杂（需要学习 OSS/COS/CDN）。\n\n成本估算（阿里云 OSS）：存储费用 ¥0.12/GB/月（静态文件通常 < 100MB，几乎免费）、流量费用 ¥0.5/GB（每月 1000 次访问 ≈ 1GB，约 ¥0.5）、CDN 费用 ¥0.24/GB（每月约 ¥1-10）、总计 ~¥10-50/月（取决于访问量）。\n\n---\n\n# 块 4: 域名配置与常见问题\n\n## 域名配置思路\n\n**步骤 1：购买域名**\n\n向'''{{sys_user_nickname}}'''介绍国内域名购买平台和选择建议。用表格对比不同后缀的域名（.com、.cn、.top 等）的成本和特点。强调：国内平台（阿里云、腾讯云）需要实名认证，国内服务器 + 域名需要备案（1-2 周）。\n\n---\n\n**步骤 2：DNS 解析**\n\n向'''{{sys_user_nickname}}'''讲解 A 记录和 CNAME 记录的区别。用表格对比两者的指向、适用场景和示例（A 记录指向云服务器 IP，CNAME 记录指向 CDN 域名）。\n\n提供 DNS 配置的四个步骤：1) 登录域名服务商 2) 找到\"DNS 解析\"或\"域名管理\"3) 添加记录（后端用 A 记录指向服务器 IP，前端用 CNAME 记录指向 CDN 域名）4) 等待 DNS 生效（几分钟到几小时）。\n\n告诉'''{{sys_user_nickname}}'''如何验证 DNS 是否生效：可以用 dig 命令查询 A 记录和 CNAME 记录，也可以直接访问域名看是否能打开网站。\n\n---\n\n**步骤 3：配置 HTTPS（SSL 证书）**\n\n向'''{{sys_user_nickname}}'''介绍 Let's Encrypt 免费证书和 Certbot 自动化工具。告诉 ta 三个步骤：1) 安装 Certbot（sudo apt install certbot python3-certbot-nginx）2) 为 Nginx 配置 HTTPS（sudo certbot --nginx -d yourapp.com）3) Certbot 会自动申请证书、配置 Nginx HTTPS、设置自动续期（证书 90 天过期）。\n\n提醒'''{{sys_user_nickname}}'''如何验证 HTTPS：访问 https://yourapp.com，浏览器地址栏显示🔒图标。\n\n---\n\n## 常见部署问题与 Vibe Coding 排查\n\n向'''{{sys_user_nickname}}'''强调：遇到部署问题时，不要慌张，用 Vibe Coding 让 AI 帮你排查！\n\n列出 7 个最常见的部署问题，每个问题包含症状和排查方向：\n\n**问题 1：端口被占用**\n症状：Error: address already in use :::8000\n排查方向：如何查找占用端口的进程、如何停止进程、如何换一个端口\n\n---\n\n**问题 2：防火墙拦截**\n症状：本地 curl localhost:8000 可以访问，外网 curl your-server-ip:8000 无法访问\n排查方向：如何开放 Ubuntu 防火墙端口、如何在云服务器控制面板开放安全组\n\n---\n\n**问题 3：环境变量未设置**\n症状：Error: OPENAI_API_KEY not found\n排查方向：如何在 docker run 时传入环境变量、如何使用 .env 文件\n\n---\n\n**问题 4：CORS 跨域错误**\n症状：浏览器控制台显示 \"has been blocked by CORS policy\"\n排查方向：如何在 FastAPI 中添加 CORS 中间件、如何在 Nginx 配置中添加 CORS 头\n\n---\n\n**问题 5：SSL 证书过期**\n症状：ERR_CERT_DATE_INVALID\n排查方向：如何检查 Certbot 自动续期配置、如何手动续期证书\n\n---\n\n**问题 6：前端构建失败**\n症状：npm run build 命令失败\n排查方向：如何排查 TypeScript 类型错误、如何检查环境变量是否设置、如何查看构建日志\n\n---\n\n**问题 7：Docker 镜像过大**\n症状：docker images 显示镜像超过 2GB\n排查方向：如何使用 slim 镜像、如何使用 .dockerignore 排除文件、如何多阶段构建\n\n---\n\n教'''{{sys_user_nickname}}'''一个通用的排查套路：遇到任何部署问题，都可以向 AI 询问：\"我在部署时遇到 [错误信息]，请帮我分析原因并给出解决方案。\"强调：AI 是你的调试助手，善用 Vibe Coding 可以快速解决问题。\n\n恭喜'''{{sys_user_nickname}}'''！已经掌握了项目部署的完整思路。接下来，让我们规划进阶学习路径。\n"
    },
    {
      "outline_item_bid": "2ec38c2823e9407f925fd7b88b1db41c",
      "title": "AI 应用开发的三种模式对比",
      "type": 401,
      "hidden": 0,
      "parent_bid": "691a0bb7866e447895e365fc262c5454",
      "position": "0201",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1:三种开发模式全景介绍\n\n欢迎来到第二章!完成第一章后,你已经对这门课程有了整体认识,也配置好了开发环境。现在,让我们进入一个非常关键的话题:**如何选择合适的 AI 应用开发工具?**\n\n在开始动手开发之前,我想带你看看当前 AI 应用开发的**三种主流模式**。理解它们的差异,会帮助你更清楚地知道为什么我们选择 MarkdownFlow,以及在什么场景下应该使用什么工具。\n\n结合你的背景'''{{sys_user_background}}''',我会用你容易理解的方式来解释这三种模式。\n\n---\n## AI 应用开发的三种模式\n\n### 1. 低代码平台模式\n\n**代表工具**:扣子(Coze)、Dify、FastGPT\n\n**核心特点**:\n- 可视化拖拽式开发\n- 内置大量预设模板\n- 快速搭建原型\n- 几乎不需要写代码\n\n**适合场景**:\n- 快速验证想法\n- 简单的对话机器人\n- 标准化的业务流程自动化\n\n**局限性**:\n- 定制能力有限\n- 复杂逻辑难以实现\n- 难以集成到现有系统\n- 平台绑定,迁移困难\n\n---\n\n### 2. 工作流编排模式\n\n**代表工具**:LangChain、LlamaIndex、Semantic Kernel\n\n**核心特点**:\n- 代码级开发\n- 模块化组件\n- 灵活的流程编排\n- 需要编程基础\n\n**适合场景**:\n- 复杂的 AI 应用\n- 需要深度定制\n- 与现有系统集成\n- 生产级部署\n\n**局限性**:\n- 学习曲线陡峭\n- 代码量大(数百上千行)\n- 需要理解多个抽象层\n- 调试复杂\n\n---\n\n### 3. MarkdownFlow 模式\n\n**代表工具**:MarkdownFlow(本课程教学工具)\n\n**核心特点**:\n- 用自然语言控制 AI 输出\n- Markdown 语法,易学易用\n- 代码级灵活性\n- 专注内容逻辑,而非技术细节\n\n**适合场景**:\n- 交互式内容生成\n- 教育培训场景\n- 个性化内容交付\n- 快速迭代验证\n\n**局限性**:\n- 专注于内容生成,不适合所有场景\n- 相对较新,生态较小\n---\n\n你可能会想:**这三种模式到底有什么本质区别?** 让我用一个具体例子来说明。\n\n假设你要开发一个**AI 职业规划助手**,它需要根据用户的背景、技能、兴趣,给出个性化的职业建议。\n\n!===\n| 开发模式 | 实现方式 | 工作量 | 灵活性 | 代码量 |\n|---------|---------|--------|--------|--------|\n| **低代码平台** | 在扣子/Dify 中配置对话流程、设置变量、连接知识库 | ⭐⭐ 低 | ⭐⭐ 中等 | 几乎为 0 |\n| **工作流编排** | 用 Python 编写 LangChain 代码,定义 Agent、Tool、Memory 等 | ⭐⭐⭐⭐ 高 | ⭐⭐⭐⭐⭐ 非常高 | 500-1000 行 |\n| **MarkdownFlow** | 用 Markdown 编写交互式文档,定义问题、选项、输出格式 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐ 高 | 50-100 行 |\n!===\n\n从表格可以看出,**MarkdownFlow 在工作量和灵活性之间达到了很好的平衡**。它比低代码平台更灵活,比工作流编排更简洁。\n\n---\n\n# 块 2:三种模式的决策树\n\n现在你可能会问:**我应该选择哪种模式?**\n\n这取决于你的具体需求。让我给你一个决策树,帮助你快速判断:\n\n```mermaid\ngraph TD\n    A[开始选择开发模式] --> B{是否需要代码级控制?}\n    B -->|不需要,快速验证想法| C[低代码平台<br/>扣子/Dify]\n    B -->|需要| D{应用的核心是什么?}\n\n    D -->|复杂的业务逻辑<br/>多系统集成| E[工作流编排<br/>LangChain/LlamaIndex]\n    D -->|交互式内容生成<br/>个性化交付| F[MarkdownFlow]\n\n    C --> G{平台能力够用吗?}\n    G -->|够用| H[✅ 使用低代码平台]\n    G -->|不够用| I[考虑迁移到<br/>代码级开发]\n\n    E --> J[✅ 使用工作流编排]\n    F --> K[✅ 使用 MarkdownFlow]\n\n    I --> D\n\n    style H fill:#90EE90\n    style J fill:#90EE90\n    style K fill:#90EE90\n```\n\n**关键判断点**:\n\n1. **如果你只是想快速验证一个想法**,比如做一个简单的客服机器人,用**低代码平台**最快。\n\n2. **如果你需要构建复杂的 AI 系统**,比如多 Agent 协作、复杂的知识检索,用**工作流编排**。\n\n3. **如果你的核心需求是生成个性化、交互式的内容**,比如教育课程、咨询服务,用 **MarkdownFlow**。\n\n结合你的学习目标'''{{learning_goal}}''',我会给你一些针对性的建议。\n\n如果你的目标是**快速入门 AI 开发**,建议你**三种模式都体验一下**,这样你会对整个生态有全面的认识。\n\n如果你的目标是**深入学习 MarkdownFlow**,建议你先快速过一遍低代码平台,理解它的局限性,然后重点放在 MarkdownFlow 上。\n\n如果你的目标是**开发自己的 AI 产品**,建议你先明确产品的核心需求,然后根据决策树选择最合适的模式。\n\n---\n\n# 块 3:工具使用经验调研\n\n在继续之前,我想了解一下你对这些工具的了解程度。这会帮助我调整后续内容的详细程度。\n\n下面列出了一些常见的 AI 开发工具,请选择你**用过**或**了解过**的工具(可以多选)。如果都没用过,也完全没关系,我们会在接下来的实操环节手把手带你体验。\n\n?[%{{tool_experience}} 扣子(Coze)||Dify||n8n||都没用过]\n\n根据你的选择,我会调整后续实操环节的详细程度。如果你已经用过扣子或 Dify,我会快速过重点;如果你都没用过,我会提供非常详细的分步指导。\n\n---\n\n现在,让我们进入激动人心的实操环节!在下一节,你会亲手体验**扣子**和 **Dify** 这两个低代码平台,感受一下用拖拽方式开发 AI 应用是什么样的。\n\n体验完低代码平台后,我们会在 2.3 节详细对比 **MarkdownFlow 的优势**,让你深刻理解为什么我们选择它作为课程的教学工具。\n\n用你喜欢的讲课风格'''{{sys_user_style}}''',鼓励 {{sys_user_nickname}} 继续下一节的学习。\n"
    },
    {
      "outline_item_bid": "6b25fda1a9fe48ffb334a41c033703e5",
      "title": "MarkdownFlow 核心概念速成",
      "type": 401,
      "hidden": 0,
      "parent_bid": "ec716ba63dad4e618178f02675c0c3bb",
      "position": "0402",
      "prerequisite_item_bids": "",
      "llm": "",
      "llm_temperature": 0.3,
      "llm_system_prompt": "",
      "ask_enabled_status": 5101,
      "ask_llm": "",
      "ask_llm_temperature": 0.3,
      "ask_llm_system_prompt": "",
      "content": "# 块 1: 为什么 MarkdownFlow 语法是你必须精通的核心技能?\n\n{{sys_user_nickname}},现在我们进入第四章最重要的部分:**MarkdownFlow 语法深度掌握**。\n\n我要先强调一个重要的学习原则:在整个后端开发学习中,**MarkdownFlow 语法是唯一需要你精通的技能**,其他的(Python、FastAPI、数据库)都可以让 AI 帮你处理。\n\n为什么这么说?让我用一个类比帮你理解:\n\n!===\n| 类比 | MarkdownFlow 语法 | Python/FastAPI 代码 |\n|------|------------------|-------------------|\n| **建筑师** | 设计图纸 | 施工细节 |\n| **导演** | 剧本 | 摄影机操作 |\n| **指挥家** | 乐谱 | 乐器演奏技巧 |\n\n!===\n\n---\n!===\n在 Vibe Coding 模式下:\n- **MarkdownFlow** = **你的设计图纸 / 剧本 / 乐谱** - 这是你的创意和设计,必须你自己精通\n- **Python 代码** = **施工 / 拍摄 / 演奏** - 这些执行细节可以交给 AI\n\n**所以本节内容分配**:\n- MarkdownFlow 语法:**40% 篇幅,深入讲解,必须精通**\n- Python/FastAPI:**不讲,AI 会处理**\n- AI 工作流:**30% 篇幅,学会与 AI 协作**\n\n结合你的学习目标'''{{learning_goal}}''',精通 MarkdownFlow 语法意味着:\n- 你能**设计**任意复杂的交互流程\n- 你能**控制** AI 生成的内容格式和风格\n- 你能**调试** MarkdownFlow 文档中的问题\n\n准备好了吗?让我们从变量系统开始,系统学习 MarkdownFlow 的每一个语法细节。\n\n!===\n\n---\n!===\n# 块 2: 变量系统完全指南 - 可替换变量 vs 交互变量\n\n**MarkdownFlow 有两种变量形式**,理解它们的区别是关键:\n\n```bash\n类型:\n可替换变量\n语法:\n{{var}} \n作用:\nAI 替换为实际内容\n值来源:\n交互传入\n使用位置:\n任意位置\n示例:\n你好 {{name}}\n\n类型:\n交互变量\n语法:\n%{{var}}\n作用:\n收集用户输入\n值来源:\n用户点击 / 输入\n使用位置:\n只能在 `?[]` 内\n示例:\n?[%{{city}} 北京|上海]\n```\n\n!===\n---\n!===\n**1. 可替换变量 **\n\n**用途**:在生成时被 AI 替换为动态内容\n\n**示例 1**: 简单替换\n\n```markdown\n你好 {{user_name}}!\n\n今天是 {{current_date}},天气 {{weather}}。\n```\n\n\n**AI 会将变量替换为实际内容**:\n\n```markdown\n你好 张三!\n\n今天是 2025 年 12 月 12 日,天气 晴朗。\n```\n\n\n**示例 2**: 变量嵌套（用于复杂数据结构）\n\n```markdown\n你好 {{user.name}}, 你的邮箱是 {{user.email}}\n```\n\n\n**代码传入**:\n\n```python\nvariables = {\n    \"user\": {\n        \"name\": \"张三\",\n        \"email\": \"zhangsan@example.com\"\n    }\n}\n```\n!===\n---\n!===\n\n**2. 交互变量**\n\n**用途**:收集用户输入,存储到变量中\n\n**示例**:\n```markdown\n?[%{{city}} 北京|上海|深圳|广州]\n```\n\n**前端会渲染为按钮**:\n```\n[ 北京 ] [ 上海 ] [ 深圳 ] [ 广州 ]\n```\n\n**用户点击\"上海\"后**:\n```markdown\n`city` 变量被设置为 `\"上海\"`\n后续块可以使用 `{{city}}` 引用\n```\n**3. 变量强调语法 **\n\n**用途**:告诉 AI 这个变量特别重要,生成内容时要重点关注\n\n**❌ 不强调时**:\n```markdown\n用户选择的城市是 {{city}},请介绍这个城市。\n```\n\nAI 生成:\n```markdown\n用户选择的城市是上海,请介绍这个城市。\n\n中国有很多美丽的城市,比如北京、上海、深圳...\n```\n\n**✅ 强调后**:\n```markdown\n用户选择的城市是'''{{city}}''',请重点介绍这个城市的特色。\n```\n\nAI 生成:\n```markdown\n用户选择的城市是上海,请重点介绍这个城市的特色。\n\n上海是中国最大的经济中心,拥有外滩、东方明珠等著名景点...\n（AI 会生成更多关于上海的内容,而非泛泛而谈）\n```\n!===\n---\n!===\n\n```markdown\n**变量命名规范**:\n- ✅ 使用清晰的变量名:`{{user_name}}` 而非 `{{n}}`\n- ✅ 使用英文下划线:`{{user_age}}` 而非 `{{用户年龄}}`\n- ❌ 避免特殊字符:不要用 `{{user-name}}` 或 `{{user.name}}`(嵌套除外)\n```\n!===\n---\n!===\n\n# 块 3: 交互元素完整指南 - 单选 / 多选 / 自由输入\n\n**MarkdownFlow 提供 3 种交互元素**,让你收集用户输入:\n\n**1. 单选交互 **\n\n**语法**:\n\n```markdown\n?[%{{variable_name}} 选项1|选项2|选项3|...]\n```\n\n\n**示例 1**: 简单单选\n\n```markdown\n?[%{{difficulty}} 简单|中等|困难]\n```\n\n前端渲染:\n```\n[ 简单 ] [ 中等 ] [ 困难 ]\n```\n\n\n**示例 2**: 带提示文字的单选\n\n```markdown\n请选择你的技术栈:\n\n?[%{{tech_stack}} Python|JavaScript|Go|Rust]\n```\n\n\n**示例 3**: 使用 `...` 允许自由输入\n\n```markdown\n?[%{{city}} 北京|上海|深圳|...其他城市]\n```\n\n用户可以:\n- 点击\"北京\"、\"上海\"、\"深圳\"\n- 或点击\"其他城市\",输入自定义内容\n!===\n---\n!===\n\n**2. 多选交互 **\n\n**⚠️ 注意**: 使用 `||`(双竖线)而非 `|`(单竖线)\n\n**语法**:\n\n```markdown\n?[%{{variable_name}} 选项1||选项2||选项3||...]\n```\n\n\n**示例**:\n\n```markdown\n请选择你感兴趣的主题(可多选):\n\n?[%{{interests}} 技术||商业||生活||旅游||美食]\n```\n\n前端渲染:\n```\n☐ 技术  ☐ 商业  ☐ 生活  ☐ 旅游  ☐ 美食\n```\n\n用户选择后: `interests = [\"技术\", \"生活\", \"美食\"]`(数组)\n\n!===\n---\n\n!===\n\n# 块 4: 块分隔与流程控制 \n\n**块分隔符 `---` 的作用**:将 MarkdownFlow 内容分成多个块,按顺序处理\n\n**示例**: 渐进式收集信息\n\n```markdown\n# 块 0: 收集类别\n你好 {{name}}! 我是你的 AI 助手。\n\n?[%{{category}} 技术|商业|生活]\n```\n!===\n---\n!===\n```markdown\n# 块 1: 收集详细主题\n你选择了: '''{{category}}'''\n\n?[%{{topic}} 请输入你感兴趣的具体主题]\n\n---\n\n# 块 2: 生成内容\n关于 {{category}} - {{topic}} 的内容:\n\n(AI 会根据两个变量生成个性化内容)\n```\n!===\n\n---\n\n!===\n**执行流程**:\n```bash\n步骤 1: 前端发送 block_index=0\n    → 渲染块 0\n    → 用户选择\"技术\"\n    → city = \"技术\"\n\n步骤 2: 前端发送 block_index=1, variables={\"category\": \"技术\"}\n    → 渲染块 1\n    → 显示\"你选择了: 技术\"\n    → 用户输入\"AI 应用开发\"\n    → topic = \"AI 应用开发\"\n\n步骤 3: 前端发送 block_index=2, variables={\"category\": \"技术\", \"topic\": \"AI 应用开发\"}\n    → 渲染块 2\n    → AI 根据两个变量生成内容\n```\n\n\n**块设计的最佳实践**:\n\n**原则**: 每个块做一件事\n\n**✅ 好的设计**:\n\n```markdown\n# 块 0: 只收集城市\n?[%{{city}} 北京|上海|深圳]\n```\n!===\n---\n!===\n# 块 1: 只收集兴趣\n```markdown\n欢迎来到 {{city}}! 你对什么感兴趣?\n\n?[%{{interest}} 美食|景点|文化]\n```\n\n# 块 2: 只生成内容\n```markdown\n关于 {{city}} 的 {{interest}} 推荐...\n\n(AI 生成内容)\n```\n!===\n---\n\n!===\n**❌ 不好的设计**:\n\n```markdown\n# 块 0: 做了太多事\n?[%{{city}} ...]\n?[%{{interest}} ...]\n然后马上生成内容...\n# 问题: 用户体验差,一次性收集太多信息\n```\n\n\n**条件分支实现技巧**:\n\n**场景**: 根据用户选择显示不同内容\n\n**示例**:\n\n```markdown\n# 块 0\n?[%{{level}} 初学者|进阶者|专家]\n```\n!===\n---\n!===\n```markdown\n# 块 1\n{{level}} 的学习路径:\n\n(AI 会根据 level 生成不同难度的内容)\n- 初学者: 基础概念、入门教程\n- 进阶者: 最佳实践、进阶技巧\n- 专家: 架构设计、性能优化\n```\n\n\n**实现原理**: AI 会根据变量值生成不同内容,无需手动编写 if-else\n!===\n---\n!===\n# 块 5: 保留内容高级用法 - 用 `===...===` 保护固定内容\n\n**为什么需要保留内容?**\n\n在 MarkdownFlow 中,默认情况下 AI 会\"润色\"你的内容。但有些内容(如联系方式、定价表)必须保持原样,不能被 AI 修改。\n\n**MarkdownFlow 提供两种保留语法**:\n\n**1. 单行保留 `===内容===`**\n\n**作用**: 确保这一行内容不会被 AI 修改\n\n**示例**:\n\n```markdown\n关于 Python 的学习建议:\n\n(AI 生成的内容)\n\n===联系方式: support@example.com===\n```\n\n\n**效果**: 无论 AI 如何生成内容,联系方式始终不变\n\n**2. 多行保留 `!===...!===`**\n\n**作用**: 确保这段内容不会被 AI 修改\n\n**示例**:\n\n```markdown\n!===\n## 重要提示\n\n1. 请勿分享个人信息\n2. 遇到问题请联系客服\n3. 本服务仅供学习使用\n!===\n```\n!===\n---\n\n!===\n\n**使用场景总结**:\n\n**✅ 应该保留**:\n- 联系方式、客服信息\n- 定价表、功能对比表\n- 法律声明、免责条款\n- 固定格式的代码示例\n- 品牌标识、版权信息\n\n**❌ 不应该保留**:\n- AI 需要根据用户输入生成的内容\n- 需要个性化的内容\n- 需要动态变化的内容\n\n**完整示例**: 客服机器人\n\n```markdown\n你好 {{user_name}}!\n\n?[%{{issue_type}} 账号问题|支付问题|功能咨询|...其他问题]\n\n我了解到你遇到了 {{issue_type}}。\n\n(AI 根据问题类型生成解决方案)\n\n!===\n如需进一步帮助,请联系:\n- 客服微信: CustomerService2024\n- 工作时间: 9:00-18:00\n- 邮箱: support@example.com\n!===\n```\n\n!===\n\n---\n!===\n# 块 6: 常见错误与调试技巧 - 如何快速定位问题\n\n**错误 1: 变量未替换**\n\n**现象**: 输出 `{{user_name}}` 而非 `张三`\n\n**可能原因**:\n1. 变量名拼写错误\n2. 代码中未传入该变量\n3. 变量在 \n```markdown\n===...===\n```\n保留内容中(保留内容不会替换变量)\n\n**解决方法**:\n\n```bash\n# 使用 API 检查变量\ncurl -X POST http://localhost:8000/api/v1/playground/markdownflow_info \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"你好 {{user_name}}!\"}'\n\n# 检查响应中的 variables 列表\n# 确认变量名拼写正确\n```\n\n!===\n---\n!===\n\n**错误 2: 交互未识别**\n\n**现象**: 前端没有渲染交互按钮\n\n**可能原因**:\n```markdown\n1. 语法错误:`?[%{city}]` 缺少一个 `{`\n2. 分隔符错误:单选用了 `||`,多选用了 `|`\n3. 位置错误:交互元素在保留内容 `!===...!===` 中\n```\n**正确语法对比**:\n\n```markdown\n# ✅ 单选(单竖线)\n?[%{{city}} 北京|上海]\n\n# ✅ 多选(双竖线)\n?[%{{interests}} 技术||商业]\n\n# ✅ 自由输入\n?[{{question}} 请输入]\n```\n!===\n---\n!===\n\n**错误 3: 保留内容被修改**\n\n**现象**: 原本应该固定的内容被 AI 改了\n\n**原因**: 使用了 `===...===` 而非 `!===...!===`(单行 vs 多行)\n\n**解决**:\n\n```markdown\n# ❌ 错误: 单行保留只能保留一行\n!===\n第一行\n第二行\n!===\n# 第二行、第三行会被 AI 修改\n\n# ✅ 正确: 多行保留\n!===\n第一行\n第二行\n第三行\n!===\n```\n\n\n**错误 4: 多选结果异常**\n\n**现象**: 多选只返回一个值\n\n**原因**: 使用了单竖线 `|` 而非双竖线 `||`\n\n**解决**:\n\n```markdown\n# ❌ 错误: 单竖线是单选\n?[%{{skills}} Python|JavaScript|Go]\n\n# ✅ 正确: 双竖线是多选\n?[%{{skills}} Python||JavaScript||Go]\n```\n!===\n---\n!===\n**调试技巧总结**:\n\n1. **使用 `/markdownflow_info` API 检查语法**\n   ```bash\n   curl -X POST http://localhost:8000/api/v1/playground/markdownflow_info \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"content\": \"你的 MarkdownFlow 内容\"}'\n   ```\n\n2. **检查变量列表**\n```markdown\n   - 确认所有变量都在代码中传入\n   - 检查变量名拼写\n```\n\n3. **检查交互元素**\n```markdown\n   - 确认语法正确(`?[%{{var}} 选项]`)\n   - 确认分隔符正确(单选 `|`,多选 `||`)\n```\n\n5. **检查保留内容**\n```markdown\n   - 单行用 `===...===`\n   - 多行用 `!===...!===`\n```\n!===\n\n---\n!===\n**4.2 小结**:\n\n你现在应该精通了 MarkdownFlow 的所有核心语法:\n- ✅ 变量系统:\n```markdown\n{{var}} vs %{{var}}\n- ✅ 交互元素:单选 `|`、多选 `||`、自由输入\n- ✅ 块分隔:`---` 构建多步骤流程\n- ✅ 保留内容:`===...===` vs `!===...!===`\n- ✅ 调试技巧:使用 API 检查语法\n```\n\n这是本章最重要的内容,也是你在 Vibe Coding 中必须精通的技能。接下来,我们将学习如何用 AI 构建后端 API,将 MarkdownFlow 语法应用到实际开发中。\n!===\n\n"
    }
  ],
  "structure": {
    "bid": "51ee98a2341940b3a96774b5cb9559cb",
    "id": 869,
    "type": "shifu",
    "children": [
      {
        "bid": "3f837fb309554304bd731f6a519867e5",
        "id": 12185,
        "type": "outline",
        "children": [
          {
            "bid": "7630236d3bac43568740e06722473813",
            "id": 15778,
            "type": "outline",
            "children": [],
            "child_count": 7
          },
          {
            "bid": "627fad460fa74f5ca3e8766c5eeee7b4",
            "id": 12187,
            "type": "outline",
            "children": [],
            "child_count": 5
          },
          {
            "bid": "c320a9c01a52418d85d746928b826c8a",
            "id": 15787,
            "type": "outline",
            "children": [],
            "child_count": 6
          },
          {
            "bid": "5d5fb1aa3063437abf5d7bbbaa1989d6",
            "id": 15819,
            "type": "outline",
            "children": [],
            "child_count": 16
          }
        ],
        "child_count": 0
      },
      {
        "bid": "691a0bb7866e447895e365fc262c5454",
        "id": 12190,
        "type": "outline",
        "children": [
          {
            "bid": "2ec38c2823e9407f925fd7b88b1db41c",
            "id": 17137,
            "type": "outline",
            "children": [],
            "child_count": 10
          },
          {
            "bid": "a9e87bd5ea524dfab324b7435ef92f16",
            "id": 15846,
            "type": "outline",
            "children": [],
            "child_count": 12
          },
          {
            "bid": "bbf23d951bac4e768920849ff53de68f",
            "id": 15906,
            "type": "outline",
            "children": [],
            "child_count": 8
          },
          {
            "bid": "f598253d43d6463da213139edca47cdc",
            "id": 15910,
            "type": "outline",
            "children": [],
            "child_count": 5
          }
        ],
        "child_count": 0
      },
      {
        "bid": "bf841234eae84d6dbf0ee3122354e06f",
        "id": 12195,
        "type": "outline",
        "children": [
          {
            "bid": "ee80e78db5f64d47849c9b7876e52c03",
            "id": 15937,
            "type": "outline",
            "children": [],
            "child_count": 13
          },
          {
            "bid": "01f49f7d879b46a5b56dac0dd16a2ed9",
            "id": 16279,
            "type": "outline",
            "children": [],
            "child_count": 8
          },
          {
            "bid": "cd85a52fb3914a83bcdc2276dcbf72c2",
            "id": 16306,
            "type": "outline",
            "children": [],
            "child_count": 7
          },
          {
            "bid": "150776fadf6d4afead7e83da3d5c8615",
            "id": 16339,
            "type": "outline",
            "children": [],
            "child_count": 12
          }
        ],
        "child_count": 0
      },
      {
        "bid": "ec716ba63dad4e618178f02675c0c3bb",
        "id": 15717,
        "type": "outline",
        "children": [
          {
            "bid": "f15259aee98b4f82bb6dc16af6ee87fd",
            "id": 16354,
            "type": "outline",
            "children": [],
            "child_count": 8
          },
          {
            "bid": "6b25fda1a9fe48ffb334a41c033703e5",
            "id": 17744,
            "type": "outline",
            "children": [],
            "child_count": 21
          },
          {
            "bid": "403cae06018a429eb64d80e188d37b6a",
            "id": 16020,
            "type": "outline",
            "children": [],
            "child_count": 7
          },
          {
            "bid": "500bdfd36a4d42328392af962156d809",
            "id": 16023,
            "type": "outline",
            "children": [],
            "child_count": 6
          }
        ],
        "child_count": 0
      },
      {
        "bid": "0bc85fd1cd3a43a18c2cdc704910b505",
        "id": 15729,
        "type": "outline",
        "children": [
          {
            "bid": "0ee3261224e2464487fc972fad701fee",
            "id": 16024,
            "type": "outline",
            "children": [],
            "child_count": 5
          },
          {
            "bid": "740fd6ef6dd741c0a12a47b8e8faa615",
            "id": 16025,
            "type": "outline",
            "children": [],
            "child_count": 7
          },
          {
            "bid": "775b0f05a75345348d95f09c6ab689b0",
            "id": 16608,
            "type": "outline",
            "children": [],
            "child_count": 7
          },
          {
            "bid": "16b5be108ab547dfaceaceca0a4dee4f",
            "id": 16027,
            "type": "outline",
            "children": [],
            "child_count": 6
          }
        ],
        "child_count": 0
      },
      {
        "bid": "7e10d317f3b444cabdfd70aa0e3e7a2c",
        "id": 15771,
        "type": "outline",
        "children": [
          {
            "bid": "386d036a05fa41be8b19a4afe41b7649",
            "id": 16028,
            "type": "outline",
            "children": [],
            "child_count": 10
          },
          {
            "bid": "3f44cddca033468cbcf37e4d0607e678",
            "id": 16269,
            "type": "outline",
            "children": [],
            "child_count": 4
          },
          {
            "bid": "1f14b2129cce49f98de46fadd842c9d5",
            "id": 16692,
            "type": "outline",
            "children": [],
            "child_count": 19
          },
          {
            "bid": "8d3dbf94ec1443ca930a37ba690d4f07",
            "id": 16659,
            "type": "outline",
            "children": [],
            "child_count": 5
          }
        ],
        "child_count": 0
      }
    ],
    "child_count": 0
  }
}
